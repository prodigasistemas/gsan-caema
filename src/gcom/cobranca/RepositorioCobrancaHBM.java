/*
 * Copyright (C) 2007-2007 the GSAN - Sistema Integrado de Gest?o de Servi?os de Saneamento
 *
 * This file is part of GSAN, an integrated service management system for Sanitation
 *
 * GSAN is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * GSAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 */

/*
 * GSAN - Sistema Integrado de Gest?o de Servi?os de Saneamento
 * Copyright (C) <2007> 
 * Adriano Britto Siqueira
 * Alexandre Santos Cabral
 * Ana Carolina Alves Breda
 * Ana Maria Andrade Cavalcante
 * Aryed Lins de Ara?jo
 * Bruno Leonardo Rodrigues Barros
 * Carlos Elmano Rodrigues Ferreira
 * Cl?udio de Andrade Lira
 * Denys Guimar?es Guenes Tavares
 * Eduardo Breckenfeld da Rosa Borges
 * Fab?ola Gomes de Ara?jo
 * Fl?vio Leonardo Cavalcanti Cordeiro
 * Francisco do Nascimento J?nior
 * Homero Sampaio Cavalcanti
 * Ivan S?rgio da Silva J?nior
 * Jos? Edmar de Siqueira
 * Jos? Thiago Ten?rio Lopes
 * K?ssia Regina Silvestre de Albuquerque
 * Leonardo Luiz Vieira da Silva
 * M?rcio Roberto Batista da Silva
 * Maria de F?tima Sampaio Leite
 * Micaela Maria Coelho de Ara?jo
 * Nelson Mendon?a de Carvalho
 * Newton Morais e Silva
 * Pedro Alexandre Santos da Silva Filho
 * Rafael Corr?a Lima e Silva
 * Rafael Francisco Pinto
 * Rafael Koury Monteiro
 * Rafael Palermo de Ara?jo
 * Raphael Veras Rossiter
 * Roberto Sobreira Barbalho
 * Rodrigo Avellar Silveira
 * Rosana Carvalho Barbosa
 * S?vio Luiz de Andrade Cavalcante
 * Tai Mu Shih
 * Thiago Augusto Souza do Nascimento
 * Tiago Moreno Rodrigues
 * Vivianne Barbosa Sousa
 *
 * Este programa ? software livre; voc? pode redistribu?-lo e/ou
 * modific?-lo sob os termos de Licen?a P?blica Geral GNU, conforme
 * publicada pela Free Software Foundation; vers?o 2 da
 * Licen?a.
 * Este programa ? distribu?do na expectativa de ser ?til, mas SEM
 * QUALQUER GARANTIA; sem mesmo a garantia impl?cita de
 * COMERCIALIZA??O ou de ADEQUA??O A QUALQUER PROP?SITO EM
 * PARTICULAR. Consulte a Licen?a P?blica Geral GNU para obter mais
 * detalhes.
 * Voc? deve ter recebido uma c?pia da Licen?a P?blica Geral GNU
 * junto com este programa; se n?o, escreva para Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307, USA.
 */
package gcom.cobranca;

import gcom.arrecadacao.ArrecadadorContratoTarifa;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.AvisoDeducoes;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.PagamentoSituacao;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.ordemservico.ServicoTipo;
import gcom.atendimentopublico.registroatendimento.AtendimentoMotivoEncerramento;
import gcom.atendimentopublico.registroatendimento.AtendimentoRelacaoTipo;
import gcom.atendimentopublico.registroatendimento.EspecificacaoTipoValidacao;
import gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteRelacaoTipo;
import gcom.cadastro.cliente.ClienteTipo;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.empresa.EmpresaCobrancaFaixa;
import gcom.cadastro.geografico.Microrregiao;
import gcom.cadastro.geografico.Municipio;
import gcom.cadastro.geografico.Regiao;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.CategoriaTipo;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.bean.ConsultarTransferenciasDebitoHelper;
import gcom.cobranca.bean.DadosConsultaNegativacaoHelper;
import gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaBoletimCadastroHelper;
import gcom.cobranca.bean.EmitirDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarComandosAcaoCobrancaEventualHelper;
import gcom.cobranca.bean.FiltrarDocumentoCobrancaHelper;
import gcom.cobranca.bean.FiltrarRelacaoParcelamentoHelper;
import gcom.cobranca.bean.FiltroSupressoesReligacoesReestabelecimentoHelper;
import gcom.cobranca.bean.PesquisarQtdeRotasSemCriteriosParaAcoesCobranca;
import gcom.cobranca.bean.SituacaoEspecialCobrancaHelper;
import gcom.cobranca.contratoparcelamento.ContratoParcelamento;
import gcom.cobranca.parcelamento.ParcDesctoInativVista;
import gcom.cobranca.parcelamento.ParcelaEntradaDesconto;
import gcom.cobranca.parcelamento.Parcelamento;
import gcom.cobranca.parcelamento.ParcelamentoDescontoInatividade;
import gcom.cobranca.parcelamento.ParcelamentoFaixaValor;
import gcom.cobranca.parcelamento.ParcelamentoMotivoDesfazer;
import gcom.cobranca.parcelamento.ParcelamentoQuantidadeReparcelamento;
import gcom.cobranca.parcelamento.ParcelamentoSituacao;
import gcom.cobranca.parcelamentojudicial.EmitirGuiasParcelamentoJudicialHelper;
import gcom.cobranca.parcelamentojudicial.FiltrarManterParcelamentoJudicial;
import gcom.cobranca.parcelamentojudicial.ParcelamentoJudicial;
import gcom.cobranca.parcelamentojudicial.ParcelamentoJudicialImovel;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoTipo;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.gerencial.bean.InformarDadosGeracaoResumoAcaoConsultaEventualHelper;
import gcom.gui.cobranca.cobrancaporresultado.MovimentarOrdemServicoGerarOSHelper;
import gcom.gui.relatorio.atendimentopublico.FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper;
import gcom.gui.relatorio.cobranca.FaixaHelper;
import gcom.gui.relatorio.cobranca.FiltroRelatorioDocumentosAReceberHelper;
import gcom.micromedicao.consumo.ConsumoHistorico;
import gcom.micromedicao.consumo.LigacaoTipo;
import gcom.micromedicao.medicao.MedicaoTipo;
import gcom.relatorio.cobranca.FiltrarRelatorioParcelasEmAtrasoParcelamentoJudicialHelper;
import gcom.relatorio.cobranca.ProtocoloDocumentoCobrancaRelatorioHelper;
import gcom.relatorio.cobranca.RelatorioAcompanhamentoAcoesCobrancaHelper;
import gcom.relatorio.cobranca.RelatorioAnalisePerdasCreditosBean;
import gcom.relatorio.cobranca.RelatorioBoletimMedicaoCobrancaHelper;
import gcom.relatorio.cobranca.parcelamento.RelacaoParcelamentoRelatorioHelper;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.util.CollectionUtil;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ErroRepositorioException;
import gcom.util.HibernateUtil;
import gcom.util.RepositorioUtilHBM;
import gcom.util.Util;
import gcom.util.filtro.Filtro;
import gcom.util.filtro.GeradorHQLCondicional;

import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.StatelessSession;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;

/**
 * Repositorio para cobran?a
 * 
 * @author Rafael Santos
 * @since 02/01/2006
 */
public class RepositorioCobrancaHBM implements IRepositorioCobranca {

	/** Repositorio Cobranca Hibernate */
	private static RepositorioCobrancaHBM instancia;

	/**
	 * Construtor da classe RepositorioAcessoHBM
	 */
	protected RepositorioCobrancaHBM() {
	}

	/**
	 * Retorna o valor de instancia
	 * 
	 * @return O valor de instancia
	 */
	public static RepositorioCobrancaHBM getInstancia() {

		String dialect = HibernateUtil.getDialect();

		if (dialect.toUpperCase().contains("ORACLE")) {
			if (instancia == null) {
				instancia = new RepositorioCobrancaHBM();
			}
		} else {
			if (instancia == null) {
				instancia = new RepositorioCobrancaPostgresHBM();
			}
		}

		return instancia;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa os imóveis das contas
	 * 
	 * @author: Raphael Rossiter
	 * @date: 21/03/2013
	 */
	public void inserirComandoEmpresaCobrancaContaImovelParcial(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper,
			boolean percentualInformado) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String primeiraGeracao = null;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper
					.getComandoEmpresaCobrancaConta();

			primeiraGeracao = "INSERT INTO cobranca.cmd_empr_cobr_cnta_imov_p (imov_id, cecc_id, loca_id, stcm_id, qdra_id, cbst_id) "
					+ "SELECT DISTINCT imov.imov_id as idImovel, ? as comando, imov.loca_id as localidade, imov.stcm_id as setor_comercial, "
					+ "imov.qdra_id as quadra, imov.cbst_id as cobranca_situacao_tipo "
					+ "FROM cadastro.imovel imov "
					+ "WHERE imov.imov_icexclusao <> 1 "
					+ "AND imov.imov_idcategoriaprincipal IN(*) ";

			// CATEGORIA
			int qtdCategorias = 4;
			Integer[] idsCategorias = null;

			if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null && !comandoEmpresaCobrancaConta
					.getIndicadorResidencial().equals(
							ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorComercial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorComercial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null && !comandoEmpresaCobrancaConta
							.getIndicadorIndustrial().equals(
									ConstantesSistema.NAO.intValue()))
					|| (comandoEmpresaCobrancaConta.getIndicadorPublico() != null && !comandoEmpresaCobrancaConta
							.getIndicadorPublico().equals(
									ConstantesSistema.NAO.intValue()))) {

				qtdCategorias = 0;
				int countQtdCategorias = 1;
				int indexIdsCategorias = -1;

				while (countQtdCategorias <= 2) {

					if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null
							&& !comandoEmpresaCobrancaConta
									.getIndicadorResidencial().equals(
											ConstantesSistema.NAO.intValue())) {

						if (countQtdCategorias == 1) {
							qtdCategorias++;
						} else {

							indexIdsCategorias++;
							idsCategorias[indexIdsCategorias] = Categoria.RESIDENCIAL;

						}
					}

					if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null
							&& !comandoEmpresaCobrancaConta
									.getIndicadorComercial().equals(
											ConstantesSistema.NAO.intValue())) {

						if (countQtdCategorias == 1) {
							qtdCategorias++;
						} else {

							indexIdsCategorias++;
							idsCategorias[indexIdsCategorias] = Categoria.COMERCIAL;

						}
					}

					if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null
							&& !comandoEmpresaCobrancaConta
									.getIndicadorIndustrial().equals(
											ConstantesSistema.NAO.intValue())) {

						if (countQtdCategorias == 1) {
							qtdCategorias++;
						} else {

							indexIdsCategorias++;
							idsCategorias[indexIdsCategorias] = Categoria.INDUSTRIAL;

						}
					}

					if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null
							&& !comandoEmpresaCobrancaConta
									.getIndicadorPublico().equals(
											ConstantesSistema.NAO.intValue())) {

						if (countQtdCategorias == 1) {
							qtdCategorias++;
						} else {

							indexIdsCategorias++;
							idsCategorias[indexIdsCategorias] = Categoria.PUBLICO;

						}
					}

					// INICIALIZANDO O ARRAY COM A QUANTIDADE DE CATEGORIAS
					// SELECIONADAS
					if (countQtdCategorias == 1) {
						idsCategorias = new Integer[qtdCategorias];
					}

					countQtdCategorias++;
				}
			} else {

				idsCategorias = new Integer[qtdCategorias];
				idsCategorias[0] = Categoria.RESIDENCIAL;
				idsCategorias[1] = Categoria.COMERCIAL;
				idsCategorias[2] = Categoria.INDUSTRIAL;
				idsCategorias[3] = Categoria.PUBLICO;
			}

			// CARREGANDO OS PARÊMETROS DAS CATEGORIAS
			String idsCategoriasBindVariable = "";
			for (int j = 0; j < idsCategorias.length; j++) {

				idsCategoriasBindVariable = idsCategoriasBindVariable + "?, ";
			}

			idsCategoriasBindVariable = Util.removerUltimosCaracteres(
					idsCategoriasBindVariable, 2);

			// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
			primeiraGeracao = primeiraGeracao.replace("*",
					idsCategoriasBindVariable);

			// IMOVEL
			if (comandoEmpresaCobrancaConta.getImovel() != null) {

				primeiraGeracao = primeiraGeracao + "AND imov.imov_id = ? ";
			}

			// PERFIL
			Integer[] idsImovelPerfil = null;

			if (comandoEmpresaCobrancaConta.getImovelPerfil() != null) {

				primeiraGeracao = primeiraGeracao + "AND imov.iper_id IN(?) ";

				idsImovelPerfil = new Integer[1];
				idsImovelPerfil[0] = comandoEmpresaCobrancaConta
						.getImovelPerfil().getId();
			} else if (comandoEmpresaCobrancaContaHelper
					.getColecaoImovelPerfil() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoImovelPerfil().isEmpty()) {

				boolean consultaColecaoImovelPerfil = true;
				if (comandoEmpresaCobrancaContaHelper.getColecaoImovelPerfil()
						.size() == 1) {
					Iterator it = comandoEmpresaCobrancaContaHelper
							.getColecaoImovelPerfil().iterator();
					while (it.hasNext()) {
						ImovelPerfil obj = (ImovelPerfil) it.next();
						if (obj != null && obj.getId() == -1) {
							consultaColecaoImovelPerfil = false;
						}
					}
				}

				if (consultaColecaoImovelPerfil) {

					primeiraGeracao = primeiraGeracao
							+ "AND imov.iper_id IN(*) ";

					idsImovelPerfil = new Integer[comandoEmpresaCobrancaContaHelper
							.getColecaoImovelPerfil().size()];

					Iterator iterator = comandoEmpresaCobrancaContaHelper
							.getColecaoImovelPerfil().iterator();
					ImovelPerfil imovelPerfil = null;
					int indexIdsImovelPerfil = 0;

					while (iterator.hasNext()) {
						imovelPerfil = (ImovelPerfil) iterator.next();

						idsImovelPerfil[indexIdsImovelPerfil] = imovelPerfil
								.getId();

						indexIdsImovelPerfil++;
					}
				}
			}

			// CARREGANDO OS PARÊMETROS DOS PERFIS
			if (idsImovelPerfil != null && idsImovelPerfil.length > 0) {

				String idsImovelPerfilBindVariable = "";
				for (int j = 0; j < idsImovelPerfil.length; j++) {

					idsImovelPerfilBindVariable = idsImovelPerfilBindVariable
							+ "?, ";
				}

				idsImovelPerfilBindVariable = Util.removerUltimosCaracteres(
						idsImovelPerfilBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				primeiraGeracao = primeiraGeracao.replace("*",
						idsImovelPerfilBindVariable);
			}

			// SITUAÇÃO DA LIGAÇÃO DE ÁGUA
			Integer[] idsLigacaoAguaSituacao = null;

			if (comandoEmpresaCobrancaConta.getLigacaoAguaSituacao() != null) {

				primeiraGeracao = primeiraGeracao + "AND imov.last_id IN(*) ";

				idsLigacaoAguaSituacao = new Integer[1];
				idsLigacaoAguaSituacao[0] = comandoEmpresaCobrancaConta
						.getLigacaoAguaSituacao().getId();
			} else if (comandoEmpresaCobrancaContaHelper
					.getColecaoLigacaoAguaSituacao() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoLigacaoAguaSituacao().isEmpty()) {

				boolean consultaColecaoLigacaoAguaSituacao = true;
				if (comandoEmpresaCobrancaContaHelper
						.getColecaoLigacaoAguaSituacao().size() == 1) {
					Iterator it = comandoEmpresaCobrancaContaHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					while (it.hasNext()) {
						LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it
								.next();
						if (obj != null && obj.getId() == -1) {
							consultaColecaoLigacaoAguaSituacao = false;
						}
					}
				}

				if (consultaColecaoLigacaoAguaSituacao) {

					primeiraGeracao = primeiraGeracao
							+ "AND imov.last_id IN(*) ";

					idsLigacaoAguaSituacao = new Integer[comandoEmpresaCobrancaContaHelper
							.getColecaoLigacaoAguaSituacao().size()];

					Iterator iterator = comandoEmpresaCobrancaContaHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					LigacaoAguaSituacao ligacaoAguaSituacao = null;
					int indexIdsLigacaoAguaSituacao = 0;

					while (iterator.hasNext()) {
						ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator
								.next();

						idsLigacaoAguaSituacao[indexIdsLigacaoAguaSituacao] = ligacaoAguaSituacao
								.getId();

						indexIdsLigacaoAguaSituacao++;

					}
				}
			}

			// CARREGANDO OS PARÊMETROS DAS SITUAÇÕES DA LIGAÇÃO DE ÁGUA
			if (idsLigacaoAguaSituacao != null
					&& idsLigacaoAguaSituacao.length > 0) {

				String idsLigacaoAguaSituacaoBindVariable = "";
				for (int j = 0; j < idsLigacaoAguaSituacao.length; j++) {

					idsLigacaoAguaSituacaoBindVariable = idsLigacaoAguaSituacaoBindVariable
							+ "?, ";
				}

				idsLigacaoAguaSituacaoBindVariable = Util
						.removerUltimosCaracteres(
								idsLigacaoAguaSituacaoBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				primeiraGeracao = primeiraGeracao.replace("*",
						idsLigacaoAguaSituacaoBindVariable);
			}

			// 2.4.1. Seleciona os imóveis que não possuam documento de cobrança
			// para as ações de cobrança selecionadas
			Integer[] idsServicoTipo = null;

			if (comandoEmpresaCobrancaContaHelper
					.getColecaoAcoesCobrancaNaoGeracao() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoAcoesCobrancaNaoGeracao().isEmpty()) {

				primeiraGeracao = primeiraGeracao
						+ " AND NOT EXISTS (select orse.imov_id "
						+ " FROM atendimentopublico.ordem_servico orse "
						+ " WHERE orse.amen_id is null "
						+ " AND orse.cbdo_id IS NOT NULL "
						+ " AND orse.rgat_id IS NULL "
						+ " AND imov.imov_id = orse.imov_id "
						+ " AND orse.svtp_id IN(*) ) ";

				idsServicoTipo = new Integer[comandoEmpresaCobrancaContaHelper
						.getColecaoAcoesCobrancaNaoGeracao().size()];

				Iterator iterator = comandoEmpresaCobrancaContaHelper
						.getColecaoAcoesCobrancaNaoGeracao().iterator();
				CobrancaAcao cobrancaAcao = null;
				int indexIdsServicoTipo = 0;
				String idsServicoTipoBindVariable = "";

				while (iterator.hasNext()) {
					cobrancaAcao = (CobrancaAcao) iterator.next();

					idsServicoTipo[indexIdsServicoTipo] = cobrancaAcao
							.getServicoTipo().getId();
					idsServicoTipoBindVariable = idsServicoTipoBindVariable
							+ "?, ";

					indexIdsServicoTipo++;
				}

				idsServicoTipoBindVariable = Util.removerUltimosCaracteres(
						idsServicoTipoBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				primeiraGeracao = primeiraGeracao.replace("*",
						idsServicoTipoBindVariable);
			}

			// 2.5.1. Seleciona os imóveis que possuam situações de cobrança
			// selecionadas
			Integer[] idsCobrancaSituacao = null;

			if (comandoEmpresaCobrancaContaHelper.getColecaoCobrancaSituacao() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoCobrancaSituacao().isEmpty()) {

				primeiraGeracao = primeiraGeracao
						+ " and exists (select iscb.imov_id "
						+ " from cadastro.imovel_cobranca_situacao iscb "
						+ " where imov.imov_id = iscb.imov_id "
						+ " and iscb.iscb_dtretiradacobranca is null "
						+ " and iscb.cbst_id in (*) ) ";

				idsCobrancaSituacao = new Integer[comandoEmpresaCobrancaContaHelper
						.getColecaoCobrancaSituacao().size()];

				Iterator iterator = comandoEmpresaCobrancaContaHelper
						.getColecaoCobrancaSituacao().iterator();
				CobrancaSituacao cobrancaSituacao = null;
				int indexIdsCobrancaSituacao = 0;
				String idsCobrancaSituacaoBindVariable = "";

				while (iterator.hasNext()) {
					cobrancaSituacao = (CobrancaSituacao) iterator.next();

					idsCobrancaSituacao[indexIdsCobrancaSituacao] = cobrancaSituacao
							.getId();
					idsCobrancaSituacaoBindVariable = idsCobrancaSituacaoBindVariable
							+ "?, ";

					indexIdsCobrancaSituacao++;
				}

				idsCobrancaSituacaoBindVariable = Util
						.removerUltimosCaracteres(
								idsCobrancaSituacaoBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				primeiraGeracao = primeiraGeracao.replace("*",
						idsCobrancaSituacaoBindVariable);
			}

			// SITUAÇÃO ESPECIAL DE COBRANÇA
			if (!percentualInformado) {

				primeiraGeracao = primeiraGeracao
						+ " AND NOT EXISTS (SELECT cbsh.imov_id FROM cobranca.cobranca_situacao_hist cbsh "
						+ " WHERE cbsh.imov_id = imov.imov_id and cbsh.cbsh_amcobrancaretirada IS NULL) ";
			}

			/*
			 * //SITUAÇÃO DE COBRANÇA if (!percentualInformado) {
			 * 
			 * primeiraGeracao = primeiraGeracao +
			 * " AND NOT EXISTS (SELECT cbsh.imov_id FROM CADASTRO.imovel_cobranca_situacao iscb "
			 * +
			 * " inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
			 * +
			 * " WHERE iscb.imov_id = imov.imov_id and iscb.ISCB_DTRETIRADACOBRANCA IS NULL "
			 * + " and cbst.cbst_icnaocobranca = 1 " +
			 * " and iscb.CBST_ID <> 20) "; }
			 */

			st = con.prepareStatement(primeiraGeracao);
			int i = 1;

			// COMANDO
			st.setInt(i, comandoEmpresaCobrancaConta.getId());

			// CATEGORIA
			for (int j = 0; j < idsCategorias.length; j++) {
				i++;
				st.setInt(i, idsCategorias[j]);
			}

			// IMOVEL
			if (comandoEmpresaCobrancaConta.getImovel() != null) {

				i++;
				st.setInt(i, comandoEmpresaCobrancaConta.getImovel().getId());
			}

			// PERFIL
			if (idsImovelPerfil != null && idsImovelPerfil.length > 0) {

				for (int j = 0; j < idsImovelPerfil.length; j++) {
					i++;
					st.setInt(i, idsImovelPerfil[j]);
				}
			}

			// SITUAÇÃO DA LIGAÇÃO DE ÁGUA
			if (idsLigacaoAguaSituacao != null
					&& idsLigacaoAguaSituacao.length > 0) {

				for (int j = 0; j < idsLigacaoAguaSituacao.length; j++) {
					i++;
					st.setInt(i, idsLigacaoAguaSituacao[j]);
				}
			}

			// TIPO DE SERVIÇO
			if (idsServicoTipo != null && idsServicoTipo.length > 0) {

				for (int j = 0; j < idsServicoTipo.length; j++) {
					i++;
					st.setInt(i, idsServicoTipo[j]);
				}
			}

			// SITUAÇÕES DE COBRANÇA
			if (idsCobrancaSituacao != null && idsCobrancaSituacao.length > 0) {

				for (int j = 0; j < idsCobrancaSituacao.length; j++) {
					i++;
					st.setInt(i, idsCobrancaSituacao[j]);
				}
			}

			st.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Im?vel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Pesquisa os imoveis cortados h? 60 dias ou
	 * mais a data do ?ltimo dia do m?s de faturamento
	 * 
	 * @return Colec??o de Matriculas
	 * @exception ErroRepositorioException
	 *                Descri??o da exce??o
	 */
	public Collection pesquisarImoveisCortados(String situacaoEsgotoLigado,
			String situacaoAguaCortado, Date anoMesReferenciaFaturamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select i.id "
					+ "from Imovel i "
					+ "inner join i.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ "inner join i.ligacaoAgua ligacaoAgua "
					+ "inner join i.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ "inner join i.ligacaoEsgoto ligacaoEsgoto "
					+ "where ligacaoAguaSituacao.id = :situacao and "
					+ "ligacaoAgua.dataCorte <= :anoMesReferencia and "
					+ "((ligacaoEsgotoSituacao.id != :situacaoEsgoto)  or "
					+ "(ligacaoEsgotoSituacao.id = :situacaoEsgoto and "
					+ "(ligacaoEsgoto.consumoMinimo = 0 or "
					+ "ligacaoEsgoto.consumoMinimo is null)))";

			retorno = session
					.createQuery(consulta)
					.setInteger("situacao",
							new Integer(situacaoAguaCortado).intValue())
					.setDate("anoMesReferencia", anoMesReferenciaFaturamento)
					.setInteger("situacaoEsgoto",
							new Integer(situacaoEsgotoLigado).intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0178] Religar Automaticamente Im?vel Cortado Author:
	 * Rafael Santos Data: 02/01/2006 Caso o imovel possua hidrometro na liga??o
	 * de ?gua e o tipo do ultimo consumo faturado tenha sido real
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @param consumoTipoReal
	 *            Tipo de Consumo Real
	 * @param ligacaoTipoLigacaoAgua
	 *            Tipo de Liga??o Agua
	 * @return Consumo Historico do Imovel
	 * @throws ErroRepositorioException
	 *             Erro no Repositorio
	 */
	public String pesquisarImoveisHidrometroAguaConsumoFaturadoReal(String id,
			String anoMesFaturamento, String consumoTipoReal,
			String ligacaoTipoLigacaoAgua) throws ErroRepositorioException {

		String idConsumoHistorico = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ch.id from ConsumoHistorico ch "
					+ "inner join ch.imovel im "
					+ "inner join ch.imovel.ligacaoAgua la "
					+ "inner join la.hidrometroInstalacaoHistorico "
					+ "inner join ch.consumoTipo ct "
					+ "inner join ch.ligacaoTipo lt "
					+ "where la.hidrometroInstalacaoHistorico is not null "
					+ "and ct.id = :idConsumo and lt.id = :ligacaoAgua "
					+ " and ch.referenciaFaturamento = :anoMesReferencia "
					+ " and im.id = :idImovel";

			retorno = session
					.createQuery(consulta)
					.setInteger("idConsumo",
							new Integer(consumoTipoReal).intValue())
					.setInteger("ligacaoAgua",
							new Integer(ligacaoTipoLigacaoAgua).intValue())
					.setInteger("anoMesReferencia",
							new Integer(anoMesFaturamento).intValue())
					.setInteger("idImovel", new Integer(id).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {

				idConsumoHistorico = ((Integer) retorno).toString();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idConsumoHistorico;
	}

	/**
	 * [UC0178] Religar Automaticamente Im?vel Cortado Auhtor: Rafael Santos
	 * Data: 03/01/2006
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param situacaoAguaLigado
	 *            Situa??o Agua
	 * @param dataReligacaoAgua
	 *            Data Religacao Agua
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void religarImovelCortado(String id, String situacaoAguaLigado,
			Date dataReligacaoAgua) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;
		String atualizarLigacaoAgua;

		try {
			System.out.println("Entrou.....");
			atualizarImovel = "update gcom.cadastro.imovel.Imovel "
					+ "set last_id = :situacaoAgua where imov_id = :id";

			session.createQuery(atualizarImovel)
					.setInteger("situacaoAgua",
							new Integer(situacaoAguaLigado).intValue())
					.setInteger("id", new Integer(id).intValue())
					.executeUpdate();

			atualizarLigacaoAgua = "update gcom.atendimentopublico.ligacaoagua.LigacaoAgua "
					+ "set lagu_dtreligacaoagua = :data"
					+ " where hidi_id = :id";

			session.createQuery(atualizarLigacaoAgua)
					.setDate("data", dataReligacaoAgua)
					.setInteger("id", new Integer(id).intValue())
					.executeUpdate();
		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente Obtem os d?bitos de um im?vel
	 * Author: Rafael Santos Data: 03/01/2006
	 * 
	 * @param id
	 *            Matricula do Imovel
	 * @param contaSituacaoNormal
	 *            Situa??o Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situa??o Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situa??o Inclu?da de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Cole??o de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovel(Integer idImovel,
			int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id = :idImovel "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) ";

			if (anoMesInicialReferenciaDebito != null
					&& anoMesFinalReferenciaDebito != null) {

				consulta += "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia ";

			}

			consulta += "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (anoMesInicialReferenciaDebito != null
					&& anoMesFinalReferenciaDebito != null) {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.setInteger("idImovel", idImovel)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.setInteger("idImovel", idImovel)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("dataRevisao", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("idSituacaoAtual", Hibernate.INTEGER)
					.addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("idMotivoRevisao", Hibernate.INTEGER)
					.addScalar("ultimaAlteracao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("consumoAgua", Hibernate.INTEGER)
					.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
					.addScalar("consumoEsgoto", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal",
							new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada",
							new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida",
							new Integer(contaSituacaoIncluida))
					.setInteger("situacaoParcelada",
							new Integer(contaSituacaoParcelada))
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Im?vel ou Cliente Obtem os d?bitos
	 * de um cliente Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idsContas
	 *            Cole??o de Ids das Contas
	 * @param contaSituacaoNormal
	 *            Situa??o Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situa??o Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situa??o Inclu?da de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Cole??o de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasCliente(Integer idCliente,
			Short relacaoTipo, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento,conta.parc_id as idParcelamento "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE clieConta.clie_id = :idCliente "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";// min(pagto.pgmt_dtpagamento)
																																																									// ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("dataRevisao", Hibernate.DATE)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("idSituacaoAtual", Hibernate.INTEGER)
					.addScalar("digitoVerificador", Hibernate.SHORT)
					.addScalar("idMotivoRevisao", Hibernate.INTEGER)
					.addScalar("ultimaAlteracao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("consumoAgua", Hibernate.INTEGER)
					.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
					.addScalar("consumoEsgoto", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.setInteger("idCliente", idCliente)
					.setInteger("situacaoNormal",
							new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada",
							new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida",
							new Integer(contaSituacaoIncluida))
					.setInteger("situacaoParcelada",
							new Integer(contaSituacaoParcelada))
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Im?vel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Conta Author: Rafael Santos Data: 05/01/2006
	 * 
	 * @param idConta
	 *            Id Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalPagamentoMenorDataPagamento(
			String idConta) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT SUM(p.valorPagamento),MIN(p.dataPagamento) "
					+ "FROM Pagamento p " + "WHERE p.contaGeral.id = :id "
					+ "GROUP BY p.contaGeral.id";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idConta).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Im?vel ou Cliente Obtem o Valor
	 * Total dos Pagamentos da Guia de Pagamento Author: Rafael Santos,Rafael
	 * Santos Data: 07/01/2006,21/03/2006
	 * 
	 * @param idGuiaPagamento
	 *            Id Guia Pagamento
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarValorTotalGuiaPagamentoMenorDataGuiaPagamento(
			String idGuiaPagamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select sum(p.valorPagamento), min(p.dataPagamento) "
					+ "from Pagamento p "
					+ "inner join p.guiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :id "
					+ "group by guiaPagamento.id";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idGuiaPagamento)).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @param situacaoNormal
	 *            situacao de debito credito
	 * @return Cole??o de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovel(String idImovel,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac,debitoTipo.descricao,debitoTipo.id  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "where imovel.id = :id "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			retorno = session.createQuery(consulta)
					.setInteger("id", new Integer(idImovel))
					.setInteger("normal", new Integer(situacaoNormal)).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Pesquisa os ID dos imoveis dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteImovel(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 07/01/2006 Pesquisa os ID dos clientes contas
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return ID dos Imvoeis Cliente Conta
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDImoveisClienteConta(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteConta cc "
					+ "inner join cc.conta conta "
					+ "inner join cc.cliente cliente "
					+ "inner join conta.imovel imovel ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join cc.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 06/01/2006 Colec??o de Debitos a Cobrar de Cliente
	 * 
	 * @param colecaoIdImoveis
	 *            Cole??o de ID dos Imoveis
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarCliente(Collection idsImoveis,
			String situacaoNormal) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select dac,debitoTipo.descricao,debitoTipo.id "
					+ "from DebitoACobrar dac "
					+ "inner join dac.imovel imovel "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where imovel.id IN(:ids) "
					+ "and dac.numeroPrestacaoCobradas < "
					+ "(dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id)";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createQuery(consulta)
							.setInteger("normal",
									new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createQuery(consulta)
						.setInteger("normal",
								new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006 Colec??o de Creditos a Realizar de Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @return Cole??o de Creditos A Realizar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarCliente(Collection idsImoveis,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car, creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.imovel imovel "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "where imovel.id IN(:ids) "
					+ "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or "
					+ "car.valorResidualMesAnterior > 0) "
					+ " and car.debitoCreditoSituacaoAtual = :normal ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createQuery(consulta)
							.setInteger("normal",
									new Integer(situacaoNormal).intValue())
							.setParameterList("ids", particoes.get(i)).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createQuery(consulta)
						.setInteger("normal",
								new Integer(situacaoNormal).intValue())
						.setParameterList("ids", idsImoveis).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 05/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @return Cole??o de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarImovel(String idImovel,
			String situacaoNormal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.imovel imovel "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "where imovel.id = :id "
					+ "and (car.numeroPrestacaoRealizada < car.numeroPrestacaoCredito or "
					+ "car.valorResidualMesAnterior > 0) "
					+ " and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("id", new Integer(idImovel).intValue())
					.setInteger("normal",
							new Integer(situacaoNormal).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente
	 * 
	 * Author: Rafael Santos,Rafael Santos, Ivan S?rgio Data: 07/01/2006,
	 * 21/03/2006, 07/01/2009 Alteracao: 07/01/2009 - CRC932: No HQL do primeiro
	 * IF os dois ultimos campos estvam com o alias escrito errado. No ultimo
	 * campo faltava um espaco.
	 * 
	 * Colec??o de Guias de Pagamento do Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @param clienteRelacaoTipo
	 *            Rela??o Cliente Tipo
	 * @return Cole??o de Guias de Pagamento do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoCliente(Integer idCliente,
			int indicadorPagamento, String situacaoNormal,
			Short clienteRelacaoTipo, Date dataVencimentoInicial,
			Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += " and clieGuia.crtp_id = "
						+ clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING)
					.addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idCliente", idCliente)
					.setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial)
					.setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acr?scimo por Impontualidade Santos Data:
	 * 09/01/2006 Dados do Indices Acrescimo Impontualidade
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano M?s de Referencia de D?bito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia =  :anoMesReferencia";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Pesquisa o acr?scimo da maneira correta
	 * 
	 * Data: 07/09/2009 Author: Rafael Corr?a
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano M?s de Referencia de D?bito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIgualIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia <= :anoMesReferencia)";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Faz parte de [UC0216] Calcular Acr?scimo por Impontualidade Santos Data:
	 * 09/01/2006 Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 * ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 *            Ano M?s de Referencia de D?bito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade(
			int anoMesReferenciaDebito) throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select max(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2 where iai2.anoMesReferencia < :anoMesReferencia)";

			retorno = session
					.createQuery(consulta)
					.setInteger("anoMesReferencia",
							new Integer(anoMesReferenciaDebito).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 07/01/2006
	 * 
	 * @param idImovel
	 *            Matricula do Imovel
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Cole??o de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoImovel(Integer idImovel,
			int indicadorPagamento, String situacaoNormal,
			Date dataVencimentoInicial, Date dataVencimentoFinal)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.imov_id = :idImovel "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal  ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGuia", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferencia", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
					.addScalar("descricaoDebitoTipo", Hibernate.STRING)
					.addScalar("dataEmissao", Hibernate.DATE)
					.addScalar("idDebitoTipo", Hibernate.INTEGER)
					.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
					.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", new Integer(situacaoNormal))
					.setDate("inicialVencimento", dataVencimentoInicial)
					.setDate("finalVencimento", dataVencimentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico [FS0004] Verificar Data de Op??o
	 * posterior j? informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcao(String matriculaImovel, Date dataOpcao,
			String identificadorCliente, String codigoAgencia)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id "
					+ "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula AND "
					// Alterado Bruno Barros
					// + "((agencia.codigoAgencia = :codigoAgencia AND "
					// +
					// "deb.identificacaoClienteBanco = :identificadorCliente) OR "
					+ "(deb.dataExclusao is null "
					+ "and deb.dataOpcaoDebitoContaCorrente >= :data)";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0201] Excluir D?bito Autom?tico [FS0004] Verificar Data de Op??o
	 * posterior j? informada
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDataOpcaoExclusao(String matriculaImovel,
			Date dataOpcao, String identificadorCliente)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id " + "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula AND "
					+ "deb.dataExclusao is null "
					+ "and deb.dataOpcaoDebitoContaCorrente > :data";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico Verificar se o Im?vel j? ? D?bito
	 * Autom?tico
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomatico(String matriculaImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se j? tem d?bito autom?tico
			verificaDebitoAutomatico = "select agencia.id "
					+ "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "inner join deb.agencia agencia "
					+ "where imovel.id = :matricula "
					+ "and deb.dataExclusao is null ";

			retorno = session
					.createQuery(verificaDebitoAutomatico)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico Atualiza a data da exclus?o com a data
	 * corrente em D?bio Autom?tico
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarDataExclusao(String matriculaImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em d?bito autom?tico a Data Exclus?o com a data corrente
			atualizaDataExclusao = "update gcom.arrecadacao.debitoautomatico.DebitoAutomatico "
					+ "set deba_dtexclusao = :data,deba_tmultimaalteracao = :ultimaAlteracao where imov_id = :matricula";

			session.createQuery(atualizaDataExclusao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico
	 * 
	 * @author Roberta Costa
	 * @created 04/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @param codigoBanco
	 *            C?digo do Banco
	 * @param codigoAgencia
	 *            C?digo da Ag?ncia
	 * @param identificacaoCliente
	 *            Identifica??o do Cliente no Banco
	 * @param dataOpcao
	 *            Data da Op??o
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void inserirDebitoAutomatico(DebitoAutomatico debitoAutomatico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			// Inclui o d?bito autom?rico

			session.save(debitoAutomatico);
			session.flush();
			session.clear();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico Atualiza o indicador de d?bio
	 * autom?tico em Im?vel
	 * 
	 * @author Roberta Costa
	 * @created 05/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarIndicadorDebitoAutomatico(String matriculaImovel,
			Integer indicadorDebito) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaIndicadorDebitoAutomatico;

		try {
			// Atualiza em d?bito autom?tico a Data Exclus?o com a data corrente
			atualizaIndicadorDebitoAutomatico = "update gcom.cadastro.imovel.Imovel "
					+ "set imov_icdebitoconta = :indicador,imov_tmultimaalteracao = :ultimaAlteracao where imov_id = :matricula";

			session.createQuery(atualizaIndicadorDebitoAutomatico)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setInteger("indicador", indicadorDebito)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0201] Remover D?bito Autom?tico Verificar se o Im?vel j? ? D?bito
	 * Autom?tico para o mesmo Banco e Agencia
	 * 
	 * @author Roberta Costa
	 * @created 09/01/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public String verificarDebitoAutomaticoBancoAgencia(String codigoBanco,
			String codigoAgencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String verificaDebitoAutomatico;

		try {
			// Verifica se j? tem d?bito autom?tico
			verificaDebitoAutomatico = "select agencia.id "
					+ "from Agencia agencia "
					+ "inner join agencia.banco banco "
					+ "where banco.id = :codigoBanco "
					+ "and agencia.codigoAgencia = :agencia ";

			retorno = session
					.createQuery(verificaDebitoAutomatico)
					.setInteger("codigoBanco",
							new Integer(codigoBanco).intValue())
					.setString("agencia", codigoAgencia).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0246] Executar Atividade de A??o de Cobran?a Pesquisa uma cole??o de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeCronograma>
	 * pesquisarCobrancaAcaoAtividadeCronograma() throws
	 * ErroRepositorioException{
	 * 
	 * //cria a vari?vel que vai armazenar a cole??o pesquisada
	 * Collection<CobrancaAcaoAtividadeCronograma> retorno = null;
	 * 
	 * //cria uma sess?o com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a vari?vel que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select caac " + "from
	 * CobrancaAcaoAtividadeCronograma caac " + "where (caac.comando is not
	 * null) and " + "((caac.realizacao is null) or (caac.realizacao <
	 * caac.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exce??o
	 * para a pr?xima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sess?o
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a cole??o do resultado da pesquisa return retorno; }
	 */

	/**
	 * [UC0246] Executar Atividade de A??o de Cobran?a Pesquisa uma cole??o de
	 * CobrancaAcaoAtividadeComand
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	/*
	 * public Collection<CobrancaAcaoAtividadeComand>
	 * pesquisarCobrancaAcaoAtividadeComand() throws ErroRepositorioException{
	 * 
	 * //cria a vari?vel que vai armazenar a cole??o pesquisada
	 * Collection<CobrancaAcaoAtividadeComand> retorno = null;
	 * 
	 * //cria uma sess?o com o hibernate Session session =
	 * HibernateUtil.getSession();
	 * 
	 * //cria a vari?vel que vai conter o hql String consulta;
	 * 
	 * try { //constroi o hql consulta = "select cacm " + "from
	 * CobrancaAcaoAtividadeComand cacm " + "where (cacm.comando is not null)
	 * and " + "((cacm.realizacao is null) or (cacm.realizacao <
	 * cacm.comando))";
	 * 
	 * //executa o hql retorno = session.createQuery(consulta).list();
	 * 
	 * //erro no hibernate } catch (HibernateException e) { // levanta a exce??o
	 * para a pr?xima camada throw new ErroRepositorioException(e, "Erro no
	 * Hibernate"); } finally { // fecha a sess?o
	 * HibernateUtil.closeSession(session); }
	 * 
	 * //retorna a cole??o do resultado da pesquisa return retorno; }
	 */

	/**
	 * Consultar Dados do Cliente Imovel Vinculado Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param inscricaoImovel
	 *            Inscri??o do Imovel
	 * @return Dados do Imovel Vinculado
	 * @throws ControladorException
	 */
	public Object[] consultarDadosClienteImovelUsuario(Imovel imovel)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select cliente.id,cliente.nome "
					+ "from ClienteImovel clienteImovel "
					+ "inner join clienteImovel.cliente cliente "
					+ "inner join clienteImovel.imovel imovel "
					+ "inner join clienteImovel.clienteRelacaoTipo clienteRelacaoTipo "
					+ "where imovel.id = :id and clienteRelacaoTipo.id = :usuario "
					+ "and clienteImovel.clienteImovelFimRelacaoMotivo is null";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("id", imovel.getId().intValue())
					.setInteger("usuario", ClienteRelacaoTipo.USUARIO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * Consultar Matriculas dos Imoveis Vinculados do Imovel condominio Auhtor:
	 * Rafael Santos Data: 23/01/2006 [UC0179] Consultar Historico Medi??o
	 * Indiviualizada
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarConsumoHistoricoImoveisVinculados(
			ConsumoHistorico consumoHistorico) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select imovel.id " + "from ConsumoHistorico consumo "
					+ "inner join consumo.imovel imovel "
					+ "where consumo.consumoImovelCondominio = :id";

			retorno = session.createQuery(consulta)
					.setInteger("id", consumoHistorico.getId().intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Consultar Consumo Tipo do Consumo Historico Auhtor: Rafael Santos Data:
	 * 23/01/2006
	 * 
	 * @param consumoHistorico
	 *            Consumo Historico
	 * @return Dados do Consumo Tipo
	 * @throws ControladorException
	 */
	public Object[] consultarDadosConsumoTipoConsumoHistorico(
			ConsumoHistorico consumoHistorico) throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select consumo.descricaoAbreviada,consumo.id "
					+ "from ConsumoTipo consumo " + "where consumo.id = :id";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger(
							"id",
							consumoHistorico.getConsumoTipo().getId()
									.intValue()).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Consultar Consumo Historico da Medicao Individualizada Auhtor: Rafael
	 * Santos Data: 23/01/2006 [UC0179] Consultar Historico Medi??o
	 * Indiviualizada
	 * 
	 * @param imovel
	 *            Imovel
	 * @param ligcaoTipo
	 *            Tipo de Ligaca??o
	 * @param anoMesFaturamento
	 *            Ano Mes Faturamento
	 * @return
	 * @throws ControladorException
	 */
	public Object[] obterConsumoHistoricoMedicaoIndividualizada(Imovel imovel,
			LigacaoTipo ligacaoTipo, int anoMesFaturamento)
			throws ErroRepositorioException {
		Object[] retornoDados = null;
		Object retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select ch.id,ch.consumoRateio, "
					+ "ch.numeroConsumoFaturadoMes,ch.consumoTipo "
					+ "from ConsumoHistorico ch where  "
					+ "ch.imovel.id = :id  "
					+ "and ch.referenciaFaturamento = :anoMes "
					+ "and ch.ligacaoTipo.id = :ligacao";

			retorno = session.createQuery(consulta)
					.setInteger("id", imovel.getId().intValue())
					.setInteger("anoMes", anoMesFaturamento)
					.setInteger("ligacao", ligacaoTipo.getId())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				retornoDados = (Object[]) retorno;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retornoDados;

	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Atualiza o debitocreditosituacao
	 * em conta
	 * 
	 * @author Fernanda Karla
	 * @created 14/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idConta
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoConta(String codigoConta, int situacaoAtual,
			int anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoConta;

		try {
			// Atualiza em conta o DebitoCreditoSituacao
			atualizaSituacaoConta = "update gcom.faturamento.conta.Conta "
					+ "set dcst_idatual = :situacaoAtual, dcst_idanterior = null, "
					+ "cnta_tmultimaalteracao = :ultimaAlteracao, cnta_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where cnta_id = :codigoConta";

			session.createQuery(atualizaSituacaoConta)
					.setInteger("codigoConta",
							new Integer(codigoConta).intValue())
					.setInteger("situacaoAtual",
							new Integer(situacaoAtual).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Atualiza o debitocreditosituacao
	 * em guia pagamento
	 * 
	 * @author Fernanda Karla
	 * @created 15/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idGuiaPagamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoGuiaPagamento(String codigoGuiaPagamento,
			int situacaoAtualGuia, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoGuiaPagamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaSituacaoGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set dcst_idatual = :situacaoAtualGuia, dcst_idanterior = null, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao, gpag_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where gpag_id = :codigoGuiaPagamento";

			session.createQuery(atualizaSituacaoGuiaPagamento)
					.setInteger("codigoGuiaPagamento",
							new Integer(codigoGuiaPagamento).intValue())
					.setInteger("situacaoAtualGuia",
							new Integer(situacaoAtualGuia).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Atualiza o parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idParcelamento
	 *            motivo parcelamentoSituacao
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarParcelamento(Integer codigoParcelamento,
			Integer parcelamentoSituacao, String motivo, Integer usuarioId)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			// Atualiza em guiapagamento o DebitoCreditoSituacao
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento "
					+ "set "
					+ "pcst_id = :parcelamentoSituacao, "
					+ "pmdz_id = :motivo, "
					+ "parc_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_iddesfaz = :usuarioId  "
					+ "where parc_id = :codigoParcelamento";

			session.createQuery(atualizaParcelamento)
					.setInteger("codigoParcelamento",
							new Integer(codigoParcelamento).intValue())
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao).intValue())
					.setInteger("motivo", new Integer(motivo).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioId", usuarioId.intValue())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	// @TODO

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Atualiza o debitocreditosituacao
	 * em debito a cobrar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            iddebitoacobrar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoDebitoACobrar(String codigoDebitoACobrar,
			int situacaoAtualDebito, int anoMesReferenciaContabil)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoDebitoACobrar;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			atualizaSituacaoDebitoACobrar = "update gcom.faturamento.debito.DebitoACobrar "
					+ "set dcst_idatual = :situacaoAtualDebito, dcst_idanterior = null, "
					+ "dbac_tmultimaalteracao = :ultimaAlteracao, dbac_amreferenciacontabil =:anoMesReferenciaContabil  "
					+ "where dbac_id = :codigoDebitoACobrar";

			session.createQuery(atualizaSituacaoDebitoACobrar)
					.setInteger("codigoDebitoACobrar",
							new Integer(codigoDebitoACobrar).intValue())
					.setInteger("situacaoAtualDebito",
							new Integer(situacaoAtualDebito).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Atualiza o debitocreditosituacao
	 * em credito a realizar
	 * 
	 * @author Fernanda Karla
	 * @created 16/02/2006
	 * 
	 * @param DebitoCreditoSituacaoAtual
	 *            idCreditoARealizar
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarSituacaoCreditoARealizar(
			String codigoCreditoARealizar, int situacaoAtualCredito,
			int anoMesReferenciaContabil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaSituacaoCreditoARealizar;

		try {
			// Atualiza em creditoarealizar o DebitoCreditoSituacao
			atualizaSituacaoCreditoARealizar = "update gcom.faturamento.credito.CreditoARealizar "
					+ "set dcst_idatual = :situacaoAtualCredito, dcst_idanterior = null, "
					+ "crar_tmultimaalteracao = :ultimaAlteracao , crar_amreferenciacontabil = :anoMesReferenciaContabil "
					+ "where crar_id = :codigoCreditoARealizar";

			session.createQuery(atualizaSituacaoCreditoARealizar)
					.setInteger("codigoCreditoARealizar",
							new Integer(codigoCreditoARealizar).intValue())
					.setInteger("situacaoAtualCredito",
							new Integer(situacaoAtualCredito).intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("anoMesReferenciaContabil",
							anoMesReferenciaContabil).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove d?bitos a cobrar referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerDebitoACobrarDoParcelamento(Integer codigoImovel,
			Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;
		String consulta;
		Collection collectionIdDebito = null;

		try {

			consulta = "select dac.id  "
					+ "from DebitoACobrar dac "
					+ "where dac.imovel.id = :codigoImovel and dac.parcelamento.id = :codigoParcelamento";

			collectionIdDebito = session
					.createQuery(consulta)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarCategoria debitoACobrarCategoria "
							+ "where debitoACobrarCategoria.debitoACobrar.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta cobran?a documento item
			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.debitoACobrarGeral.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta o debito a cobrar
			removerDebitoACobrarDoParcelamento = "delete DebitoACobrar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerDebitoACobrarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdDebito != null && !collectionIdDebito.isEmpty()) {

				Iterator icolecaoDebitos = collectionIdDebito.iterator();

				while (icolecaoDebitos.hasNext()) {

					String id = ((Integer) icolecaoDebitos.next()).toString();
					consulta = "delete DebitoACobrarGeral debitoACobrarGeral "
							+ "where debitoACobrarGeral.debitoACobrar.id = :debito ";

					session.createQuery(consulta)
							.setInteger("debito", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove d?bitos a cobrar categoria
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerDebitoACobrarCategoriaDoParcelamento(Integer idDebito)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			removerDebitoACobrarDoParcelamento = "delete gcom.faturamento.debito.DebitoACobrarCategoria "
					+ "where dbac_id = :idDebito ";

			session.createQuery(removerDebitoACobrarDoParcelamento)
					.setInteger("idDebito", idDebito.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Seleciona o d?bito a cobrar para
	 * remover do parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<DebitoACobrar> pesquisarDebitoACobrarDoParcelamento(
			Integer codigoImovel, Integer codigoParcelamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<DebitoACobrar> retorno = null;
		String pesquisarDebitoACobrarDoParcelamento;

		try {
			// Atualiza em debitoacobrar o DebitoCreditoSituacao
			pesquisarDebitoACobrarDoParcelamento = "SELECT debitoACobrar FROM DebitoACobrar debitoACobrar "
					+ "WHERE debitoACobrar.imovel.id = :codigoImovel AND debitoACobrar.parcelamento.id = :codigoParcelamento ";

			retorno = session
					.createQuery(pesquisarDebitoACobrarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove credito a realizar
	 * referentes ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerCreditoARealizarDoParcelamento(Integer codigoImovel,
			Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCreditoARealizarDoParcelamento;
		String consulta;
		Collection collectionIdCredito = null;

		try {

			consulta = "select car.id  "
					+ "from CreditoARealizar car "
					+ "where car.imovel.id = :codigoImovel and car.parcelamento.id = :codigoParcelamento";

			collectionIdCredito = session
					.createQuery(consulta)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarCategoria creditoARealizarCategoria "
							+ "where creditoARealizarCategoria.creditoARealizar.id = :credito ";

					session.createQuery(consulta)
							.setInteger("credito", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta o debito a cobrar
			removerCreditoARealizarDoParcelamento = "delete CreditoARealizar "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerCreditoARealizarDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdCredito != null && !collectionIdCredito.isEmpty()) {

				Iterator icolecaoCreditos = collectionIdCredito.iterator();

				while (icolecaoCreditos.hasNext()) {

					String id = ((Integer) icolecaoCreditos.next()).toString();
					consulta = "delete CreditoARealizarGeral creditoARealizarGeral "
							+ "where creditoARealizarGeral.creditoARealizar.id = :credito ";

					session.createQuery(consulta)
							.setInteger("credito", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoDoParcelamento(Integer codigoImovel,
			Integer codigoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;
		String consulta;
		Collection collectionIdGuia = null;

		try {

			consulta = "select gui.id  "
					+ "from GuiaPagamento gui "
					+ "where gui.imovel.id = :codigoImovel and gui.parcelamento.id = :codigoParcelamento";

			collectionIdGuia = session
					.createQuery(consulta)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).list();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete GuiaPagamentoCategoria guiaPagamentoCategoria "
							+ "where guiaPagamentoCategoria.guiaPagamento.id = :guia ";

					session.createQuery(consulta)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();
				}
			}

			// deleta cobran?a documento item
			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
							+ "where cobrancaDocumentoItem.guiaPagamentoGeral.id = :guia ";

					session.createQuery(consulta)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();
				}

			}

			// deleta o debito a cobrar
			removerGuiaPagamentoDoParcelamento = "delete GuiaPagamento "
					+ "where imov_id = :codigoImovel and parc_id = :codigoParcelamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento)
					.setInteger("codigoImovel", codigoImovel.intValue())
					.setInteger("codigoParcelamento",
							codigoParcelamento.intValue()).executeUpdate();

			if (collectionIdGuia != null && !collectionIdGuia.isEmpty()) {

				Iterator icolecaoGuias = collectionIdGuia.iterator();

				while (icolecaoGuias.hasNext()) {

					String id = ((Integer) icolecaoGuias.next()).toString();
					consulta = "delete GuiaPagamentoGeral guiaPagamentoGeral "
							+ "where guiaPagamentoGeral.guiaPagamento.id = :guia ";

					session.createQuery(consulta)
							.setInteger("guia", new Integer(id).intValue())
							.executeUpdate();
				}
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove guia pagamento referentes
	 * ao parcelamento
	 * 
	 * @author Fernanda Karla
	 * @created 20/02/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerGuiaPagamentoCobrancaDoParcelamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerGuiaPagamentoDoParcelamento = "delete gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerGuiaPagamentoDoParcelamento)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0246] Executar Atividade de A??o de Cobran?a Pesquisa uma cole??o de
	 * CobrancaAcaoAtividadeCronograma
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronograma()
			throws ErroRepositorioException {

		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select caac "
					+ "from CobrancaAcaoAtividadeCronograma caac "
					+ " left join fetch caac.cobrancaAcaoCronograma cac"
					+ " left join fetch caac.cobrancaAtividade"
					+ " left join fetch cac.cobrancaAcao"
					+ " left join fetch cac.cobrancaGrupoCronogramaMes"
					+ " left join fetch cac.cobrancaGrupoCronogramaMes cgcm"
					+ " left join fetch cgcm.cobrancaGrupo"
					+ "where (caac.comando is not null) and "
					+ "((caac.realizacao is null) or (caac.realizacao < caac.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0246] Executar Atividade de A??o de Cobran?a Pesquisa uma cole??o de
	 * CobrancaAcaoAtividadeComando
	 * 
	 * @author Pedro Alexandre
	 * @created 01/02/2006
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeComando()
			throws ErroRepositorioException {

		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm "
					+ "from CobrancaAcaoAtividadeComando cacm "
					+ " left join fetch cacm.cobrancaAcao ca"
					+ " left join fetch cacm.cobrancaAtividade cat"
					+ " left join fetch cacm.usuario usuario"
					+ "where (cacm.comando is not null) and "
					+ "((cacm.realizacao is null) or (cacm.realizacao < cacm.comando))";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobran?a
	 * 
	 * @author S?vio Luiz
	 * @created 16/02/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id, documentoTipo.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com c?digo de Barras [SB0005] - Processar
	 * Recebimento de Acr?scimos por Inpontualidade Autor: S?vio Luiz
	 * Data:06/11/2006
	 */
	public Collection pesquisarCobrancaDocumentoItemComConta(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT conta " + "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "WHERE conta.id is not null AND "
					+ "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com c?digo de Barras [SB0005] - Processar
	 * Recebimento de Acr?scimos por Inpontualidade Autor: S?vio Luiz
	 * Data:06/11/2006
	 */
	public Collection pesquisarCobrancaDocumentoItemComGuiaPagamento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT guiaPagamento.id "
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "WHERE guiaPagamento.id is not null AND "
					+ "cd.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobran?a
	 * 
	 * @author S?vio Luiz, Ivan Sergio
	 * @created 16/02/2006 01/10/2010 - CRC5063 - Adicionado o id do Item para
	 *          auxiliar a CRC;
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id, " // 15
					+ "debitoACobrar.numeroPrestacaoDebito, " // 16
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 17
					+ "cdi.numeroParcelasAntecipadas, " // 18
					+ "cdi.id " // 19
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Inseri a cobran?a situa??o historico na base passando a cole??o de
	 * cobran?a situa??o historico
	 * 
	 * [UC0177] Informar Situacao Especial de Cobran?a
	 * 
	 * @author S?vio Luiz
	 * @date 20/03/2006
	 * 
	 * @param collectionCobrancaSituacaoHistorico
	 * @return
	 */
	public void inserirCobrancaSituacaoHistorico(
			Collection collectionCobrancaSituacaoHistorico)
			throws ErroRepositorioException {
		// StatelessSession session = HibernateUtil.getStatelessSession();
		// Iterator iteratorFSH =
		// collectionCobrancaSituacaoHistorico.iterator();
		// try {
		// // int i = 1;
		// while (iteratorFSH.hasNext()) {
		// CobrancaSituacaoHistorico cobrancaSituacaoHistorico =
		// (CobrancaSituacaoHistorico) iteratorFSH
		// .next();
		// session.insert(cobrancaSituacaoHistorico);
		// /*
		// * if (i % 50 == 0) { // 20, same as the JDBC batch size //
		// * flush a batch of inserts and release memory: session.flush();
		// * session.clear(); } i++;
		// */
		// }
		// // session.flush();
		// // session.clear();
		// } catch (HibernateException e) {
		// e.printStackTrace();
		// throw new ErroRepositorioException(e, "Erro no Hibernate");
		// } finally {
		//
		// // session.clear();
		// HibernateUtil.closeSession(session);
		// // session.close();
		// }
		//

		Session session = HibernateUtil.getSession();
		Iterator iteratorFSH = collectionCobrancaSituacaoHistorico.iterator();
		try {
			// int i = 1;
			while (iteratorFSH.hasNext()) {
				CobrancaSituacaoHistorico cobrancaSituacaoHistorico = (CobrancaSituacaoHistorico) iteratorFSH
						.next();
				session.save(cobrancaSituacaoHistorico);
				/*
				 * if (i % 50 == 0) { // 20, same as the JDBC batch size //
				 * flush a batch of inserts and release memory: session.flush();
				 * session.clear(); } i++;
				 */
			}
			session.flush();
			// session.clear();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// session.clear();
			HibernateUtil.closeSession(session);
			// session.close();
		}

	}

	/**
	 * Atualiza o ano mes de cobranca situa??o historico
	 * 
	 * [UC0156] Informar Situacao Especial Faturamento
	 * 
	 * @author S?vio Luiz
	 * @date 17/03/2006
	 * 
	 * @param situacaoEspecialFaturamentoHelper
	 * @throws ErroRepositorioException
	 */
	public void atualizarAnoMesCobrancaSituacaoHistorico(
			SituacaoEspecialCobrancaHelper situacaoEspecialCobrancaHelper,
			Integer anoMesReferencia, Collection colecaoImoveis,
			Integer idCobrancaSituacaoConsumo) throws ErroRepositorioException {

		String consulta = "";

		Session session = HibernateUtil.getSession();
		try {
			
				Iterator it = colecaoImoveis.iterator();
				Collection colApoio = new ArrayList();
				while(it.hasNext()){
					colApoio.add(it.next());
					if(colApoio.size() == 999){
						consulta = "update gcom.cobranca.CobrancaSituacaoHistorico set "
								+ "cbsc_idretirada = :idCobrancaSituacaoConsumo, "
								+ "cbsh_amcobrancaretirada = :anoMes,"
								+ "usur_idretira = null,"
								+ "cbsh_tmultimaalteracao = :ultimaAlteracao "
								+ "where imov_id in ( :imoveis )"
								+ " and cbsh_amcobrancaretirada is null";

						session.createQuery(consulta)
								.setParameterList("imoveis", colApoio)
								.setInteger("anoMes", anoMesReferencia)
								.setInteger("idCobrancaSituacaoConsumo",
										idCobrancaSituacaoConsumo)
								.setTimestamp("ultimaAlteracao", new Date())
								.executeUpdate();
						
						colApoio.clear();
					}
				}
				if(colApoio.size() > 0){
					consulta = "update gcom.cobranca.CobrancaSituacaoHistorico set "
							+ "cbsc_idretirada = :idCobrancaSituacaoConsumo, "
							+ "cbsh_amcobrancaretirada = :anoMes,"
							+ "usur_idretira = null,"
							+ "cbsh_tmultimaalteracao = :ultimaAlteracao "
							+ "where imov_id in ( :imoveis )"
							+ " and cbsh_amcobrancaretirada is null";
	
					session.createQuery(consulta)
							.setParameterList("imoveis", colApoio)
							.setInteger("anoMes", anoMesReferencia)
							.setInteger("idCobrancaSituacaoConsumo",
									idCobrancaSituacaoConsumo)
							.setTimestamp("ultimaAlteracao", new Date())
							.executeUpdate();
				}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Author: Rafael
	 * Santos Data: 30/03/2006 Pesquisa os ID das Contas dos cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIDContasClienteConta(String codigoCliente,
			Short relacaoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select conta.id from ClienteConta clienteConta "
					+ "inner join clienteConta.cliente cliente "
					+ "inner join clienteConta.conta conta ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join clienteConta.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta + "where cliente.id = :codigo ";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito atualizar na tabela imovel o
	 * parcelamento e reparcelamento
	 * 
	 * @author Fernanda Paiva
	 * @date 29/04/2006
	 * 
	 * @param imovel
	 * @param numeroParcelamento
	 * @param numeroReparcelamento
	 * @param numeroReparcelamentoConsecutivo
	 * @throws ErroRepositorioException
	 */
	public void atualizarDadosParcelamentoImovel(Integer codigoImovel,
			Short numeroParcelamento, Short numeroReparcelamento,
			Short numeroReparcelamentoConsecutivo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarImovel;

		try {
			atualizarImovel = "update gcom.cadastro.imovel.Imovel "
					+ "set imov_nnparcelamento = :numeroParcelamento, "
					+ "imov_nnreparcelamento = :numeroReparcelamento, "
					+ "imov_nnreparcmtconsec = :numeroReparcelamentoConsecutivo, "
					+ "imov_tmultimaalteracao = :ultimaAlteracao "
					+ "where imov_id = :codigoImovel";

			session.createQuery(atualizarImovel)
					.setInteger("codigoImovel",
							new Integer(codigoImovel).intValue())
					.setInteger("numeroParcelamento",
							new Short(numeroParcelamento).intValue())
					.setInteger("numeroReparcelamento",
							new Short(numeroReparcelamento).intValue())
					.setInteger(
							"numeroReparcelamentoConsecutivo",
							new Short(numeroReparcelamentoConsecutivo)
									.intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada N?o Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os parcelamentos de d?bitos efetuados no m?s de faturamento
	 * corrente e que estejam com situa??o normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormalNoMes(
			String parcelamentoSituacao, Integer anoMesReferenciaArrecadacao)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "WHERE parc.anoMesReferenciaFaturamento = :anoMesReferenciaArrecadacao "
					+ "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) "
					+ "AND dbac.numeroPrestacaoCobradas = 0 "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao))
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada N?o Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem as guias de pagamentos dos parcelamentos de d?bitos efetuados no
	 * m?s de faturamento corrente e que estejam com situa??o normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamento(String parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  "
					+ "FROM GuiaPagamento gpag "
					+ "WHERE gpag.parcelamento = :parcelamento ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", new Integer(parcelamento))
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada N?o Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem as contas dos parcelamentos de d?bitos efetuados no m?s de
	 * faturamento corrente e que estejam com situa??o normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamento(Integer parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta.id " + "FROM Conta cnta "
					+ "WHERE cnta.parcelamento.id = :parcelamento ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada N?o Paga Author: Fernanda
	 * Paiva Data: 02/05/2006
	 * 
	 * Obtem os pagamentos para a guia de pagamentos dos parcelamentos de
	 * d?bitos efetuados no m?s de faturamento corrente e que estejam com
	 * situa??o normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaGuiaPagamentoDoParcelamento(
			String igGuiaPagamento, Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// alterado por Vivianne Sousa - 03/09/2009 - Adriano Britto
			// alguns pagamentos n?o estavam guardando o id da guia,
			// para esses casos recupera o pagamento do imovel correspondente a
			// entrada de parcelamento
			consulta = " select pgmt_id as idPagamento "
					+ " from arrecadacao.pagamento "
					+ " where  gpag_id = :idGuiaPagamento "
					+ " or (imov_id = :idImovel and dbtp_id = :entradaParcelamento )";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idPagamento", Hibernate.INTEGER)
					.setInteger("idGuiaPagamento", new Integer(igGuiaPagamento))
					.setInteger("entradaParcelamento",
							DebitoTipo.ENTRADA_PARCELAMENTO)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Desfazer Parcelamentos por Entrada N?o Paga Author: Raphael
	 * Rossiter Data: 28/12/2006
	 * 
	 * Obtem os pagamentos para a conta dos parcelamentos de d?bitos efetuados
	 * no m?s de faturamento corrente e que estejam com situa??o normal
	 * 
	 * @param conta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarPagamentoParaContaDoParcelamento(String idConta)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT pgmt.id  " + "FROM Pagamento pgmt "
					+ "WHERE pgmt.contaGeral = :conta ";

			retorno = session.createQuery(consulta)
					.setInteger("conta", new Integer(idConta)).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0317] Manter Crit?rio de Cobran?a
	 * 
	 * Este caso de uso remove as linhas da cobran?a crit?rio passando a colecao
	 * de cobran?a criterio
	 * 
	 * [SB0002] Excluir Crit?rio de Cobran?a
	 * 
	 * @author S?vio luiz
	 * @created 11/05/2006
	 * 
	 * @throws ControladorException
	 *             Controlador Exception
	 */
	public void removerCobrancaCriterioLinha(String[] idscobrancaCriterio)
			throws ErroRepositorioException {

		String remocao = null;

		/*
		 * Collection colecaoCobrancaCriterio = new ArrayList(); for(int
		 * i=0;i<idscobrancaCriterio.length;i++ ){ CobrancaCriterio
		 * cobrancaCriterio = new CobrancaCriterio(); cobrancaCriterio.setId(new
		 * Integer(idscobrancaCriterio[i]));
		 * colecaoCobrancaCriterio.add(cobrancaCriterio); }
		 */

		Session session = HibernateUtil.getSession();

		try {

			remocao = "delete gcom.cobranca.CobrancaCriterioLinha "
					+ "where cbct_id IN(:idscobrancaCriterio)";

			session.createQuery(remocao)
					.setParameterList("idscobrancaCriterio",
							idscobrancaCriterio).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	public Collection gerarRelacaoDebitos(String idImovelCondominio,
			String idImovelPrincipal, String idNomeConta,
			String idSituacaoLigacaoAgua, String consumoMinimoInicialAgua,
			String consumoMinimoFinalAgua, String idSituacaoLigacaoEsgoto,
			String consumoMinimoInicialEsgoto, String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String ordenacao, int quantidadeImovelInicio,
			String indicadorCpfCnpj, String cpfCnpj)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT DISTINCT greg.greg_id AS idGerenciaRegional," // 0
					+ " greg.greg_nmabreviado AS nomeGerenciaRegionalAbreviado,"// 1
					+ " loca.loca_id AS idLocalidade,"// 2
					+ " loca.loca_nmlocalidade AS nomeLocalidade,"// 3
					+ " imov1.imov_id AS idImovel,"// 4
					+ " imov1.imov_qteconomia AS qtdEconomia,"// 5
					+ " stcm.stcm_cdsetorcomercial AS codigoSetorComercial,"// 6
					+ " qdra.qdra_nnquadra AS numeroQuadra,"// 7
					+ " imov1.imov_nnlote AS numeroLote,"// 8
					+ " imov1.imov_nnsublote AS numeroSubLote,"// 9
					+ " lastt.last_dsligacaoaguasituacao AS descricaoLigacaoAguaSituacao,"// 10
					+ " lestt.lest_dsligacaoesgotosituacao AS descricaoLigacaoEsgotoSituacao,"// 11
					+ " lesg.lesg_pcesgoto AS percentuaEsgoto,"// 12
					+ " lagu.lagu_dtcorte AS dataCorte,"// 13
					+ " greg.greg_nmregional AS nomeGerenciaRegional,"// 14
					+ " clieUsur.clie_nmcliente AS nomeClienteUsuario,"// 15
					+ " clieResp.clie_nmcliente AS nomeClienteResponsavel,"// 16
					+ " rota.rota_cdrota AS codigoRota,"// 17
					+ " imov1.imov_nnsequencialrota AS numeroSequencialRota,"// 18
					+ " (SELECT NVL(SUM(cnta4.cnta_vlagua+cnta4.cnta_vlesgoto+cnta4.cnta_vldebitos-cnta4.cnta_vlcreditos-NVL(cnta4.cnta_vlimpostos, 0)), 0)"
					+ " FROM faturamento.conta cnta4"
					+ " WHERE imov1.imov_id =cnta4.imov_id"
					+ " AND (cnta4.dcst_idatual IN (0 , 1 , 2))"
					+ " AND (cnta4.cnta_id NOT IN (SELECT NVL(pgmt1.cnta_id, 0) FROM arrecadacao.pagamento pgmt1 WHERE pgmt1.imov_id=cnta4.imov_id ))) AS valorConta,"// 19
					+ " scat.scat_dssubcategoria AS descricaoSubcategoria,"// 20
					+ " catg.catg_dscategoria AS descricaoCategoria,"// 21
					+ " (SELECT cshi.cshi_nnconsumomedio"
					+ " FROM micromedicao.consumo_historico cshi"
					+ " INNER JOIN cadastro.imovel imovel46_"
					+ " ON cshi.imov_id=imovel46_.imov_id"
					+ " INNER JOIN micromedicao.ligacao_tipo ligacaotip47_"
					+ " ON cshi.lgti_id            =ligacaotip47_.lgti_id"
					+ " WHERE imov1.imov_id              =imovel46_.imov_id"
					+ " AND ligacaotip47_.lgti_id           =1"
					+ " AND cshi.cshi_amfaturamento="
					+ " (SELECT MAX(cshi1.cshi_amfaturamento)"
					+ " FROM micromedicao.consumo_historico cshi1"
					+ " INNER JOIN cadastro.imovel imov3"
					+ " ON cshi1.imov_id=imov3.imov_id"
					+ " INNER JOIN micromedicao.ligacao_tipo ligacaotip50_"
					+ " ON cshi1.lgti_id =ligacaotip50_.lgti_id"
					+ " WHERE imov3.imov_id  =imov1.imov_id"
					+ " AND ligacaotip50_.lgti_id=1"
					+ " )"
					+ " ) AS consumoMedio"// 22
					+ " FROM cadastro.imovel imov1"
					+ " INNER JOIN cadastro.imovel_subcategoria imovScat ON imovScat.imov_id=imov1.imov_id"
					+ " INNER JOIN cadastro.subcategoria scat ON imov1.imov_idsubcategoriaprincipal = scat.scat_id"
					+ " INNER JOIN cadastro.categoria catg ON imov1.imov_idcategoriaprincipal = catg.catg_id"
					+ " INNER JOIN cadastro.localidade loca ON imov1.loca_id=loca.loca_id"
					+ " INNER JOIN cadastro.gerencia_regional greg ON loca.greg_id=greg.greg_id"
					+ " INNER JOIN cadastro.setor_comercial stcm ON imov1.stcm_id=stcm.stcm_id"
					+ " INNER JOIN cadastro.quadra qdra ON imov1.qdra_id=qdra.qdra_id"
					+ " INNER JOIN micromedicao.rota rota ON qdra.rota_id=rota.rota_id"
					+ " INNER JOIN cadastro.logradouro_bairro lgbr ON imov1.lgbr_id=lgbr.lgbr_id"
					+ " INNER JOIN cadastro.bairro bair ON lgbr.bair_id=bair.bair_id"
					+ " INNER JOIN atendimentopublico.ligacao_agua_situacao lastt ON imov1.last_id=lastt.last_id"
					+ " INNER JOIN atendimentopublico.ligacao_esgoto_situacao lestt ON imov1.lest_id=lestt.lest_id"
					+ " LEFT JOIN cadastro.logradouro_cep lgcp ON imov1.lgcp_id=lgcp.lgcp_id"
					+ " LEFT JOIN cadastro.cep cpe ON lgcp.cep_id=cpe.cep_id"
					+ " LEFT JOIN atendimentopublico.ligacao_agua lagu ON imov1.imov_id=lagu.lagu_id"
					+ " LEFT JOIN atendimentopublico.ligacao_esgoto lesg ON imov1.imov_id=lesg.lesg_id"
					+ " LEFT JOIN micromedicao.hidrometro_inst_hist hidi ON lagu.hidi_id=hidi.hidi_id"
					+ " LEFT JOIN cobranca.cobranca_situacao_tipo cbsp ON imov1.cbsp_id=cbsp.cbsp_id"
					+ " LEFT JOIN cadastro.elo_anormalidade eanm ON imov1.eanm_id=eanm.eanm_id"
					+ " LEFT JOIN micromedicao.hidrometro_inst_hist hidiImovel ON imov1.hidi_id=hidiImovel.hidi_id"
					+ " LEFT JOIN micromedicao.medicao_historico mdhi ON imov1.imov_id=mdhi.imov_id"
					+ " INNER JOIN cadastro.cliente_imovel clim ON imov1.imov_id=clim.imov_id"
					+ " INNER JOIN cadastro.cliente clie ON clim.clie_id=clie.clie_id"
					+ " LEFT JOIN cadastro.cliente_imovel clieImovUsur ON imov1.imov_id =clieImovUsur.imov_id AND (clieImovUsur.crtp_id =2 AND (clieImovUsur.clim_dtrelacaofim IS NULL))"
					+ " LEFT JOIN cadastro.cliente clieUsur ON clieImovUsur.clie_id=clieUsur.clie_id"
					+ " LEFT JOIN cadastro.cliente_imovel clieRespImov ON imov1.imov_id =clieRespImov.imov_id AND (clieRespImov.crtp_id =3 AND (clieRespImov.clim_dtrelacaofim IS NULL))"
					+ " LEFT JOIN cadastro.cliente clieResp ON clieRespImov.clie_id=clieResp.clie_id";

			// falta imovel cobranca situacao
			if (idCobrancaSituacaoTipo != null
					&& !idCobrancaSituacaoTipo.equals("")
					&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " left join cadastro.imovel_cobranca_situacao iscb on iscb.imov_id = imov1.imov_id ";
			}

			// intervalo Media Minima Imovel Inicial e Final
			if ((intervaloMediaMinimaImovelInicial != null
					&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaImovelFinal != null
							&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " left join micromedicao.consumo_historico consumosHistorico on consumosHistorico.imov_id = imov1.imov_id ";
			}

			consulta = consulta + " where 1=1 ";

			// cobranca situacao tipo
			if (idCobrancaSituacaoTipo != null
					&& !idCobrancaSituacaoTipo.equals("")
					&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " iscb.cbst_id = :idCobrancaSituacaoTipo and iscb.iscb_amreferenciafinal is null ";
			}

			// intervalo Media Minima Imovel Inicial e Final
			if ((intervaloMediaMinimaImovelInicial != null
					&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaImovelFinal != null
							&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and consumosHistorico.cshi_nnconsumomedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.cshi_nnconsumomedio <= :intervaloMediaMinimaImovelFinal ";
			}

			// ID DO CLIENTE
			if (idCliente != null
					&& !idCliente.equals("")
					&& !idCliente.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and clie.clie_id = :idCliente  ";
			}

			// cliente tipo
			if (idClienteTipo != null
					&& !idClienteTipo.equals("")
					&& !idClienteTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and clie.cltp_id = :idClienteTipo ";
			}

			// cliente relacao tipo
			if (idClienteRelacaoTipo != null
					&& !idClienteRelacaoTipo.equals("")
					&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and clim.crtp_id = :idClienteRelacaoTipo ";
			}

			if (indicadorCpfCnpj != null && indicadorCpfCnpj.equals("2")) {
				consulta = consulta
						+ " and clie.clie_nncpf is null and clie.clie_nncpnj is null ";

			}

			if (cpfCnpj != null && !cpfCnpj.equals("")) {
				consulta = consulta
						+ " and (clie.clie_nncpf = :cpfCnpj or clie.clie_nncnpj = :cpfCnpj) ";

				if (idClienteRelacaoTipo != null
						&& idClienteRelacaoTipo.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {
					consulta = consulta + " and clim.crtp_id = "
							+ ClienteRelacaoTipo.USUARIO + " ";
				}
			}

			// gerencia regional
			if (idGerenciaRegional != null
					&& !idGerenciaRegional.equals("")
					&& !idGerenciaRegional.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and greg.greg_id = :idGerenciaRegional ";
			}

			// localidade inicial e final
			if (((idLocalidadeInicial != null
					&& !idLocalidadeInicial.equals("") && !idLocalidadeInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) && (idLocalidadeFinal != null
					&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())))) {
				consulta = consulta
						+ " and loca.loca_id >= :idLocalidadeInicial and loca.loca_id <= :idLocalidadeFinal ";
			}

			// setor comercial inicial e final
			if (((setorComercialInicial != null
					&& !setorComercialInicial.equals("") && !setorComercialInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) && (setorComercialFinal != null
					&& !setorComercialFinal.equals("") && !setorComercialFinal
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())))) {
				consulta = consulta
						+ " and stcm.stcm_cdsetorcomercial >= :setorComercialInicial and stcm.stcm_cdsetorcomercial <= :setorComercialFinal ";
			}

			// quadra
			if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and qdra.qdra_nnquadra >= :quadraInicial and qdra.qdra_nnquadra <= :quadraFinal ";
			}

			// lote
			if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and imov1.imov_nnlote >= :loteOrigem  and  imov1.imov_nnlote <= :loteDestino ";
			}

			// cep
			if (cep != null
					&& !cep.equals("")
					&& !cep.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and cpe.cep_cdcep = :cep  ";
			}
			// logradouro
			if (logradouro != null
					&& !logradouro.equals("")
					&& !logradouro.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and lgcp.logr_id = :logradouro  ";
			}
			// bairro
			if (bairro != null
					&& !bairro.equals("")
					&& !bairro.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and bair.bair_cdbairro = :bairro  ";
			}
			// municipio
			if (municipio != null
					&& !municipio.equals("")
					&& !municipio.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and bair.muni_id = :municipio  ";
			}
			// consumo minimo agua inicial e final
			if ((consumoMinimoInicialAgua != null
					&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (consumoMinimoFinalAgua != null
							&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and lagu.lagu_nnconsumominimoagua >= :consumoMinimoInicialAgua and lagu.lagu_nnconsumominimoagua <= :consumoMinimoFinalAgua  ";
			}
			// consumo minimo esgoto inicial e final
			if ((consumoMinimoInicialEsgoto != null
					&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (consumoMinimoFinalEsgoto != null
							&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and lesg.lesg_nnconsumominimoesgoto >= :consumoMinimoInicialEsgoto and lesg.lesg_nnconsumominimoesgoto <= :consumoMinimoFinalEsgoto ";
			}

			// percentual esgoto inicial e final
			if ((intervaloValorPercentualEsgotoInicial != null
					&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloValorPercentualEsgotoFinal != null
							&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {

				consulta = consulta
						+ " and lesg.lesg_pcesgoto >= :intervaloValorPercentualEsgotoInicial and lesg.lesg_pcesgoto <= :intervaloValorPercentualEsgotoFinal  ";
			}

			// indicador medicao
			if (indicadorMedicao != null
					&& indicadorMedicao.equals("comMedicao")) {

				// tipo medicao
				if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA
								.toString())) {
					consulta = consulta + " and hidi.hidi_id is not null ";

				} else if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
					consulta = consulta
							+ " and hidiImovel.hidi_id is not null ";

				} else {
					consulta = consulta
							+ " and (hidi.hidi_id is not null or hidiImovel.hidi_id is not null)  ";
				}
			} else if (indicadorMedicao != null
					&& indicadorMedicao.equals("semMedicao")) {
				consulta = consulta
						+ " and (hidi.hidi_id is null and hidiImovel.hidi_id is null) ";
			}

			// imovel condominio
			if (idImovelCondominio != null
					&& !idImovelCondominio.equals("")
					&& !idImovelCondominio.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.imov_idimovelcondominio = :idImovelCondominio  ";
			}
			// imovel principal
			if (idImovelPrincipal != null
					&& !idImovelPrincipal.equals("")
					&& !idImovelPrincipal.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.imov_idimovelprincipal = :idImovelPrincipal  ";
			}

			// situacao da ligacao de agua
			if (idSituacaoLigacaoAgua != null
					&& !idSituacaoLigacaoAgua.equals("")
					&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and lastt.last_id = :idSituacaoLigacaoAgua  ";
			}
			// situacao ligacao de esgoto
			if (idSituacaoLigacaoEsgoto != null
					&& !idSituacaoLigacaoEsgoto.equals("")
					&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and lestt.lest_id = :idSituacaoLigacaoEsgoto  ";
			}
			// imovel Perfil
			if (idImovelPerfil != null
					&& !idImovelPerfil.equals("")
					&& !idImovelPerfil.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and imov1.iper_id = :idImovelPerfil  ";
			}

			// poco tipo
			if (idPocoTipo != null
					&& !idPocoTipo.equals("")
					&& !idPocoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and imov1.poco_id = :idPocoTipo ";
			}
			// faturamento situacao tipo
			if (idFaturamentoSituacaoTipo != null
					&& !idFaturamentoSituacaoTipo.equals("")
					&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.fttp_id = idFaturamentoSituacaoTipo ";
			}

			// Situacao Especial Cobranca
			if (idSituacaoEspecialCobranca != null
					&& !idSituacaoEspecialCobranca.equals("")
					&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.ftst_id = :idSituacaoEspecialCobranca ";
			}

			// elo anormalidade
			if (idEloAnormalidade != null
					&& !idEloAnormalidade.equals("")
					&& !idEloAnormalidade.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.eanm_id = :idEloAnormalidade ";
			}
			// cadastro ocorrencia
			if (idCadastroOcorrencia != null
					&& !idCadastroOcorrencia.equals("")
					&& !idCadastroOcorrencia.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.cocr_id = :idCadastroOcorrencia ";
			}

			// area construida inicial e final
			if ((areaConstruidaInicial != null
					&& !areaConstruidaInicial.equals("") && !areaConstruidaInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (areaConstruidaFinal != null
							&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and imov1.imov_nnareaconstruida >= :areaConstruidaInicial and imov1.imov_nnareaconstruida <= :areaConstruidaFinal  ";
			}

			// consumo tarifa
			if (idConsumoTarifa != null
					&& !idConsumoTarifa.equals("")
					&& !idConsumoTarifa.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and imov1.cstf_id = :idConsumoTarifa ";
			}

			// intervalo MediaMinima Hidrometro Inicial e Final
			if ((intervaloMediaMinimaHidrometroInicial != null
					&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaHidrometroFinal != null
							&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and mdhi.mdhi_nnconsumomediohidrometro >= :intervaloMediaMinimaHidrometroInicial and mdhi.mdhi_nnconsumomediohidrometro <= :intervaloMediaMinimaHidrometroFinal  ";
			}
			// categoria
			if (idCategoria != null
					&& !idCategoria.equals("")
					&& !idCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and catg.catg_id = :idCategoria  ";
			}
			// sub categoria
			if (idSubCategoria != null
					&& !idSubCategoria.equals("")
					&& !idSubCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and scat.scat_id = :idSubCategoria  ";
			}
			// quantidade economias inicial e final
			if ((quantidadeEconomiasInicial != null
					&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (quantidadeEconomiasFinal != null
							&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and imovScat.imsb_qteconomia >= :quantidadeEconomiasInicial and imovScat.imsb_qteconomia <= :quantidadeEconomiasFinal ";
			}

			// dia Vencimento
			if (diaVencimento != null
					&& !diaVencimento.equals("")
					&& !diaVencimento.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				if (diaVencimento.equals("1")) {// sim
					consulta = consulta
							+ " and imov1.imov_ddvencimento is not null ";
				}
			}

			// numero prontos inicial e final
			if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (numeroPontosFinal != null
							&& !numeroPontosFinal.equals("") && !numeroPontosFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and imov1.imov_nnpontosutilizacao >= :numeroPontosInicial and imov1.imov_nnpontosutilizacao <= :numeroPontosFinal ";
			}

			// numero moradores inicial e final
			if ((numeroMoradoresInicial != null
					&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (numeroMoradoresFinal != null
							&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				consulta = consulta
						+ " and imov1.imov_nnmorador >= :numeroMoradoresInicial and imov1.imov_nnmorador <= :numeroMoradoresFinal ";
			}
			// area construida faixa
			if (idAreaConstruidaFaixa != null
					&& !idAreaConstruidaFaixa.equals("")
					&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta
						+ " and imov1.acon_id = :idAreaConstruidaFaixa ";
			}

			if (ordenacao != null
					&& !ordenacao.trim().equals("")
					&& !ordenacao.trim().equals(
							"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {

				if (ordenacao.trim().equals("rota")) {
					consulta = consulta
							+ " order by greg.greg_id, loca.loca_id, stcm.stcm_cdsetorcomercial, rota.rota_cdrota, imov1.imov_nnsequencialrota";
				}

			} else {
				consulta = consulta
						+ " order by  greg.greg_id, loca.loca_id, valorConta desc";
			}

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegionalAbreviado",
							Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("qtdEconomia", Hibernate.SHORT)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("numeroLote", Hibernate.SHORT)
					.addScalar("numeroSubLote", Hibernate.SHORT)
					.addScalar("descricaoLigacaoAguaSituacao", Hibernate.STRING)
					.addScalar("descricaoLigacaoEsgotoSituacao",
							Hibernate.STRING)
					.addScalar("percentuaEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("dataCorte", Hibernate.DATE)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("nomeClienteUsuario", Hibernate.STRING)
					.addScalar("nomeClienteResponsavel", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencialRota", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("descricaoSubcategoria", Hibernate.STRING)
					.addScalar("descricaoCategoria", Hibernate.STRING)
					.addScalar("consumoMedio", Hibernate.STRING);

			// gerencia regional
			if (idGerenciaRegional != null
					&& !idGerenciaRegional.equals("")
					&& !idGerenciaRegional.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idGerenciaRegional", new Integer(
						idGerenciaRegional).intValue());
			}
			// localidade inicial e final
			if (((idLocalidadeInicial != null
					&& !idLocalidadeInicial.equals("") && !idLocalidadeInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) && (idLocalidadeFinal != null
					&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())))) {
				query.setInteger("idLocalidadeInicial", new Integer(
						idLocalidadeInicial).intValue());
				query.setInteger("idLocalidadeFinal", new Integer(
						idLocalidadeFinal).intValue());
			}
			// setor comercial inicial e final
			if (((setorComercialInicial != null
					&& !setorComercialInicial.equals("") && !setorComercialInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) && (setorComercialFinal != null
					&& !setorComercialFinal.equals("") && !setorComercialFinal
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())))) {
				query.setInteger("setorComercialInicial", new Integer(
						setorComercialInicial).intValue());
				query.setInteger("setorComercialFinal", new Integer(
						setorComercialFinal).intValue());
			}
			// quadra inicial e final
			if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("quadraInicial",
						new Integer(quadraInicial).intValue());
				query.setInteger("quadraFinal",
						new Integer(quadraFinal).intValue());
			}
			// lote
			if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("loteOrigem",
						new Integer(loteOrigem).intValue());
				query.setInteger("loteDestino",
						new Integer(loteDestno).intValue());
			}
			// cep
			if (cep != null
					&& !cep.equals("")
					&& !cep.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("cep", new Integer(cep).intValue());
			}
			// logradouro
			if (logradouro != null
					&& !logradouro.equals("")
					&& !logradouro.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("logradouro",
						new Integer(logradouro).intValue());
			}
			// bairro
			if (bairro != null
					&& !bairro.equals("")
					&& !bairro.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("bairro", new Integer(bairro).intValue());
			}
			// municipio
			if (municipio != null
					&& !municipio.equals("")
					&& !municipio.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("municipio", new Integer(municipio).intValue());
			}
			// consumo minimo agua inicial e final
			if ((consumoMinimoInicialAgua != null
					&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (consumoMinimoFinalAgua != null
							&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("consumoMinimoInicialAgua", new Integer(
						consumoMinimoInicialAgua).intValue());
				query.setInteger("consumoMinimoFinalAgua", new Integer(
						consumoMinimoFinalAgua).intValue());
			}
			// consumo minimo esgoto inicial e final
			if ((consumoMinimoInicialEsgoto != null
					&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (consumoMinimoFinalEsgoto != null
							&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("consumoMinimoInicialEsgoto", new Integer(
						consumoMinimoInicialEsgoto).intValue());
				query.setInteger("consumoMinimoFinalEsgoto", new Integer(
						consumoMinimoFinalEsgoto).intValue());
			}
			// percentual esgoto inicial e final
			if ((intervaloValorPercentualEsgotoInicial != null
					&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloValorPercentualEsgotoFinal != null
							&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("intervaloValorPercentualEsgotoInicial",
						new BigDecimal(intervaloValorPercentualEsgotoInicial)
								.intValue());
				query.setInteger("intervaloValorPercentualEsgotoFinal",
						new BigDecimal(intervaloValorPercentualEsgotoFinal)
								.intValue());
			}
			// imovel condominio
			if (idImovelCondominio != null
					&& !idImovelCondominio.equals("")
					&& !idImovelCondominio.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idImovelCondominio", new Integer(
						idImovelCondominio).intValue());
			}
			// imovel principal
			if (idImovelPrincipal != null
					&& !idImovelPrincipal.equals("")
					&& !idImovelPrincipal.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idImovelPrincipal", new Integer(
						idImovelPrincipal).intValue());
			}

			// Situacao Ligacao Agua
			if (idSituacaoLigacaoAgua != null
					&& !idSituacaoLigacaoAgua.equals("")
					&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idSituacaoLigacaoAgua", new Integer(
						idSituacaoLigacaoAgua).intValue());
			}

			// situa??o liga??o de esgoto
			if (idSituacaoLigacaoEsgoto != null
					&& !idSituacaoLigacaoEsgoto.equals("")
					&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idSituacaoLigacaoEsgoto", new Integer(
						idSituacaoLigacaoEsgoto).intValue());
			}
			// imovel Perfil
			if (idImovelPerfil != null
					&& !idImovelPerfil.equals("")
					&& !idImovelPerfil.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idImovelPerfil",
						new Integer(idImovelPerfil).intValue());
			}
			// poco tipo
			if (idPocoTipo != null
					&& !idPocoTipo.equals("")
					&& !idPocoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idPocoTipo",
						new Integer(idPocoTipo).intValue());
			}
			// faturamento situacao tipo
			if (idFaturamentoSituacaoTipo != null
					&& !idFaturamentoSituacaoTipo.equals("")
					&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idFaturamentoSituacaoTipo", new Integer(
						idFaturamentoSituacaoTipo).intValue());
			}
			// cobranca situacao tipo
			if (idCobrancaSituacaoTipo != null
					&& !idCobrancaSituacaoTipo.equals("")
					&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idCobrancaSituacaoTipo", new Integer(
						idCobrancaSituacaoTipo).intValue());
			}
			// Situacao Especial Cobranca
			if (idSituacaoEspecialCobranca != null
					&& !idSituacaoEspecialCobranca.equals("")
					&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idSituacaoEspecialCobranca", new Integer(
						idSituacaoEspecialCobranca).intValue());
			}
			// elo anormalidade
			if (idEloAnormalidade != null
					&& !idEloAnormalidade.equals("")
					&& !idEloAnormalidade.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idEloAnormalidade", new Integer(
						idEloAnormalidade).intValue());
			}
			// cadastro ocorrencia
			if (idCadastroOcorrencia != null
					&& !idCadastroOcorrencia.equals("")
					&& !idEloAnormalidade.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idCadastroOcorrencia", new Integer(
						idCadastroOcorrencia).intValue());
			}
			// area construida inicial e final
			if ((areaConstruidaInicial != null
					&& !areaConstruidaInicial.equals("") && !areaConstruidaInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (areaConstruidaFinal != null
							&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setBigDecimal("areaConstruidaInicial", Util
						.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
				query.setBigDecimal("areaConstruidaFinal", Util
						.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
			}
			// consumo tarifa
			if (idConsumoTarifa != null
					&& !idConsumoTarifa.equals("")
					&& !idConsumoTarifa.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idConsumoTarifa",
						new Integer(idConsumoTarifa).intValue());
			}
			// intervalo Media Minima Imovel Inicial e Final
			if ((intervaloMediaMinimaImovelInicial != null
					&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaImovelFinal != null
							&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("intervaloMediaMinimaImovelInicial",
						new Integer(intervaloMediaMinimaImovelInicial)
								.intValue());
				query.setInteger("intervaloMediaMinimaImovelFinal",
						new Integer(intervaloMediaMinimaImovelFinal).intValue());
			}
			// intervalo MediaMinima Hidrometro Inicial e Final
			if ((intervaloMediaMinimaHidrometroInicial != null
					&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (intervaloMediaMinimaHidrometroFinal != null
							&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setInteger("intervaloMediaMinimaHidrometroInicial",
						new Integer(intervaloMediaMinimaHidrometroInicial)
								.intValue());
				query.setInteger("intervaloMediaMinimaHidrometroFinal",
						new Integer(intervaloMediaMinimaHidrometroFinal)
								.intValue());
			}

			// quantidade economias inicial e final
			if ((quantidadeEconomiasInicial != null
					&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (quantidadeEconomiasFinal != null
							&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setShort("quantidadeEconomiasInicial", new Short(
						quantidadeEconomiasInicial).shortValue());
				query.setShort("quantidadeEconomiasFinal", new Short(
						quantidadeEconomiasFinal).shortValue());
			}

			// categoria
			if (idCategoria != null
					&& !idCategoria.equals("")
					&& !idCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idCategoria",
						new Integer(idCategoria).intValue());
			}

			// sub categoria
			if (idSubCategoria != null
					&& !idSubCategoria.equals("")
					&& !idSubCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idSubCategoria",
						new Integer(idSubCategoria).intValue());
			}

			// numero prontos inicial e final
			if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (numeroPontosFinal != null
							&& !numeroPontosFinal.equals("") && !numeroPontosFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setShort("numeroPontosInicial", new Short(
						numeroPontosInicial).shortValue());
				query.setShort("numeroPontosFinal",
						new Short(numeroPontosFinal).shortValue());
			}

			// numero moradores inicial e final
			if ((numeroMoradoresInicial != null
					&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
					.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString()))
					&& (numeroMoradoresFinal != null
							&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
							.trim()
							.equalsIgnoreCase(
									new Integer(
											ConstantesSistema.NUMERO_NAO_INFORMADO)
											.toString()))) {
				query.setShort("numeroMoradoresInicial", new Short(
						numeroMoradoresInicial).shortValue());
				query.setShort("numeroMoradoresFinal", new Short(
						numeroMoradoresFinal).shortValue());
			}
			// area construida faixa
			if (idAreaConstruidaFaixa != null
					&& !idAreaConstruidaFaixa.equals("")
					&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idAreaConstruidaFaixa", new Integer(
						idAreaConstruidaFaixa).intValue());
			}

			// cliente
			if (idCliente != null
					&& !idCliente.equals("")
					&& !idCliente.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idCliente", new Integer(idCliente).intValue());
			}

			// cliente tipo
			if (idClienteTipo != null
					&& !idClienteTipo.equals("")
					&& !idClienteTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idClienteTipo",
						new Integer(idClienteTipo).intValue());
			}

			// cliente relacao tipo
			if (idClienteRelacaoTipo != null
					&& !idClienteRelacaoTipo.equals("")
					&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				query.setInteger("idClienteRelacaoTipo", new Integer(
						idClienteRelacaoTipo).intValue());
			}

			if (cpfCnpj != null && !cpfCnpj.equals("")) {
				query.setString("cpfCnpj", cpfCnpj);
			}

			retorno = query.setFirstResult(quantidadeImovelInicio)
					.setMaxResults(500).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Gerar Rela??o de D?bitos
	 * 
	 * [UC0227] Gerar Rela??o de D?bitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public Integer obterQuantidadaeRelacaoImoveisDebitos(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(distinct imovel.id) "
					+ " from ImovelSubcategoria imovelSubcategoria, ImovelCobrancaSituacao imovelCobrancaSituacao "
					+ " inner join  imovelSubcategoria.comp_id.imovel imovel "
					+ " left  join  imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ " left join subcategoria.categoria categoria   "
					+ " inner join imovel.localidade localidade   "
					+ " inner join localidade.gerenciaRegional gerenciaRegional "
					+ " inner join imovel.setorComercial setorComercial   "
					+ " left  join imovel.logradouroBairro logradouroBairro  "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " left  join bairro.municipio municipio   "
					+ " left  join imovel.logradouroBairro logradouroBairro "
					+ " left  join logradouroBairro.bairro bairro   "
					+ " inner join imovel.quadra quadra   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.cep cep   "
					+ " left  join imovel.logradouroCep logradouroCep "
					+ " left  join logradouroCep.logradouro logradouro   "
					+ " left  join imovel.imovelCondominio imovelCondominio   "
					+ " left  join imovel.imovelPrincipal imovelPrincipal   "
					// + " left join imovel.nomeConta nomeConta "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua  "
					+ " left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " left  join imovel.ligacaoEsgoto ligacaoEsgoto  "
					+ " left  join imovel.imovelPerfil imovelPerfil  "
					+ " left  join imovel.pocoTipo pocoTipo   "
					+ " left  join imovel.faturamentoTipo faturamentoTipo "
					+ " left  join imovel.cobrancaSituacaoTipo cobrancaSituacaoTipo "
					+ " left  join imovel.faturamentoSituacaoTipo faturamentoSituacaoTipo "
					+ " left  join imovel.eloAnormalidade eloAnormalidade   "
					+ " left  join imovel.cadastroOcorrencia cadastroOcorrencia "
					+ " left  join imovel.areaConstruidaFaixa areaConstruidaFaixa  "
					+ " left  join imovel.consumoTarifa consumoTarifa   "
					+ " left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel  "
					+ " left  join imovel.ligacaoAgua ligacaoAgua   "
					+ " left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " left join imovel.consumosHistoricos consumosHistorico   "
					+ " left join imovel.medicaoHistoricos medicaoHistorico   "
					+ " left join imovel.clienteImoveis clienteImoveis "
					+ " left join clienteImoveis.clienteRelacaoTipo clienteRelacaoTipo "
					+ " left join clienteImoveis.cliente cliente "
					+ " left join cliente.clienteTipo clienteTipo "
					+ " left join imovel.consumosHistoricos consumosHistorico ";

			consulta = consulta
					+ montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(
							idImovelCondominio, idImovelPrincipal, idNomeConta,
							idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
							consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
							consumoMinimoInicialEsgoto,
							consumoMinimoFinalEsgoto,
							intervaloValorPercentualEsgotoInicial,
							intervaloValorPercentualEsgotoFinal,
							intervaloMediaMinimaImovelInicial,
							intervaloMediaMinimaImovelFinal,
							intervaloMediaMinimaHidrometroInicial,
							intervaloMediaMinimaHidrometroFinal,
							idImovelPerfil, idPocoTipo,
							idFaturamentoSituacaoTipo, idCobrancaSituacaoTipo,
							idSituacaoEspecialCobranca, idEloAnormalidade,
							areaConstruidaInicial, areaConstruidaFinal,
							idCadastroOcorrencia, idConsumoTarifa,
							idGerenciaRegional, idLocalidadeInicial,
							idLocalidadeFinal, setorComercialInicial,
							setorComercialFinal, quadraInicial, quadraFinal,
							loteOrigem, loteDestno, cep, logradouro, bairro,
							municipio, idTipoMedicao, indicadorMedicao,
							idSubCategoria, idCategoria,
							quantidadeEconomiasInicial,
							quantidadeEconomiasFinal, diaVencimento, idCliente,
							idClienteTipo, idClienteRelacaoTipo,
							numeroPontosInicial, numeroPontosFinal,
							numeroMoradoresInicial, numeroMoradoresFinal,
							idAreaConstruidaFaixa);

			/*
			 * # COLOCANDO O VALOR NAS CONDI??ES#
			 */

			Query query = session.createQuery(consulta);

			informarDadosQueryFiltrarImovelOutrosCriterio(query,
					idImovelCondominio, idImovelPrincipal, idNomeConta,
					idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
					consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
					consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
					intervaloValorPercentualEsgotoInicial,
					intervaloValorPercentualEsgotoFinal,
					intervaloMediaMinimaImovelInicial,
					intervaloMediaMinimaImovelFinal,
					intervaloMediaMinimaHidrometroInicial,
					intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
					idPocoTipo, idFaturamentoSituacaoTipo,
					idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
					idEloAnormalidade, areaConstruidaInicial,
					areaConstruidaFinal, idCadastroOcorrencia, idConsumoTarifa,
					idGerenciaRegional, idLocalidadeInicial, idLocalidadeFinal,
					setorComercialInicial, setorComercialFinal, quadraInicial,
					quadraFinal, loteOrigem, loteDestno, cep, logradouro,
					bairro, municipio, idTipoMedicao, indicadorMedicao,
					idSubCategoria, idCategoria, quantidadeEconomiasInicial,
					quantidadeEconomiasFinal, diaVencimento, idCliente,
					idClienteTipo, idClienteRelacaoTipo, numeroPontosInicial,
					numeroPontosFinal, numeroMoradoresInicial,
					numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condi??o do where
	 * 
	 * [UC0227] Gerar Rela??o de D?bitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterio(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String indicadorCpfCnpj, String cpfCnpj) {

		String consulta = "";
		/*
		 * ## CONDI??ES ##
		 */
		consulta = consulta + " where 1=1 ";

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and cliente.id = :idCliente  ";
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and clienteTipo.id = :idClienteTipo ";
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and clienteRelacaoTipo.id = :idClienteRelacaoTipo ";
		}

		if (indicadorCpfCnpj != null && indicadorCpfCnpj.equals("2")) {
			consulta = consulta
					+ " and cliente.cpf is null and cliente.cnpj is null ";

		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			consulta = consulta
					+ " and (cliente.cpf = :cpfCnpj or cliente.cnpj = :cpfCnpj) ";

			if (idClienteRelacaoTipo != null
					&& idClienteRelacaoTipo.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				consulta = consulta + " and clienteRelacaoTipo.id = "
						+ ClienteRelacaoTipo.USUARIO + " ";
			}

		}

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and gerenciaRegional.id = :idGerenciaRegional ";
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			consulta = consulta
					+ " and localidade.id >= :idLocalidadeInicial and localidade.id <= :idLocalidadeFinal ";
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			consulta = consulta
					+ " and setorComercial.codigo >= :setorComercialInicial and setorComercial.codigo <= :setorComercialFinal ";
		}
		// quadra
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and quadra.numeroQuadra >= :quadraInicial and quadra.numeroQuadra <= :quadraFinal ";
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.lote >= :loteOrigem  and  imovel.lote <= :loteDestino ";
		}

		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and cep.codigo = :cep  ";
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and logradouro.id = :logradouro  ";
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and bairro.codigo = :bairro  ";
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and municipio.id = :municipio  ";
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and ligacaoAgua.numeroConsumoMinimoAgua >= :consumoMinimoInicialAgua and ligacaoAgua.numeroConsumoMinimoAgua <= :consumoMinimoFinalAgua  ";
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and ligacaoEsgoto.consumoMinimo >= :consumoMinimoInicialEsgoto and ligacaoEsgoto.consumoMinimo <= :consumoMinimoFinalEsgoto ";
		}

		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {

			consulta = consulta
					+ " and ligacaoEsgoto.percentual >= :intervaloValorPercentualEsgotoInicial and ligacaoEsgoto.percentual <= :intervaloValorPercentualEsgotoFinal  ";
		}
		// indicador medi??o
		if (indicadorMedicao != null && indicadorMedicao.equals("comMedicao")) {
			// tipo medicao
			if (idTipoMedicao != null
					&& idTipoMedicao
							.equals(MedicaoTipo.LIGACAO_AGUA.toString())) {
				consulta = consulta
						+ " and hidrometroInstalacaoHistorico.id is not null ";
			} else if (idTipoMedicao != null
					&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
				consulta = consulta
						+ " and hidrometroInstalacaoHistoricoImovel.id is not null ";
			} else {
				consulta = consulta
						+ " and (hidrometroInstalacaoHistorico.id is not null or ";
				consulta = consulta
						+ "hidrometroInstalacaoHistoricoImovel.id is not null)  ";
			}
		} else if (indicadorMedicao != null
				&& indicadorMedicao.equals("semMedicao")) {
			consulta = consulta
					+ " and (hidrometroInstalacaoHistorico.id is null and ";
			consulta = consulta
					+ "hidrometroInstalacaoHistoricoImovel.id is null) ";
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and imovelCondominio.id = :idImovelCondominio  ";
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and imovelPrincipal.id = :idImovelPrincipal  ";
		}
		// nome conta

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// consulta = consulta + " nomeConta.id = :idNomeConta and ";
		// }

		// situa??o da liga??o de agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua  ";
		}
		// situa??o liga??o de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and ligacaoEsgotoSituacao.id = :idSituacaoLigacaoEsgoto  ";
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and imovelPerfil.id = :idImovelPerfil  ";
		}
		// po?o tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and pocoTipo.id = :idPocoTipo ";
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and faturamentoTipo.id = idFaturamentoSituacaoTipo ";
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					// +
					// " and cobrancaSituacaoTipo.id = :idCobrancaSituacaoTipo ";
					+ " and imovelCobrancaSituacao.imovel.id = imovel.id and imovelCobrancaSituacao.cobrancaSituacao.id = :idCobrancaSituacaoTipo "
					+ " and imovelCobrancaSituacao.anoMesReferenciaFinal is null ";
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and faturamentoSituacaoTipo.id = :idSituacaoEspecialCobranca ";
		}

		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and eloAnormalidade.id = :idEloAnormalidade ";
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idCadastroOcorrencia.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and cadastroOcorrencia.id = :idCadastroOcorrencia ";
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.areaConstruida >= :areaConstruidaInicial and imovel.areaConstruida <= :areaConstruidaFinal  ";
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and consumoTarifa.id = :idConsumoTarifa ";
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and consumosHistorico.consumoMedio >= :intervaloMediaMinimaImovelInicial and consumosHistorico.consumoMedio <= :intervaloMediaMinimaImovelFinal ";
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and medicaoHistorico.consumoMedioHidrometro >= :intervaloMediaMinimaHidrometroInicial and medicaoHistorico.consumoMedioHidrometro <= :intervaloMediaMinimaHidrometroFinal  ";
		}
		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and categoria.id = :idCategoria  ";
		}
		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta + " and subCategoria.id = :idSubCategoria  ";
		}
		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovelSubcategoria.quantidadeEconomias >= :quantidadeEconomiasInicial and imovelSubcategoria.quantidadeEconomias <= :quantidadeEconomiasFinal ";
		}

		// dia Vencimento
		if (diaVencimento != null
				&& !diaVencimento.equals("")
				&& !diaVencimento.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			if (diaVencimento.equals("1")) {// sim
				consulta = consulta
						+ " and imovel.diaVencimento  is not null  ";
			}
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imove.numeroPontosUtilizacao >= :numeroPontosInicial and imovel.numeroPontosUtilizacao <= :numeroPontosFinal ";
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			consulta = consulta
					+ " and imovel.numeroMorador >= :numeroMoradoresInicial and imovel.numeroMorador <= :numeroMoradoresFinal ";
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			consulta = consulta
					+ " and areaConstruidaFaixa.id = :idAreaConstruidaFaixa ";
		}

		return consulta;
	}

	/**
	 * 
	 * Seta os valores na condi??o do where
	 * 
	 * [UC0227] Gerar Rela??o de D?bitos
	 * 
	 * @author Rafael Santos
	 * @param cpfCnpj
	 * @param indicadorCpfCnpj
	 * @date 12/06/2006
	 * 
	 */
	public void informarDadosQueryFiltrarImovelOutrosCriterio(Query query,
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa,
			String indicadorCpfCnpj, String cpfCnpj) {

		// gerencia regional
		if (idGerenciaRegional != null
				&& !idGerenciaRegional.equals("")
				&& !idGerenciaRegional.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idGerenciaRegional", new Integer(
					idGerenciaRegional).intValue());
		}
		// localidade inicial e final
		if (((idLocalidadeInicial != null && !idLocalidadeInicial.equals("") && !idLocalidadeInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (idLocalidadeFinal != null
				&& !idLocalidadeFinal.equals("") && !idLocalidadeFinal.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			query.setInteger("idLocalidadeInicial", new Integer(
					idLocalidadeInicial).intValue());
			query.setInteger("idLocalidadeFinal",
					new Integer(idLocalidadeFinal).intValue());
		}
		// setor comercial inicial e final
		if (((setorComercialInicial != null
				&& !setorComercialInicial.equals("") && !setorComercialInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) && (setorComercialFinal != null
				&& !setorComercialFinal.equals("") && !setorComercialFinal
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())))) {
			query.setInteger("setorComercialInicial", new Integer(
					setorComercialInicial).intValue());
			query.setInteger("setorComercialFinal", new Integer(
					setorComercialFinal).intValue());
		}
		// quadra inicial e final
		if ((quadraInicial != null && !quadraInicial.equals("") && !quadraInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quadraFinal != null && !quadraFinal.equals("") && !quadraFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("quadraInicial",
					new Integer(quadraInicial).intValue());
			query.setInteger("quadraFinal", new Integer(quadraFinal).intValue());
		}
		// lote
		if ((loteOrigem != null && !loteOrigem.equals("") && !loteOrigem.trim()
				.equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (loteDestno != null && !loteDestno.equals("") && !loteDestno
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("loteOrigem", new Integer(loteOrigem).intValue());
			query.setInteger("loteDestino", new Integer(loteDestno).intValue());
		}
		// cep
		if (cep != null
				&& !cep.equals("")
				&& !cep.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("cep", new Integer(cep).intValue());
		}
		// logradouro
		if (logradouro != null
				&& !logradouro.equals("")
				&& !logradouro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("logradouro", new Integer(logradouro).intValue());
		}
		// bairro
		if (bairro != null
				&& !bairro.equals("")
				&& !bairro.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("bairro", new Integer(bairro).intValue());
		}
		// municipio
		if (municipio != null
				&& !municipio.equals("")
				&& !municipio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("municipio", new Integer(municipio).intValue());
		}
		// consumo minimo agua inicial e final
		if ((consumoMinimoInicialAgua != null
				&& !consumoMinimoInicialAgua.equals("") && !consumoMinimoInicialAgua
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalAgua != null
						&& !consumoMinimoFinalAgua.equals("") && !consumoMinimoFinalAgua
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialAgua", new Integer(
					consumoMinimoInicialAgua).intValue());
			query.setInteger("consumoMinimoFinalAgua", new Integer(
					consumoMinimoFinalAgua).intValue());
		}
		// consumo minimo esgoto inicial e final
		if ((consumoMinimoInicialEsgoto != null
				&& !consumoMinimoInicialEsgoto.equals("") && !consumoMinimoInicialEsgoto
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (consumoMinimoFinalEsgoto != null
						&& !consumoMinimoFinalEsgoto.equals("") && !consumoMinimoFinalEsgoto
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("consumoMinimoInicialEsgoto", new Integer(
					consumoMinimoInicialEsgoto).intValue());
			query.setInteger("consumoMinimoFinalEsgoto", new Integer(
					consumoMinimoFinalEsgoto).intValue());
		}
		// percentual esgoto inicial e final
		if ((intervaloValorPercentualEsgotoInicial != null
				&& !intervaloValorPercentualEsgotoInicial.equals("") && !intervaloValorPercentualEsgotoInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloValorPercentualEsgotoFinal != null
						&& !intervaloValorPercentualEsgotoFinal.equals("") && !intervaloValorPercentualEsgotoFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloValorPercentualEsgotoInicial",
					new BigDecimal(intervaloValorPercentualEsgotoInicial)
							.intValue());
			query.setInteger("intervaloValorPercentualEsgotoFinal",
					new BigDecimal(intervaloValorPercentualEsgotoFinal)
							.intValue());
		}
		// imovel condominio
		if (idImovelCondominio != null
				&& !idImovelCondominio.equals("")
				&& !idImovelCondominio.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelCondominio", new Integer(
					idImovelCondominio).intValue());
		}
		// imovel principal
		if (idImovelPrincipal != null
				&& !idImovelPrincipal.equals("")
				&& !idImovelPrincipal.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPrincipal",
					new Integer(idImovelPrincipal).intValue());
		}

		// nome conta
		// if (idNomeConta != null
		// && !idNomeConta.equals("")
		// && !idNomeConta.trim().equalsIgnoreCase(
		// new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
		// .toString())) {
		// query
		// .setInteger("idNomeConta", new Integer(idNomeConta)
		// .intValue());
		// }
		// Situacao Ligacao Agua
		if (idSituacaoLigacaoAgua != null
				&& !idSituacaoLigacaoAgua.equals("")
				&& !idSituacaoLigacaoAgua.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoAgua", new Integer(
					idSituacaoLigacaoAgua).intValue());
		}

		// situa??o liga??o de esgoto
		if (idSituacaoLigacaoEsgoto != null
				&& !idSituacaoLigacaoEsgoto.equals("")
				&& !idSituacaoLigacaoEsgoto.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoLigacaoEsgoto", new Integer(
					idSituacaoLigacaoEsgoto).intValue());
		}
		// imovel Perfil
		if (idImovelPerfil != null
				&& !idImovelPerfil.equals("")
				&& !idImovelPerfil.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idImovelPerfil",
					new Integer(idImovelPerfil).intValue());
		}
		// po?o tipo
		if (idPocoTipo != null
				&& !idPocoTipo.equals("")
				&& !idPocoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idPocoTipo", new Integer(idPocoTipo).intValue());
		}
		// faturamento situacao tipo
		if (idFaturamentoSituacaoTipo != null
				&& !idFaturamentoSituacaoTipo.equals("")
				&& !idFaturamentoSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idFaturamentoSituacaoTipo", new Integer(
					idFaturamentoSituacaoTipo).intValue());
		}
		// cobranca situacao tipo
		if (idCobrancaSituacaoTipo != null
				&& !idCobrancaSituacaoTipo.equals("")
				&& !idCobrancaSituacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCobrancaSituacaoTipo", new Integer(
					idCobrancaSituacaoTipo).intValue());
		}
		// Situacao Especial Cobranca
		if (idSituacaoEspecialCobranca != null
				&& !idSituacaoEspecialCobranca.equals("")
				&& !idSituacaoEspecialCobranca.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSituacaoEspecialCobranca", new Integer(
					idSituacaoEspecialCobranca).intValue());
		}
		// elo anormalidade
		if (idEloAnormalidade != null
				&& !idEloAnormalidade.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idEloAnormalidade",
					new Integer(idEloAnormalidade).intValue());
		}
		// cadastro ocorrencia
		if (idCadastroOcorrencia != null
				&& !idCadastroOcorrencia.equals("")
				&& !idEloAnormalidade.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCadastroOcorrencia", new Integer(
					idCadastroOcorrencia).intValue());
		}
		// area construida inicial e final
		if ((areaConstruidaInicial != null && !areaConstruidaInicial.equals("") && !areaConstruidaInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (areaConstruidaFinal != null
						&& !areaConstruidaFinal.equals("") && !areaConstruidaFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setBigDecimal("areaConstruidaInicial",
					Util.formatarMoedaRealparaBigDecimal(areaConstruidaInicial));
			query.setBigDecimal("areaConstruidaFinal",
					Util.formatarMoedaRealparaBigDecimal(areaConstruidaFinal));
		}
		// consumo tarifa
		if (idConsumoTarifa != null
				&& !idConsumoTarifa.equals("")
				&& !idConsumoTarifa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idConsumoTarifa",
					new Integer(idConsumoTarifa).intValue());
		}
		// intervalo Media Minima Imovel Inicial e Final
		if ((intervaloMediaMinimaImovelInicial != null
				&& !intervaloMediaMinimaImovelInicial.equals("") && !intervaloMediaMinimaImovelInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaImovelFinal != null
						&& !intervaloMediaMinimaImovelFinal.equals("") && !intervaloMediaMinimaImovelFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaImovelInicial", new Integer(
					intervaloMediaMinimaImovelInicial).intValue());
			query.setInteger("intervaloMediaMinimaImovelFinal", new Integer(
					intervaloMediaMinimaImovelFinal).intValue());
		}
		// intervalo MediaMinima Hidrometro Inicial e Final
		if ((intervaloMediaMinimaHidrometroInicial != null
				&& !intervaloMediaMinimaHidrometroInicial.equals("") && !intervaloMediaMinimaHidrometroInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (intervaloMediaMinimaHidrometroFinal != null
						&& !intervaloMediaMinimaHidrometroFinal.equals("") && !intervaloMediaMinimaHidrometroFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setInteger("intervaloMediaMinimaHidrometroInicial",
					new Integer(intervaloMediaMinimaHidrometroInicial)
							.intValue());
			query.setInteger("intervaloMediaMinimaHidrometroFinal",
					new Integer(intervaloMediaMinimaHidrometroFinal).intValue());
		}

		// quantidade economias inicial e final
		if ((quantidadeEconomiasInicial != null
				&& !quantidadeEconomiasInicial.equals("") && !quantidadeEconomiasInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (quantidadeEconomiasFinal != null
						&& !quantidadeEconomiasFinal.equals("") && !quantidadeEconomiasFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("quantidadeEconomiasInicial", new Short(
					quantidadeEconomiasInicial).shortValue());
			query.setShort("quantidadeEconomiasFinal", new Short(
					quantidadeEconomiasFinal).shortValue());
		}

		// categoria
		if (idCategoria != null
				&& !idCategoria.equals("")
				&& !idCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCategoria", new Integer(idCategoria).intValue());
		}

		// sub categoria
		if (idSubCategoria != null
				&& !idSubCategoria.equals("")
				&& !idSubCategoria.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idSubCategoria",
					new Integer(idSubCategoria).intValue());
		}

		// numero prontos inicial e final
		if ((numeroPontosInicial != null && !numeroPontosInicial.equals("") && !numeroPontosInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroPontosFinal != null && !numeroPontosFinal.equals("") && !numeroPontosFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroPontosInicial",
					new Short(numeroPontosInicial).shortValue());
			query.setShort("numeroPontosFinal",
					new Short(numeroPontosFinal).shortValue());
		}

		// numero moradores inicial e final
		if ((numeroMoradoresInicial != null
				&& !numeroMoradoresInicial.equals("") && !numeroMoradoresInicial
				.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString()))
				&& (numeroMoradoresFinal != null
						&& !numeroMoradoresFinal.equals("") && !numeroMoradoresFinal
						.trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString()))) {
			query.setShort("numeroMoradoresInicial", new Short(
					numeroMoradoresInicial).shortValue());
			query.setShort("numeroMoradoresFinal", new Short(
					numeroMoradoresFinal).shortValue());
		}
		// area construida faixa
		if (idAreaConstruidaFaixa != null
				&& !idAreaConstruidaFaixa.equals("")
				&& !idAreaConstruidaFaixa.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idAreaConstruidaFaixa", new Integer(
					idAreaConstruidaFaixa).intValue());
		}

		// cliente
		if (idCliente != null
				&& !idCliente.equals("")
				&& !idCliente.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idCliente", new Integer(idCliente).intValue());
		}

		// cliente tipo
		if (idClienteTipo != null
				&& !idClienteTipo.equals("")
				&& !idClienteTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteTipo",
					new Integer(idClienteTipo).intValue());
		}

		// cliente relacao tipo
		if (idClienteRelacaoTipo != null
				&& !idClienteRelacaoTipo.equals("")
				&& !idClienteRelacaoTipo.trim().equalsIgnoreCase(
						new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
								.toString())) {
			query.setInteger("idClienteRelacaoTipo", new Integer(
					idClienteRelacaoTipo).intValue());
		}

		if (cpfCnpj != null && !cpfCnpj.equals("")) {
			query.setString("cpfCnpj", cpfCnpj);
		}
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional "
					+ "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro "
					+ "LEFT JOIN fetch hih.hidrometroLocalInstalacao "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			consulta = consulta
					+ " AND cbdo.emissao >= :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corr?a
	 * @data 02/09/2009
	 * 
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaRelatorio(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra "
					+ "INNER JOIN FETCH imov.localidade loca "
					+ "INNER JOIN FETCH loca.localidade locaElo "
					+ "INNER JOIN FETCH qdra.rota rota "
					+ "INNER JOIN FETCH rota.cobrancaGrupo "
					+ "INNER JOIN FETCH rota.faturamentoGrupo "
					+ "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao "
					+ "INNER JOIN FETCH cbdo.cobrancaAcao "
					+ " LEFT JOIN FETCH imov.ligacaoAgua ligacaoAgua "
					+ " LEFT JOIN FETCH ligacaoAgua.hidrometroInstalacaoHistorico hidrHistorico "
					+ " LEFT JOIN FETCH hidrHistorico.hidrometro hidrometro "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			// RM 930 - Todos os relat?rios de campo da CAERN s?o classificados
			// por localidade, setor e rota
			String empresa = RepositorioUtilHBM.getInstancia()
					.pesquisarParametrosDoSistema().getNomeAbreviadoEmpresa();

			if (empresa.equals("CAERN")) {
				consulta = consulta
						+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, rota.codigo, "
						+ "imov.numeroSequencialRota, cbdo.id";
			} else {
				consulta = consulta
						+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
						+ "imov.lote, imov.subLote, cbdo.id";
			}

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 27/06/2007
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirPorRota(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch imov.perimetroInicial periInicial "
					+ "LEFT JOIN fetch periInicial.logradouroTipo "
					+ "LEFT JOIN fetch periInicial.logradouroTitulo "
					+ "LEFT JOIN fetch imov.perimetroFinal periFinal "
					+ "LEFT JOIN fetch periFinal.logradouroTipo "
					+ "LEFT JOIN fetch periFinal.logradouroTitulo "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional " + "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rot.codigo, "
					+ "imov.numeroSequencialRota, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * Seleciona os itens do documento de cobran?a correspondentes a conta e
	 * ordenar por ano/m?s de refer?ncia da conta
	 * 
	 * @author Raphael Rossiter
	 * @data 26/05/2006
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteConta(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.contaGeral cntaGeral "
					+ "LEFT JOIN fetch cntaGeral.conta  cnta "
					+ "LEFT JOIN fetch cnta.debitoCreditoSituacaoAtual "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "cnta.id IS NOT NULL ORDER BY cdit.contaGeral.conta.referencia";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXX] Emitir Aviso de Cobran?a
	 * 
	 * Seleciona os itens do documento de cobran?a correspondentes a guia
	 * pagamento
	 * 
	 * @author S?vio Luiz
	 * @data 09/04/2007
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<Object[]> selecionarDadosCobrancaDocumentoItemReferenteGuiaPagamento(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit.valorItemCobrado,cdit.valorAcrescimos "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN cdit.guiaPagamentoGeral guia "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "guia.id IS NOT NULL ";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o count do resultado da pesquisa de Cobranca Cronograma
	 * 
	 * pesquisarCobrancaCronogramaCount
	 * 
	 * @author Fl?vio Cordeiro
	 * @date 14/06/2006
	 * 
	 * @return Integer retorno
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarCobrancaCronogramaCount(Filtro filtro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		// String consulta = null;

		try {
			filtro.limparCamposOrderBy();
			// filtro.adicionarCaminhoParaCarregamentoEntidade("cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes");
			retorno = (Integer) GeradorHQLCondicional
					.gerarCondicionalQuery(
							filtro,
							"objeto",
							"select count(distinct objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id) "
									+ "	from gcom.cobranca.CobrancaAcaoAtividadeCronograma objeto ",
							session).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public void removerCobrancaCronograma(Integer idGrupoCronogramaMes)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String remover = null;
		try {
			remover = "delete CobrancaAcaoAtividadeCronograma objeto"
					+ "	where objeto.cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id ="
					+ idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();

			remover = "delete CobrancaAcaoCronograma objeto "
					+ "	where objeto.cobrancaGrupoCronogramaMes.id = "
					+ idGrupoCronogramaMes;

			session.createQuery(remover).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * Consultar Rela??o de Debitos do Imovel Consulta o Consumo Medio do Imovel
	 * 
	 * [UC0227] - Gerar Rel??o de D?bitos
	 * 
	 * @author Rafael Santos
	 * @date 15/06/2006
	 * 
	 * @param imovelId
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarConsumoMedioConsumoHistoricoImovel(Integer imovelId)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select consumoHistorico.consumoMedio "
					+ "from ConsumoHistorico consumoHistorico "
					+ "inner join consumoHistorico.imovel imovel "
					+ "inner join consumoHistorico.ligacaoTipo   ligacaoTipo "
					+ "where imovel.id = :imovelId "
					+ "and ligacaoTipo.id = :ligacaoTipo and consumoHistorico.referenciaFaturamento = ( "
					+ "select max(consumoHistorico2.referenciaFaturamento) "
					+ "from ConsumoHistorico consumoHistorico2 "
					+ "inner join consumoHistorico2.imovel imovel2 "
					+ "inner join consumoHistorico2.ligacaoTipo ligacaoTipo2 "
					+ "where imovel2.id = :imovelId and ligacaoTipo2.id = :ligacaoTipo) ";

			Object resultado = session
					.createQuery(consulta)
					.setInteger("imovelId", imovelId.intValue())
					.setInteger("ligacaoTipo",
							LigacaoTipo.LIGACAO_AGUA.intValue()).uniqueResult();

			if (resultado != null) {
				retorno = (Integer) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Monta a condi??o do where
	 * 
	 * [UC0227] Gerar Rela??o de D?bitos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/2006
	 * 
	 */
	public String montarCondicaoWhereFiltrarImovelOutrosCriterioContarQuantidade(
			String idImovelCondominio, String idImovelPrincipal,
			String idNomeConta, String idSituacaoLigacaoAgua,
			String consumoMinimoInicialAgua, String consumoMinimoFinalAgua,
			String idSituacaoLigacaoEsgoto, String consumoMinimoInicialEsgoto,
			String consumoMinimoFinalEsgoto,
			String intervaloValorPercentualEsgotoInicial,
			String intervaloValorPercentualEsgotoFinal,
			String intervaloMediaMinimaImovelInicial,
			String intervaloMediaMinimaImovelFinal,
			String intervaloMediaMinimaHidrometroInicial,
			String intervaloMediaMinimaHidrometroFinal, String idImovelPerfil,
			String idPocoTipo, String idFaturamentoSituacaoTipo,
			String idCobrancaSituacaoTipo, String idSituacaoEspecialCobranca,
			String idEloAnormalidade, String areaConstruidaInicial,
			String areaConstruidaFinal, String idCadastroOcorrencia,
			String idConsumoTarifa, String idGerenciaRegional,
			String idLocalidadeInicial, String idLocalidadeFinal,
			String setorComercialInicial, String setorComercialFinal,
			String quadraInicial, String quadraFinal, String loteOrigem,
			String loteDestno, String cep, String logradouro, String bairro,
			String municipio, String idTipoMedicao, String indicadorMedicao,
			String idSubCategoria, String idCategoria,
			String quantidadeEconomiasInicial, String quantidadeEconomiasFinal,
			String diaVencimento, String idCliente, String idClienteTipo,
			String idClienteRelacaoTipo, String numeroPontosInicial,
			String numeroPontosFinal, String numeroMoradoresInicial,
			String numeroMoradoresFinal, String idAreaConstruidaFaixa) {

		String consulta = "";
		consulta = consulta
				+ montarCondicaoWhereFiltrarImovelOutrosCriterio(
						idImovelCondominio, idImovelPrincipal, idNomeConta,
						idSituacaoLigacaoAgua, consumoMinimoInicialAgua,
						consumoMinimoFinalAgua, idSituacaoLigacaoEsgoto,
						consumoMinimoInicialEsgoto, consumoMinimoFinalEsgoto,
						intervaloValorPercentualEsgotoInicial,
						intervaloValorPercentualEsgotoFinal,
						intervaloMediaMinimaImovelInicial,
						intervaloMediaMinimaImovelFinal,
						intervaloMediaMinimaHidrometroInicial,
						intervaloMediaMinimaHidrometroFinal, idImovelPerfil,
						idPocoTipo, idFaturamentoSituacaoTipo,
						idCobrancaSituacaoTipo, idSituacaoEspecialCobranca,
						idEloAnormalidade, areaConstruidaInicial,
						areaConstruidaFinal, idCadastroOcorrencia,
						idConsumoTarifa, idGerenciaRegional,
						idLocalidadeInicial, idLocalidadeFinal,
						setorComercialInicial, setorComercialFinal,
						quadraInicial, quadraFinal, loteOrigem, loteDestno,
						cep, logradouro, bairro, municipio, idTipoMedicao,
						indicadorMedicao, idSubCategoria, idCategoria,
						quantidadeEconomiasInicial, quantidadeEconomiasFinal,
						diaVencimento, idCliente, idClienteTipo,
						idClienteRelacaoTipo, numeroPontosInicial,
						numeroPontosFinal, numeroMoradoresInicial,
						numeroMoradoresFinal, idAreaConstruidaFaixa, null, null);

		consulta = consulta.substring(0, (consulta.length() - 5));

		consulta = consulta + " ";

		return consulta;
	}

	/**
	 * Gerar Relat?rio de Crit?rio de Cobran?a
	 * 
	 * Pesquisa as linhas de crit?rio de cobran?a atrav?s do id do crit?rio de
	 * cobran?a
	 * 
	 * @author Rafael Corr?a
	 * @data 09/08/2006
	 */
	public Collection pesquisarCobrancaCriterioLinha(Integer idCriterioCobranca)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT " + "imovelPerfil.descricao, "
					+ "categoria.descricao, " + "ccl.valorMinimoDebito, "
					+ "ccl.valorMaximoDebito, "
					+ "ccl.quantidadeMinimaContas, "
					+ "ccl.quantidadeMaximaContas, "
					+ "ccl.valorMinimoContaMes, "
					+ "ccl.valorMinimoDebitoDebitoAutomatico, "
					+ "ccl.quantidadeMinimaContasDebitoAutomatico "
					+ "FROM CobrancaCriterioLinha as ccl "
					+ "inner join ccl.imovelPerfil imovelPerfil "
					+ "inner join ccl.categoria categoria "
					+ "WHERE ccl.cobrancaCriterio.id = :idCriterioCobranca "
					+ "order by imovelPerfil.id, categoria.id";

			retorno = session.createQuery(consulta)
					.setInteger("idCriterioCobranca", idCriterioCobranca)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relat?rio de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Antiguidade atrav?s do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corr?a
	 * @data 22/08/2006
	 */
	public Collection pesquisarParcelamentoDescontoAntiguidade(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT antiguidade.id, "
					+ "antiguidade.quantidadeMinimaMesesDebito, "
					+ "antiguidade.percentualDescontoSemRestabelecimento, "
					+ "antiguidade.percentualDescontoComRestabelecimento, "
					+ "antiguidade.percentualDescontoAtivo "
					+ "FROM ParcelamentoDescontoAntiguidade as antiguidade "
					+ "INNER JOIN antiguidade.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY antiguidade.quantidadeMinimaMesesDebito";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relat?rio de Perfil de Parcelamento
	 * 
	 * Pesquisa os Parcelamentos Desconto Inatividade atrav?s do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corr?a
	 * @data 22/08/2006
	 */
	public Collection pesquisarParcelamentoDescontoInatividade(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "SELECT inatividade.id, "
					+ "inatividade.quantidadeMaximaMesesInatividade, "
					+ "inatividade.percentualDescontoSemRestabelecimento, "
					+ "inatividade.percentualDescontoComRestabelecimento "
					+ "FROM ParcelamentoDescontoInatividade as inatividade "
					+ "INNER JOIN inatividade.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ " ORDER BY inatividade.quantidadeMaximaMesesInatividade";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relat?rio de Perfil de Parcelamento
	 * 
	 * Pesquisa os Reparcelamentos Consecutivos atrav?s do id de Perfil de
	 * Parcelamento
	 * 
	 * @author Rafael Corr?a
	 * @data 22/08/2006
	 */
	public Collection pesquisarReparcelamentoConsecutivo(
			Integer idParcelamentoPerfil) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT reparcelamento.id, "
					+ "reparcelamento.quantidadeMaximaReparcelamento, "
					+ "prestacao.id, prestacao.quantidadeMaximaPrestacao, "
					+ "prestacao.taxaJuros, prestacao.percentualMinimoEntrada "
					+ "FROM ParcelamentoQuantidadePrestacao as prestacao "
					+ "INNER JOIN prestacao.parcelamentoQuantidadeReparcelamento reparcelamento "
					+ "INNER JOIN reparcelamento.parcelamentoPerfil perfil "
					+ "WHERE perfil.id = :idParcelamentoPerfil "
					+ "ORDER BY reparcelamento.quantidadeMaximaReparcelamento, "
					+ "prestacao.quantidadeMaximaPrestacao";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamentoPerfil", idParcelamentoPerfil)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobran?a previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobran?a do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobran?a Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarCobrancaAcaoAtividadeCronogramaComandadosNaoRealizados(
			Date dataPesquisaComando) throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeCronograma> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;
		Query query = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeCronograma as cob "
					+ " left join fetch cob.cobrancaAcaoCronograma cobAcaoCron "
					+ " left join fetch cobAcaoCron.cobrancaGrupoCronogramaMes cobGrupoCronoMes"
					+ " left join fetch cobAcaoCron.cobrancaAcao cobAcao"
					+ " left join fetch cob.cobrancaAtividade cobAtiv"
					+ " left join fetch cobGrupoCronoMes.cobrancaGrupo cobGrup"
					+ " WHERE ( cob.comando is not null ";

			if (dataPesquisaComando != null) {
				consulta += " and cob.comando>=:dataPesquisa ";
			}

			consulta += " ) and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null and cob.dataPrevista <=  :dataAtual) "
					+ " order by cobGrupoCronoMes.anoMesReferencia, cobGrupoCronoMes.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or
			// cob.realizacao
			// <
			// cob.comando
			// cobAtiv.id = :cobrancaAtividade and
			// 'A
			// pedido
			// de
			// Ana
			// Breda'

			query = session.createQuery(consulta);

			if (dataPesquisaComando != null) {
				query.setDate("dataPesquisa", dataPesquisaComando);
			}

			retorno = query
					.setInteger("cobrancaAtividadeEmitir",
							CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular",
							CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS",
							CobrancaAtividade.ENCERRAR_OS)
					.setTimestamp("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite iniciar processos batch de faturamento ou
	 * cobran?a previdamento comandados e processos mensais ou eventuais
	 * 
	 * [UC0001] - Iniciar Processo
	 * 
	 * Este subfluxo inicia os processo batch de cobran?a do sistema
	 * 
	 * [SB0002] - Iniciar Process de Cobran?a Comandado
	 * 
	 * @author Rodrigo Silveira
	 * @date 17/08/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeCronogramaEventuaisComandadosNaoRealizados(
			Date dataPesquisaComando) throws ErroRepositorioException {

		Collection<CobrancaAcaoAtividadeComando> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;
		Query query = null;

		try {
			consulta = "FROM CobrancaAcaoAtividadeComando as cob "
					+ "left join fetch cob.cobrancaAtividade cobAtiv "

					+ "left join fetch cob.cobrancaAcao cobAcao "
					+ "left join fetch cob.usuario "
					+ "WHERE (cob.comando is not null ";

			if (dataPesquisaComando != null) {
				consulta += " and cob.comando>=:dataPesquisa ";
			}

			consulta += ")and (cobAtiv.id = :cobrancaAtividadeEmitir or cobAtiv.id = :cobrancaAtividadeSimular or cobAtiv.id = :cobrancaAtividadeEncerrarOS) and (cob.realizacao is null ) "
					+ " ORDER BY cob.comando";
			// + " order by cob.anoMesReferenciaContaInicial,
			// cob.cobrancaGrupo.descricao, cobAcao.ordemRealizacao"; // or;*/
			// //
			// or
			// cob.realizacao
			// <
			// cob.comando

			query = session.createQuery(consulta);

			if (dataPesquisaComando != null) {
				query.setDate("dataPesquisa", dataPesquisaComando);
			}

			retorno = query
					.setInteger("cobrancaAtividadeEmitir",
							CobrancaAtividade.EMITIR)
					.setInteger("cobrancaAtividadeSimular",
							CobrancaAtividade.SIMULAR)
					.setInteger("cobrancaAtividadeEncerrarOS",
							CobrancaAtividade.ENCERRAR_OS).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Ana Maria
	 * @data 07/09/2006
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCorte(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaHelper.class.getName()
					+ " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra,"
					+ " imov.lote, imov.subLote,"
					+ " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id,"
					+ " iper.descricao, cbdo.emissao,"
					+ " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao,"
					+ " greg.nomeAbreviado, greg.nome,"
					+ " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao,"
					+ " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, cbdo.dataEmissaoPredecessor,"
					+ " cbdo.numeroSequenciaDocumento, cbac.numeroDiasVencimento,"
					+ " rota.codigo, imov.numeroSequencialRota)"
					+ " from OrdemServico orse "
					+ " left join orse.cobrancaDocumento as cbdo "
					+ " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca"
					+ " left join cbdo.imovel as imov"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.imovelPerfil as iper"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota"
					+ " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					// + " AND cbdo.emissao = :dataEmissao "
					+ " AND cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					// .setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0476] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), rota (ROTA_ID), sequencial da rota
	 * (IMOV_NNSEQUENCIALROTA)e cobranca documento (CBDO_ID)
	 * 
	 * @author Raphael Rossiter
	 * @data 07/08/2007
	 * 
	 * @return Collection<EmitirDocumentoCobrancaHelper>
	 */
	public Collection<EmitirDocumentoCobrancaHelper> pesquisarCobrancaDocumentoOrdemCortePorRota(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaHelper.class.getName()
					+ " (cbdo.id, loca.id, loca.descricao, "
					+ " cbdo.codigoSetorComercial,cbdo.numeroQuadra,"
					+ " imov.lote, imov.subLote,"
					+ " imov.id, cbac.numeroDiasValidade,"
					+ " orse.id,"
					+ " iper.descricao, cbdo.emissao,"
					+ " rota.cobrancaGrupo.id, cbdo.valorDocumento,"
					+ " empr.id, empr.descricao,"
					+ " greg.nomeAbreviado, greg.nome,"
					+ " last.id, lest.id,"
					+ " greg.id, imov.ultimaAlteracao,"
					+ " last.descricao, lest.descricao,"
					+ " ltan.id, ltan.descricao, rota.codigo, imov.numeroSequencialRota)"
					+ " from OrdemServico orse "
					+ " left join orse.cobrancaDocumento as cbdo "
					+ " left join cbdo.empresa as empr"
					+ " left join cbdo.localidade as loca"
					+ " left join cbdo.imovel as imov"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.imovelPerfil as iper"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota"
					+ " left join loca.gerenciaRegional greg" + " where ";
			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ "cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, rota.codigo, "
					+ "imov.numeroSequencialRota, cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					.setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(1000).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0582] Emitir Boletim de Cadastro
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Rafael Corr?a
	 * @data 16/05/2007
	 * 
	 * @param Collection
	 *            <CobrancaDocumento>
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<EmitirDocumentoCobrancaBoletimCadastroHelper> pesquisarCobrancaDocumentoBoletimCadastro(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select " + " new "
					+ EmitirDocumentoCobrancaBoletimCadastroHelper.class
							.getName()
					+ " (cbdo.id, loca.id, " // 0, 1
					+ " cbdo.codigoSetorComercial, cbdo.numeroQuadra," // 2, 3
					+ " imov.lote, imov.subLote," // 4, 5
					+ " imov.id, rota.cobrancaGrupo.id, " // 6, 7
					+ " last.id, lest.id," // 8, 9
					+ " imov.numeroMorador, imov.areaConstruida, logr.id, " // 10,11,12
					+ " cep.codigo, bairro.codigo, imov.enderecoReferencia.id, imov.numeroImovel, " // 13,14
																									// ,15,16
					+ " imov.complementoEndereco, imov.reservatorioVolumeFaixaInferior.id, " // 17,18
					+ " imov.reservatorioVolumeFaixaSuperior.id, imov.piscinaVolumeFaixa.id, " // 19,20
					+ " imov.indicadorJardim, imov.pavimentoRua.id, imov.pavimentoCalcada.id, " // 21,22,23
					+ " imov.numeroPontosUtilizacao, imov.imovelPerfil.id, imov.despejo.id, " // 24,25,26
					+ " imov.pocoTipo.id, imov.fonteAbastecimento.id, imov.numeroIptu, imov.numeroCelpe,"// 27,28,29,30
					+ " rota.codigo,imov.numeroSequencialRota)" // 31,32
					+ " from OrdemServico orse "
					+ " inner join orse.cobrancaDocumento as cbdo "
					+ " inner join cbdo.localidade as loca"
					+ " inner join cbdo.imovel as imov"
					+ " inner join imov.quadra qdrImovel "
					+ " inner join qdrImovel.rota rota "
					+ " inner join rota.empresaCobranca empreCobranca "
					+ " inner join cbdo.imovelPerfil as iper"
					+ " inner join loca.gerenciaRegional greg"
					+ " left join cbdo.empresa as empr"
					+ " left join imov.ligacaoAguaSituacao last"
					+ " left join imov.ligacaoEsgotoSituacao lest"
					+ " left join imov.leituraAnormalidade ltan"
					+ " left join imov.logradouroCep as logrCep"
					+ " left join logrCep.logradouro as logr"
					+ " left join logrCep.cep as cep"
					+ " left join imov.logradouroBairro as logrBairro"
					+ " left join logrBairro.bairro as bairro"
					+ " left join cbdo.cobrancaAcao as cbac"
					+ " left join cbdo.quadra as qdra"
					+ " left join qdra.rota as rota" + " where ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {

				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma
						+ " AND empreCobranca.indicadorEmpresaPrincipal <> "
						+ Empresa.INDICADOR_EMPRESA_PRINCIPAL + " AND ";
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta
						+ " cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando + " AND ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idAvisoCorte "
					+ " order by empr.id,greg.id ,loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ " imov.lote, imov.subLote,cbdo.id";

			retorno = session.createQuery(consulta)
					.setInteger("idAvisoCorte", idCobrancaAcao)
					.setTimestamp("dataEmissao", dataEmissao)
					.setFirstResult(quantidadeCobrancaDocumentoInicio)
					.setMaxResults(500).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta os
	 * documentos de cobran?a do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarImovelDocumentosCobranca(Integer idImovel,
			Integer numeroPagina) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT distinct cobrancaAcao.descricaoCobrancaAcao, "
					+ // 0
					"cobrancaDocumento.emissao,"
					+ // 1
					"documentoEmissaoForma.descricaoDocumentoEmissaoForma,"
					+ // 2
					"documentoTipo.descricaoDocumentoTipo,"
					+ // 3
					"cobrancaDocumento.valorDocumento,"
					+ // 4
					"cobrancaDocumento.id, "
					+ // 5
					"cobrancaDocumento.usuario.nomeUsuario, "
					+ // 6
					"cobrancaDocumento.indicadorClienteImovel, "
					+ // 7
					"documentoTipo.id, "
					+ // 8
					"documentoEmissaoForma.id, "
					+ // 9
					"cobAcao.descricaoCobrancaAcao, "
					+ // 10
					"acaoCobranca.descricaoCobrancaAcao "
					+ // 11
					"FROM CobrancaDocumento as cobrancaDocumento "
					+ "left JOIN cobrancaDocumento.cobrancaAcao cobrancaAcao "
					+ "left JOIN cobrancaDocumento.documentoEmissaoForma documentoEmissaoForma "
					+ "left JOIN cobrancaDocumento.documentoTipo documentoTipo "
					+ "left JOIN cobrancaDocumento.usuario usuario "
					+ "left JOIN cobrancaDocumento.cobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando "
					+ "left JOIN cobrancaAcaoAtividadeComando.cobrancaAcao cobAcao "
					+ "left JOIN cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobrancaAcaoAtividadeCronograma "
					+ "left JOIN cobrancaAcaoAtividadeCronograma.cobrancaAcaoCronograma cobrancaAcaoCronograma "
					+ "left JOIN cobrancaAcaoCronograma.cobrancaAcao acaoCobranca "
					+ "where cobrancaDocumento.imovel.id = :idImovel ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de cobran?a do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosCobranca(Integer idImovel)
			throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumento.id) "
					+ // 0
					"FROM CobrancaDocumento as cobrancaDocumento "
					+ "where cobrancaDocumento.imovel.id = :idImovel and cobrancaDocumento.imovel.indicadorExclusao != 1 ";

			resultadoConsulta = session.createQuery(consulta)
					.setInteger("idImovel", idImovel.intValue()).uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Este caso de consulta os dados do imovel, esse metodo consulta a
	 * quantidade de documentos de itens de cobran?a do imovel
	 * 
	 * [UC0472] - Consultar Imovel
	 * 
	 * @author Rafael Santos
	 * @date 18/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer consultarQuantidadeImovelDocumentosItemCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {
		Integer retorno = null;
		Object resultadoConsulta = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT count(distinct cobrancaDocumentoItem.id) "
					+ // 0
					"FROM CobrancaDocumentoItem as cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			resultadoConsulta = session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							idCobrancaDocumento.intValue()).uniqueResult();

			if (resultadoConsulta != null) {
				retorno = (Integer) resultadoConsulta;
			} else {
				retorno = new Integer(0);
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa os dados do parcelamento necess?rios para o relat?rio atrav?s do
	 * id do parcelamento
	 * 
	 * @author Rafael Corr?a
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentoRelatorio(Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "select imov.id, "
					+ // 0
					"imov.logradouroBairro.bairro.municipio.nome, "
					+ // 1
					"parc.parcelamento,"
					+ // 2
					" parc.valorConta, "
					+ // 3
					"parc.valorServicosACobrar, "
					+ // 4
					"parc.valorAtualizacaoMonetaria, "
					+ // 5
					"parc.valorJurosMora, "
					+ // 6
					"parc.valorMulta, "
					+ // 7
					"parc.valorGuiaPapagamento, "
					+ // 8
					"parc.valorParcelamentosACobrar, "
					+ // 9
					"parc.valorDescontoAcrescimos, "
					+ // 10
					"parc.valorDescontoAntiguidade, "
					+ // 11
					"parc.valorDescontoInatividade, "
					+ // 12
					"parc.valorCreditoARealizar, "
					+ // 13
					"parc.valorDebitoAtualizado, "
					+ // 14
					"parc.valorEntrada, "
					+ // 15
					"parc.numeroPrestacoes, "
					+ // 16
					"parc.valorPrestacao, "
					+ // 17
					"parc.indicadorRestabelecimento, "
					+ // 18
					"parc.funcionario.id, "
					+ // 19
					"clie.nome, "
					+ // 20
					"clie.cpf, "
					+ // 21
					"clie.cnpj, "
					+ // 22
					"parc.taxaJuros, "
					+ // 23
					"parc.valorDescontoSancao, "
					+ // 24
					"parc.valorDescontoTarifaSocial, "
					+ // 25
					"func.id, "
					+ // 26
					"cliDir.nome, "
					+ // 27
					"cliDir.cpf, "
					+ // 28
					"prof.descricao, "
					+ // 29
					"ct.indicadorPessoaFisicaJuridica, "
					+ // 30
					"devedor.nome, "
					+ // 31
					"devedor.cnpj, "
					+ // 32
					"devedor.id, "
					+ // 33
					"usur.nomeUsuario, "
					+ // 34
					"parc.anoMesReferenciaFaturamento, "
					+ // 35
					"imov.logradouroBairro.bairro.nome, "
					+ // 36
					"imov.quadra.rota.codigo, "
					+ // 37
					"localidade.descricao, "
					+ // 38
					"setor.codigo, "
					+ // 39
					"parc.valorDescontoDebitoTotal " // 40
					+ "from Parcelamento parc "
					+ "left join parc.cliente clie "
					+ "left join clie.profissao prof "
					+ "left join parc.usuario usur "
					+ "left join usur.funcionario func "
					+ "inner join parc.imovel imov "
					+ "inner join imov.localidade localidade "
					+ "inner join imov.setorComercial setor "
					+ "left join imov.clienteImoveis ci with ( ci.clienteRelacaoTipo.id = 2 and ci.dataFimRelacao is null ) "
					+ "left join ci.cliente devedor " + "left join ci.cliente "
					+ "left join devedor.clienteTipo ct,"
					+ "SistemaParametro sp "
					+ "left join sp.clienteDiretorComercialCompesa cliDir "
					+ "where parc.id = :idParcelamento";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento.intValue())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa os itens do parcelamento necess?rios para o relat?rio atrav?s do
	 * id do parcelamento
	 * 
	 * @author Rafael Corr?a
	 * @date 25/09/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentoItemPorIdParcelamentoRelatorio(
			Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {

			consulta = "select "
					+
					// 0
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.referencia"
					+ " else"
					+ "   ch.anoMesReferenciaConta"
					+ " end,"
					+
					// 1
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorAgua"
					+ " else"
					+ "   ch.valorAgua"
					+ " end,"
					+
					// 2
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorEsgoto"
					+ " else"
					+ "   ch.valorEsgoto"
					+ " end,"
					+
					// 3
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.valorCreditos"
					+ " else"
					+ "   ch.valorCreditos"
					+ " end,"
					+
					// 4
					" case when ( cg.indicadorHistorico = 2 ) then "
					+ "   conta.debitos"
					+ " else"
					+ "   ch.valorDebitos"
					+ " end,"
					+ "gpag.id, " // 5
					+ "dtgpag.descricao, gpag.valorDebito, " // 6,7
					+ "dtdbac.id, dtdbac.descricao, " // 8,9
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, " // 10,11
					+ "dbac.valorDebito, ctcrar.id, " // 12,13
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, " // 14,15
					+ "crar.numeroPrestacaoRealizada, crar.valorCredito, " // 16,17
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus " // 18,19
					+ "from ParcelamentoItem parcItem "
					+ "inner join parcItem.parcelamento parc "
					+ "left join parcItem.contaGeral cg "
					+ "left join cg.contaHistorico ch "
					+ "left join cg.conta conta "
					+ "left join parcItem.guiaPagamentoGeral gpg "
					+ "left join gpg.guiaPagamento gpag "
					+ "left join gpag.debitoTipo dtgpag "
					+ "left join parcItem.debitoACobrarGeral dacg "
					+ "left join dacg.debitoACobrar dbac "
					+ "left join dbac.debitoTipo dtdbac "
					+ "left join parcItem.creditoARealizarGeral carg "
					+ "left join carg.creditoARealizar crar "
					+ "left join crar.creditoTipo ctcrar "
					+ "where parc.id = :idParcelamento "
					+ "group by cg.indicadorHistorico, conta.referencia, conta.valorAgua, "
					+ "conta.valorEsgoto, conta.debitos, "
					+ "conta.valorCreditos, gpag.id, "
					+ "ch.anoMesReferenciaConta, ch.valorAgua, "
					+ "ch.valorEsgoto, ch.valorDebitos, "
					+ "ch.valorCreditos, "
					+ "dtgpag.descricao, gpag.valorDebito, "
					+ "dtdbac.id, dtdbac.descricao, "
					+ "dbac.numeroPrestacaoDebito, dbac.numeroPrestacaoCobradas, "
					+ "dbac.valorDebito, ctcrar.id, "
					+ "ctcrar.descricao, crar.numeroPrestacaoCredito, "
					+ "crar.numeroPrestacaoRealizada, crar.valorCredito, "
					+ "dbac.numeroParcelaBonus , crar.numeroParcelaBonus "
					+ "order by conta.referencia, dtdbac.id, gpag.id, "
					+ " ctcrar.id";

			retorno = session.createQuery(consulta)
					.setInteger("idParcelamento", idParcelamento.intValue())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 2/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoDescontoInatividade obterPercentualDescontoInatividade(
			Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcelamentoDescontoInatividade retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin "
					+ "FROM ParcelamentoDescontoInatividade pdin "
					+ "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN ("
					+ "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p "
					+ "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcelamentoDescontoInatividade) session
					.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consultar Servi?os/Atualiza??es do documento de cobra?a
	 * 
	 * 
	 * [UC0349] - Emitir Documento de cobran?a - Ordem de Fiscaliza??o
	 * 
	 * @author Ana Maria
	 * @date 18/10/2006
	 * 
	 * @param idDocumentoCobranca
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarServioAtualizacao(Integer idDocumentoCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = " select sum(cdit.valorItemCobrado) "
					+ " from CobrancaDocumentoItem cdit "
					+ " inner join cdit.cobrancaDocumento cbdo "
					+ " left join cdit.guiaPagamentoGeral.guiaPagamento gpag "
					+ " left join cdit.debitoACobrarGeral.debitoACobrar dbac "
					+ " where cbdo.id = :idDocumentoCobranca and (gpag.id is not null or dbac.id is not null) ";

			Object resultado = session
					.createQuery(consulta)
					.setInteger("idDocumentoCobranca",
							idDocumentoCobranca.intValue()).uniqueResult();

			if (resultado != null) {
				retorno = (BigDecimal) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @created 23/10/2006
	 * 
	 * @param conta
	 * @throws ErroRepositorioException
	 */
	public void associarContaParcelamento(Conta conta)
			throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		try {
			// Atualiza PARC_ID da tabela CONTA com o id do parcelamento
			update = "UPDATE gcom.faturamento.conta.Conta SET "
					+ "parc_id = :idParcelamento,"
					+ "cnta_tmultimaalteracao = :dataUltimaAlteracao "
					+ "WHERE cnta_id = :idConta ";

			session.createQuery(update)
					.setInteger("idParcelamento",
							conta.getParcelamento().getId())
					.setTimestamp("dataUltimaAlteracao",
							conta.getUltimaAlteracao())
					.setInteger("idConta", conta.getId()).executeUpdate();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Retorna os CBCM_ID da tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaGrupoCronogramaMes()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaGrupoCronogramaMes.id,cobrancaGrupoCronogramaMes.anoMesReferencia,cobrancaGrupoCronogramaMes.cobrancaGrupo.id from CobrancaGrupoCronogramaMes cobrancaGrupoCronogramaMes"
					// +
					// " where cobrancaGrupoCronogramaMes.cobrancaGrupo.id in (31) "
					+ " where cobrancaGrupoCronogramaMes.anoMesReferencia >= 200710 ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Retorna os CBCR_ID da tabela COBRANCA_ACAO_CRONOGRAMA com CBCM_ID da
	 * tabela COBRANCA_GRUPO_CRONOGRAMA_MES
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaAcaoCronograma(
			int idCobrancaGrupoCronogramaMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcaoCronograma.id,cobrancaAcaoCronograma.cobrancaAcao.id from CobrancaAcaoCronograma cobrancaAcaoCronograma "
					+ "where cobrancaAcaoCronograma.cobrancaGrupoCronogramaMes.id = :idCobrancaGrupoCronogramaMes";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaGrupoCronogramaMes",
							idCobrancaGrupoCronogramaMes).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Retorna CAAC_TMREALIZACAO do COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDataRelizacaoCobrancaAtividadeAcaoConograma(
			int idCobrancaAcaoCronograma, int idCobrancaAtividade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAtividadeAcaoCronograma.id, "
					+ "cobrancaAtividadeAcaoCronograma.realizacao, "
					+ "cobrancaAtividadeAcaoCronograma.dataPrevista,"
					+ "cobrancaAtividadeAcaoCronograma.comando from CobrancaAcaoAtividadeCronograma cobrancaAtividadeAcaoCronograma "
					+ "where cobrancaAtividadeAcaoCronograma.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma and "
					+ "cobrancaAtividadeAcaoCronograma.cobrancaAtividade.id = :idCobrancaAtividade ";
			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma)
					.setInteger("idCobrancaAtividade", idCobrancaAtividade)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Retorna os DOTP_ID da tabela COBRANCA_ACAO com CBAC_ID de
	 * COBRANCA_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 16/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaAcao(int idCobrancaAcao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaAcao.documentoTipo.id,cobrancaAcao.servicoTipo.id,"
					+ "cobrancaAcao.indicadorDebitoInterfereAcao from CobrancaAcao cobrancaAcao "
					+ "where cobrancaAcao.id = :idCobrancaAcao";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaAcao", idCobrancaAcao).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobran?a
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,S?vio Luiz
	 * @date 17/10/2006,28/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumento(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
					+ "order by cobrancaDocumento.id";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0002] - Determinar Situa??o da A??o de Cobran?a
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com CBDO_ID da tabela
	 * COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos,S?vio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarOrdemServico(int idDocumentoCobranca)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		// int valorIdCronogramaOuComando = -1;
		// String campoCronogramaOuComando = "";
		//
		// if (idCobrancaAtividadeAcaoCronogramaEmitir !=
		// ConstantesSistema.NUMERO_NAO_INFORMADO){
		// campoCronogramaOuComando = "caac_id";
		// valorIdCronogramaOuComando = idCobrancaAtividadeAcaoCronogramaEmitir;
		// } else {
		// campoCronogramaOuComando = "cacm_id";
		// valorIdCronogramaOuComando = idCobrancaAtividadeAcaoComandoEmitir;
		// }

		try {

			consulta = "select orse.orse_id as idOS,"
					+ " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao,"
					+ " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento,"
					+ " cob.cbdo_vldocumento as valorDocumento,"
					+ " cob.cbct_id as idCriterioCobranca, "
					+ " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao,"
					+ " imov.imov_id as idImovel,"
					+ " imov.loca_id as idLocalidade, "
					+ " cob.cast_id as idSituacaoAcao, "
					+ " cob.cbdo_dtsituacaoacao as dataSituacaoAcao "
					+ ", atMotEnc.amen_id as idMotivoEncerramento, "
					+ " cob.cbdo_tmemissao as dataEmissao "
					+ "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id "
					+ "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id "
					+ "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id "
					+ " where cob.cbdo_id = :idDocumento ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("idCriterioCobranca", Hibernate.INTEGER)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.addScalar("dataSituacaoAcao", Hibernate.DATE)
					.addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.addScalar("dataEmissao", Hibernate.DATE)
					.setInteger("idDocumento", idDocumentoCobranca).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0007] - Determinar Situa??o da Ordem de Servi?o
	 * 
	 * Retorna os AMEN_ICEXECUCAO da tabela ATENDIMENTO_MOTIVO_ENCERRAMENTO com
	 * AMEN_ID da tabela ORDEM_SERVI?O
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarAtendimentoMotivoEncerramento(
			int idAtendimentoMotivoEncerramento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select atendimentoMotivoEncerramento.indicadorExecucao from AtendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "where atendimentoMotivoEncerramento.id = :idAtendimentoMotivoEncerramento";

			retorno = session
					.createQuery(consulta)
					.setInteger("idAtendimentoMotivoEncerramento",
							idAtendimentoMotivoEncerramento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os CNTA_ID,GPAG_ID,DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM com
	 * CBDO_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(int idCobrancaDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.contaGeral.id, "
					+ "cobrancaDocumentoItem.guiaPagamentoGeral.id, "
					+ "cobrancaDocumentoItem.debitoACobrarGeral.id, "
					+ "cobrancaDocumentoItem.id,"
					+ "cobrancaDocumentoItem.valorItemCobrado "
					+ "from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.cobrancaDocumento.id = :idCobrancaDocumento";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os CNTG_ID da tabela COBRANCA_GERAL com CNTA_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaGeral(int idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select contaGeral.id "
					+ "from ContaGeral contaGeral "
					+ "where contaGeral.conta.id = :idConta and contaGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,CNHI_DTCANCELAMENTO da tabela CONTA_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarContaHistorico(int idContaHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select contaHistorico.debitoCreditoSituacaoAtual.id,"
					+ "contaHistorico.dataCancelamento "
					+ "from ContaHistorico contaHistorico "
					+ "where contaHistorico.id = :idContaHistorico";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idContaHistorico", idContaHistorico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,CNTA_DTCANCELAMENTO da tabela CONTA com CNTA_ID
	 * da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,S?vio Luiz
	 * @date 17/10/2006,01/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarConta(int idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.debitoCreditoSituacaoAtual.id,"
					+ "conta.dataCancelamento " + "from Conta conta "
					+ "where conta.id = :idConta";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,S?vio Luiz
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoConta(int idConta,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.contaGeral.id = :idConta and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + " inner join tabelaParcelamento."
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem "
			// + "parcelamentoItem where parcelamentoItem.contaGeral.id =
			// :idConta) and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os GPGE_ID da tabela GUIA_PAGAMENTO_GERAL com GPAG_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoGeral(int idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoGeral.id "
					+ "from GuiaPagamentoGeral guiaPagamentoGeral "
					+ "where guiaPagamentoGeral.guiaPagamento.id = :idGuiaPagamento and guiaPagamentoGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("valorIndicador", 1).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,GPGE_DTCANCELAMENTO da tabela
	 * GUIA_PAGAMENTO_HISTORICO com GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamentoHistorico(int idGuiaPagamentoHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamentoHistorico.debitoCreditoSituacaoByDcstIdatual.id,"
					+ "guiaPagamentoHistorico.ultimaAlteracao "
					+ "from GuiaPagamentoHistorico guiaPagamentoHistorico "
					+ "where guiaPagamentoHistorico.id = :idGuiaPagamentoHistorico";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("idGuiaPagamentoHistorico",
							idGuiaPagamentoHistorico).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela GUIA_PAGAMENTO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarGuiaPagamento(int idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select guiaPagamento.debitoCreditoSituacaoAtual.id,"
					+ "guiaPagamento.ultimaAlteracao "
					+ "from GuiaPagamento guiaPagamento "
					+ "where guiaPagamento.id = :idGuiaPagamento";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,S?vio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoGuiaPagamento(int idGuiaPagamento,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.guiaPagamentoGeral.id = :idGuiaPagamento and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DAGE_ID da tabela DEBITO_A_COBRAR_GERAL com DBAC_ID da tabela
	 * COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarGeral(int idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarGeral.id "
					+ "from DebitoACobrarGeral debitoACobrarGeral "
					+ "where debitoACobrarGeral.id = :idDebitoACobrar "
					+ "and debitoACobrarGeral.indicadorHistorico = :valorIndicador";

			retorno = session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("valorIndicador", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,DAGE_DTCANCELAMENTO da tabela
	 * DEBITO_A_COBRAR_HISTORICO com DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrarHistorico(int idDebitoACobrarHistorico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrarHistorico.debitoCreditoSituacaoAtual.id,"
					+ "debitoACobrarHistorico.ultimaAlteracao "
					+ "from DebitoACobrarHistorico debitoACobrarHistorico "
					+ "where debitoACobrarHistorico.id = :idDebitoACobrarHistorico";

			retorno = (Object[]) session
					.createQuery(consulta)
					.setInteger("idDebitoACobrarHistorico",
							idDebitoACobrarHistorico).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os DCST_IDATUAL,GPAG_DTCANCELAMENTO da tabela DEBITO_A_COBRAR com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 17/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDebitoACobrar(int idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select debitoACobrar.debitoCreditoSituacaoAtual.id,"
					+ "debitoACobrar.ultimaAlteracao "
					+ "from DebitoACobrar debitoACobrar "
					+ "where debitoACobrar.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna os PARC_TM_PARCELAMENTO da tabela PARCELAMENTO com DBAC_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos,S?vio Luiz
	 * @date 17/10/2006,29/05/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarParcelamentoDebitoACobrar(int idDebitoACobrar,
			int idParcelamentoSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Date retorno = null;
		String consulta = null;

		try {
			consulta = "select tabelaParcelamento.parcelamento "
					+ " from ParcelamentoItem parcelamentoItem "
					+ " inner join parcelamentoItem.parcelamento tabelaParcelamento "
					+ " where parcelamentoItem.creditoARealizarGeral.id = :idDebitoACobrar and "
					+ " tabelaParcelamento.parcelamentoSituacao = :idParcelamentoSituacao ";

			// consulta = "select tabelaParcelamento.parcelamento "
			// + "from Parcelamento tabelaParcelamento "
			// + "where tabelaParcelamento.id =(select
			// parcelamentoItem.parcelamento.id from ParcelamentoItem
			// parcelamentoItem "
			// + "where parcelamentoItem.debitoACobrar.id = :idDebitoACobrar)
			// and "
			// + "tabelaParcelamento.parcelamentoSituacao =
			// :idParcelamentoSituacao ";

			retorno = (Date) session
					.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setInteger("idParcelamentoSituacao",
							idParcelamentoSituacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * CNTA_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosContaHistorico(int idContaHistorico)
			throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "inner join pagamentoHistorico.contaGeral contaGeral "
					+ "inner join contaGeral.contaHistorico contaHistorico "
					+ "where contaHistorico.id = :idContaHistorico";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idContaHistorico", idContaHistorico)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com CNTA_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosConta(int idConta)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.contaGeral.id = :idConta";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idConta", idConta).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * GPAG_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamentoHistorico(
			int idGuiaPagamentoHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.guiaPagamento.id = :idGuiaPagamentoHistorico";

			Object retornoObj = session
					.createQuery(consulta)
					.setInteger("idGuiaPagamentoHistorico",
							idGuiaPagamentoHistorico).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO com GPAG_ID da
	 * tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosGuiaPagamento(int idGuiaPagamento)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.guiaPagamento.id = :idGuiaPagamento";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGHI_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrarHistorico(
			int idDebitoACobrarHistorico) throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamentoHistorico.dataPagamento) "
					+ "from PagamentoHistorico pagamentoHistorico "
					+ "where pagamentoHistorico.debitoACobrarGeral.id = :idDebitoACobrarHistorico";

			Object retornoObj = session
					.createQuery(consulta)
					.setInteger("idDebitoACobrarHistorico",
							idDebitoACobrarHistorico).uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0003] - Determinar Situa??o do D?bito do Item do Documento de Cobran?a
	 * 
	 * Retorna o Menor PGMT_DTPAGAMENTO da tabela PAGAMENTO_HISTORICO com
	 * DBAC_ID da tabela COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentosDebitoACobrar(int idDebitoACobrar)
			throws ErroRepositorioException {
		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select min(pagamento.dataPagamento) "
					+ "from Pagamento pagamento "
					+ "where pagamento.debitoACobrar.id = :idDebitoACobrar";

			Object retornoObj = session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.uniqueResult();

			if (retornoObj != null) {
				retorno = (Date) retornoObj;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0005] - Determinar Situa??o Predominante do D?bito do Documento de
	 * Cobran?a
	 * 
	 * Retorna o CBCT_PCVLMINIMOPGPARCCANC, CBCBT_PCQTMINIMOPGPARCCANC da tabela
	 * COBRANCA_CRITERIO com CBCT_ID da tabela COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 18/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaCriterio(int idCobrancaCriterio)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// Menor Data de Pagamento
			consulta = "select cobrancaCriterio.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobrancaCriterio.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobrancaCriterio.valorLimitePrioridade "
					+ "from CobrancaCriterio cobrancaCriterio "
					+ "where cobrancaCriterio.id = :idCobrancaCriterio";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0004] - Atualizar item do documento de cobran?a
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO_ITEM
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaDocumentoItem(
			Collection colecaoCobrancaDocumentoItem)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		// posi??es do array com os dados que ser?o atualizados na cobran?a
		// documento item
		final byte POSICAO_ID_COBRANCA_DOCUMENTO = 0;
		final byte POSICAO_ID_COBRANCA_DOCUMENTO_ITEM = 1;
		final byte POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 2;
		final byte POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM = 3;

		try {

			Iterator iteratorColecaoCobrancaDocumentoItem = colecaoCobrancaDocumentoItem
					.iterator();

			while (iteratorColecaoCobrancaDocumentoItem.hasNext()) {

				Object[] cobrancaDocumentoItemParaAtualizar = (Object[]) iteratorColecaoCobrancaDocumentoItem
						.next();

				atualizar = "update gcom.cobranca.CobrancaDocumentoItem "
						+ " set cdst_id = :idSituacaoDebitoItem, cdit_dtsituacaodebito = :dataSituacaoDebito,cdit_tmultimaalteracao = :ultimaAlteracao "
						+ " where cbdo_id = :idCobrancaDocumento and cdit_id = :idCobrancaDocumentoItem ";

				session.createQuery(atualizar)
						.setInteger(
								"idSituacaoDebitoItem",
								((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM]))
						.setDate(
								"dataSituacaoDebito",
								((Date) cobrancaDocumentoItemParaAtualizar[POSICAO_DATA_SITUACAO_DEBITO_COBRANCA_DOCUMENTO_ITEM]))
						.setInteger(
								"idCobrancaDocumento",
								((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO]))
						.setInteger(
								"idCobrancaDocumentoItem",
								((Integer) cobrancaDocumentoItemParaAtualizar[POSICAO_ID_COBRANCA_DOCUMENTO_ITEM]))
						.setTimestamp("ultimaAlteracao", new Date())
						.executeUpdate();
			}
		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0004] - Processar Documento de Cobran?a
	 * 
	 * Atualizar os COBRANCA_DOCUMENTO
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	// Override - Metodo sobrescrito na classe RepositorioCobrancaPostgresHBM
	public void atualizarCobrancaDocumento(Collection colecaoCobrancaDocumento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Connection con = null;
		Statement stmt = null;

		try {

			con = session.connection();
			stmt = con.createStatement();

			Iterator iteratorColecaoCobrancaDocumento = colecaoCobrancaDocumento
					.iterator();

			int TAM_BLOCO_ATUALIZACAO = 50;
			int i = 0;

			StringBuffer atualizar = new StringBuffer();

			while (iteratorColecaoCobrancaDocumento.hasNext()) {

				DadosPesquisaCobrancaDocumentoHelper cobrancaDocumentoParaAtualizar = (DadosPesquisaCobrancaDocumentoHelper) iteratorColecaoCobrancaDocumento
						.next();

				atualizar.append("update cobranca.cobranca_documento set ");
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoAcao() != null) {
					atualizar.append("cast_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdSituacaoAcao() + ",");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoAcao() != null) {
					atualizar
							.append(" cbdo_dtsituacaoacao = to_date('"
									+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar
											.getDataSituacaoAcao())
									+ "','YYYY-MM-DD') , ");
				}
				if (cobrancaDocumentoParaAtualizar.getDataSituacaoDebito() != null) {
					atualizar
							.append(" cbdo_dtsituacaodebito = to_date('"
									+ Util.formatarDataComTracoAAAAMMDD(cobrancaDocumentoParaAtualizar
											.getDataSituacaoDebito())
									+ "','YYYY-MM-DD'), ");
				} else {
					atualizar.append(" cbdo_dtsituacaodebito = null, ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdCategoria() != null) {
					atualizar.append(" catg_id = "
							+ cobrancaDocumentoParaAtualizar.getIdCategoria()
							+ ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIcAcimaLimite() != null) {
					atualizar.append(" cbdo_icacimalimite = "
							+ cobrancaDocumentoParaAtualizar.getIcAcimaLimite()
							+ ", ");
				}
				if (cobrancaDocumentoParaAtualizar.getIdSituacaoDebito() != null) {
					atualizar.append(" cdst_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdSituacaoDebito() + ", ");
				}
				// else {
				// atualizar.append(" cdst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdFiscalizacao() != null) {
					atualizar.append(" fzst_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdFiscalizacao() + ", ");
				}
				// else {
				// atualizar.append(" fzst_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdEsferaPoder() != null) {
					atualizar.append(" epod_id = "
							+ cobrancaDocumentoParaAtualizar.getIdEsferaPoder()
							+ ", ");
				}
				// else {
				// atualizar.append(" epod_id = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIcAntesDepois() != null) {
					atualizar.append(" cbdo_icantesapos = "
							+ cobrancaDocumentoParaAtualizar.getIcAntesDepois()
							+ ", ");
				}
				// else {
				// atualizar.append(" cbdo_icantesapos = null, ");
				// }
				if (cobrancaDocumentoParaAtualizar.getIdMotivoEncerramento() != null) {
					atualizar.append(" amen_id = "
							+ cobrancaDocumentoParaAtualizar
									.getIdMotivoEncerramento() + ", ");
				}

				atualizar.append(" cbdo_tmultimaalteracao = "
						+ Util.obterSQLDataAtual() + " ");
				atualizar.append(" where cbdo_id = "
						+ cobrancaDocumentoParaAtualizar.getIdDocumento() + "");

				stmt.addBatch(atualizar.toString());
				atualizar = new StringBuffer("");

				if ((i > 0 && i % TAM_BLOCO_ATUALIZACAO == 0)
						|| i == (colecaoCobrancaDocumento.size() - 1)) {
					// System.out.println("SQL: " + atualizar.toString());
					// stmt.executeUpdate(atualizar.toString());
					stmt.executeBatch();
					atualizar = new StringBuffer();
					session.flush();
				}
				i++;

			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
			try {
				if (con != null)
					con.close();
				if (stmt != null)
					stmt.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conex?es");
			}
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobran?a
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author Rafael Santos
	 * @date 19/10/2006
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImovel(int idImovel)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct imovel.ligacaoAguaSituacao.id, "
					+ "imovel.ligacaoEsgotoSituacao.id, "
					+ "imovel.localidade.id, "
					+ "imovel.quadra.id, "
					+ "imovel.quadra.numeroQuadra, "
					+ "imovel.setorComercial.id, "
					+ "imovel.setorComercial.codigo, "
					+ "imovel.localidade.gerenciaRegional.id, "
					+ "imovel.quadra.rota.id,  "
					+ "imovel.imovelPerfil.id, "
					+ "esferaPoder.id "
					+ "from Imovel imovel  "
					+ "left outer join imovel.clienteImoveis clienteImoveisReposanvel with (clienteImoveisReposanvel.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " ) "
					+ "and clienteImoveisReposanvel.dataFimRelacao is null  "
					+ "left outer join clienteImoveisReposanvel.cliente clienteResposanvel "
					+ "left outer join clienteResposanvel.clienteTipo clienteTipo "
					+ "left outer join clienteTipo.esferaPoder esferaPoder "
					+ "where imovel.id = :idImovel";
			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0001] - Processar Documentos de Cobran?a
	 * 
	 * Retorna os dados do Imovel
	 * 
	 * @author S?vio Luiz
	 * @date 11/06/2007
	 * 
	 * @return Date retorno
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosImovelPorOS(int idOrdemServico)
			throws ErroRepositorioException {
		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select ordemServ.imovel.id, "
					+ "ordemServ.imovel.localidade.id "
					+ "from OrdemServico ordemServ "
					+ "where ordemServ.id = :idOrdemServico";
			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idOrdemServico", idOrdemServico)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0001] - Processar Documento de Cobran?a
	 * 
	 * Atualizar os COBRANCA_ACAO_ATIVIDADE_CRONOGRAMA
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeCronograma(
			int idCobrancaAcaoAtividadeCrongrama)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma "
					+ " set caac_tmrealizacao = :dataRealizacao,caac_tmultimaalteracao = :dataAtual "
					+ " where caac_id = :idCobrancaAcaoAtividadeCronograma";

			session.createQuery(atualizar)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCrongrama)
					.setDate("dataRealizacao", new Date())
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0006] - Processar A??o com Ordens de Servi?o
	 * 
	 * Retorna os ORSE_ID da tabela ORDEM_SERVICO com SVTP_ID da tabela
	 * COBRANCA_ACAO e ORSE_TMGERACAO entre CAAC_DTPREVISTA do Emitir e do
	 * Encerrar
	 * 
	 * @author Rafael Santos
	 * @date 25/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarOrdemServicos(int idServicoTipo,
			Date dataPrevistaAtividadeEncerrar,
			Date dataPrevistaAtividadeEmitir, int indice)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select ordemServico.id,"
					+ "ordemServico.situacao,"
					+ "ordemServico.fiscalizacaoSituacao.id,"
					+ "ordemServico.dataFiscalizacaoSituacao,"
					+ "ordemServico.dataEncerramento,"
					+ "atendimentoMotivoEncerramento.id,  "
					+ "imov.id, loc.id from OrdemServico ordemServico "
					+ "inner join ordemServico.atendimentoMotivoEncerramento atendimentoMotivoEncerramento "
					+ "left join ordemServico.imovel imov "
					+ "left join imov.localidade loc "
					+ "where ordemServico.servicoTipo.id = :idServicoTipo and "
					+ " ordemServico.dataGeracao >= :dataPrevistaAtividadeEmitir and"
					+ " ordemServico.dataGeracao <= :dataPrevistaAtividadeEncerrar ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idServicoTipo", idServicoTipo)
					.setDate("dataPrevistaAtividadeEmitir",
							dataPrevistaAtividadeEmitir)
					.setDate("dataPrevistaAtividadeEncerrar",
							dataPrevistaAtividadeEncerrar)
					.setFirstResult(indice).setMaxResults(500).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que pr?xima faixa
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 31/10/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoFaixaValor obterParcelamentoFaixaValor(
			Integer idParcelamentoQtdePrestacao, BigDecimal valorFaixa)
			throws ErroRepositorioException {

		ParcelamentoFaixaValor retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pfvl "
					+ "FROM ParcelamentoFaixaValor pfvl "
					+ "WHERE pfvl.parcelamentoQuantidadePrestacao.id = :idParcelamentoQtdePrestacao "
					+ "AND pfvl.valorFaixa IN (" + "SELECT max(p.valorFaixa) "
					+ "FROM ParcelamentoFaixaValor p "
					+ "WHERE p.valorFaixa <= :valorFaixa)";

			retorno = (ParcelamentoFaixaValor) session
					.createQuery(consulta)
					.setInteger("idParcelamentoQtdePrestacao",
							idParcelamentoQtdePrestacao.intValue())
					.setBigDecimal("valorFaixa", valorFaixa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0178] Processar Pagamentos com c?digo de Barras Auhtor: S?cio Luiz
	 * Data: 06/11/2006
	 * 
	 */
	public void atualizarGuiaPagamento(Collection idsGuiaPagamento,
			Date dataVencimento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarGuiaPagamento;
		try {
			atualizarGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_dtvencimento = :dataVencimento,gpag_iccobrancamulta = :idCobrancaMulta, "
					+ " gpag_tmultimaalteracao = :dataAtual where gpag_id in (:idsGuiaPagamento)";

			session.createQuery(atualizarGuiaPagamento)
					.setParameterList("idsGuiaPagamento", idsGuiaPagamento)
					.setDate("dataVencimento", dataVencimento)
					.setShort("idCobrancaMulta", ConstantesSistema.SIM)
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * O sistema exclui o resumo das a??es de cobran?a correspondente ao
	 * cronograma de a??o de cobran?a que esta sendo processado
	 * 
	 * @author Rafael Santos
	 * @date 08/11/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcao(int idCobrancaAcaoCronograma)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcao resumoCobrancaAcao "
					+ "where resumoCobrancaAcao.cobrancaAcaoCronograma.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * retorna uma colecao de ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicio()
			throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.indicadorUtilizacaoLivre = :indicadorUtilizacaoLivre "
					+ "and rd.dataVigenciaInicio <= :dataAtual "
					+ "and (rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ "and not exists (select rdlg.id from RdLimitacaoGeografica rdlg where rdlg.resolucaoDiretoria.id = rd.id) "
					+ "and not exists (select rdru.id from RdRestricaoUsuario rdru where rdru.resolucaoDiretoria.id = rd.id) "
					+ "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session
					.createQuery(consulta)
					.setDate("dataAtual", new Date())
					.setShort("indicadorUtilizacaoLivre", ConstantesSistema.SIM)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Obtem a condi??o referente ? qtde de reparcelamentos consecutivos j?
	 * realizadas para o perfil do parcelamento para o im?vel
	 * 
	 * a partir da tabela PARCELAMENTO_QUANTIDADE_REPARCELAMENTO com
	 * PCPF_ID=PCPF_ID da tabela PARCELAMENTO_PERFIL e
	 * PQTR_QTMAXIMAREPARCELAMENTO igual ou menor que
	 * IMOV_NNREPARCELAMENTOCONSECUTVOS, caso mais de uma ocorrencia seja
	 * selecionada, escolher a que tiver o maior valor de
	 * PQTR_QTMAXIMAREPARCELAMENTO
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 28/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelamentoQuantidadeReparcelamento obterQtdeReparcelamentoPerfil(
			Integer idPerfilParc, Short numeroReparcelamentoConsecutivos)
			throws ErroRepositorioException {

		ParcelamentoQuantidadeReparcelamento retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parcelamentoQtdeReparcel "
					+ "FROM ParcelamentoQuantidadeReparcelamento parcelamentoQtdeReparcel "
					+ "WHERE parcelamentoQtdeReparcel.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND parcelamentoQtdeReparcel.quantidadeMaximaReparcelamento IN ("
					+ "SELECT max(p.quantidadeMaximaReparcelamento)"
					+ "FROM ParcelamentoQuantidadeReparcelamento p "
					+ "WHERE p.quantidadeMaximaReparcelamento <= :numeroReparcelamentoConsecutivos "
					+ "and p.parcelamentoPerfil.id = :idPerfilParc)";

			retorno = (ParcelamentoQuantidadeReparcelamento) session
					.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setShort("numeroReparcelamentoConsecutivos",
							numeroReparcelamentoConsecutivos).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0213] Desfazer Parcelamento D?bitos Remove ClienteGuiaPagamento
	 * referentes ao parcelamento
	 * 
	 * @author Vivianne Sousa
	 * @created 28/11/2006
	 * 
	 * @param idImovel
	 *            idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void removerClienteGuiaPagamentoDoParcelamento(
			Integer idGuiaPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerClienteGuiaPagamentoDoParcelamento;

		try {
			// remove em credito a realizar os parcelamentos
			removerClienteGuiaPagamentoDoParcelamento = "delete gcom.cadastro.cliente.ClienteGuiaPagamento "
					+ "where gpag_id = :idGuiaPagamento ";

			session.createQuery(removerClienteGuiaPagamentoDoParcelamento)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisa o crit?rio de cobran?a linha definido para a rota
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0001] Gerar Atividade de
	 * A??o de Cobran?a para os Im?veis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idRota
	 * @param idCobrancaAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public CobrancaCriterio pesquisarCriterioCobrancaRota(Integer idRota,
			Integer idCobrancaAcao) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from RotaAcaoCriterio rac "
					+ "inner join rac.cobrancaAcao ca "
					+ "inner join rac.cobrancaCriterio cc "
					+ "where rac.comp_id.rotaId = :idRota and ca.id = :idCobrancaAcao";

			retorno = (CobrancaCriterio) session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("idCobrancaAcao", idCobrancaAcao)
					.setMaxResults(1).uniqueResult();

			retorno.setCriteriosSituacaoCobranca(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoCobranca(retorno.getId())));
			retorno.setCriteriosSituacaoLigacaoAgua(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoLigacaoAgua(retorno
							.getId())));
			retorno.setCriteriosSituacaoLigacaoEsgoto(new HashSet(this
					.pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(retorno
							.getId())));
			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o crit?rio de cobran?a linha definido para o crit?rio de
	 * cobran?a
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0001] Gerar Atividade de
	 * A??o de Cobran?a para os Im?veis do Cliente
	 * 
	 * @author Leonardo Vieira
	 * @created 12/12/2006
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaCriterioLinha> pesquisarCobrancaCriterioLinhaCriterio(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ccl  from CobrancaCriterioLinha ccl "
					+ "inner join ccl.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o crit?rio de situacao de cobran?a definido para o crit?rio de
	 * cobran?a
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0001] Gerar Atividade de
	 * A??o de Cobran?a para os Im?veis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoCobranca> pesquisarCobrancaCriterioSituacaoCobranca(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csc from CriterioSituacaoCobranca csc "
					+ "inner join csc.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o crit?rio de situacao de ligacao de agua definido para o
	 * crit?rio de cobran?a
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0001] Gerar Atividade de
	 * A??o de Cobran?a para os Im?veis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoAgua> pesquisarCobrancaCriterioSituacaoLigacaoAgua(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csla from CriterioSituacaoLigacaoAgua csla "
					+ "inner join csla.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o crit?rio de situacao de ligacao de esgoto definido para o
	 * crit?rio de cobran?a
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0001] Gerar Atividade de
	 * A??o de Cobran?a para os Im?veis do Cliente
	 * 
	 * @author Francisco do Nascimento
	 * @created 10/06/2008
	 * 
	 * @param idCobrancaCriterio
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CriterioSituacaoLigacaoEsgoto> pesquisarCobrancaCriterioSituacaoLigacaoEsgoto(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select csle from CriterioSituacaoLigacaoEsgoto csle "
					+ "inner join csle.comp_id.cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaCriterio pesquisarCobrancaCriterioIdCriterio(
			Integer idCobrancaCriterio) throws ErroRepositorioException {

		CobrancaCriterio retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cc from cobrancaCriterio cc "
					+ " where cc.id = :idCobrancaCriterio ";

			retorno = (CobrancaCriterio) session.createQuery(consulta)
					.setInteger("idCobrancaCriterio", idCobrancaCriterio)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Pesquisa o documento de cobranca da acao precedente (2.3.1)
	 * 
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0003] Gerar Atividade de
	 * A??o de Cobran?a o Im?vel
	 * 
	 * @author Francisco do Nascimento
	 * @date 22/12/2008
	 * 
	 * @param idImovel
	 * @param idServicoTipo
	 * @param indicadorExecucao
	 * @param dataEncerramento
	 * @return Id do documento de cobran?a
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarDocumentoCobrancaAcaoPrecedente(Integer idImovel,
			Integer idServicoTipo, Short indicadorExecucao,
			Date dataEncerramento) throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select os.cobrancaDocumento.id from OrdemServico os "
					+ "inner join os.servicoTipo st "
					+ "inner join os.imovel im "
					+ "inner join os.atendimentoMotivoEncerramento ame "
					+ "where os.dataEncerramento is not null "
					+ "and im.id = :idImovel and st.id = :idServicoTipo and ame.indicadorExecucao = :indicadorExecucao  "
					+ "and os.dataEncerramento <= :dataEncerramento";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idServicoTipo", idServicoTipo)
					.setShort("indicadorExecucao", indicadorExecucao)
					.setDate("dataEncerramento", dataEncerramento)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Integer pesquisarDocumentoCobrancaRelativoAcaoPrecedente(
			Integer idImovel, Integer idDocumentoTipo, Date dataEmissao,
			Date dataEmissaoValidade) throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cbdo.cbdo_id as idCobrancaDocumento  from cobranca.cobranca_documento cbdo "
					+ "inner join cobranca.documento_tipo dotp on dotp.dotp_id = cbdo.dotp_id "
					+ "left join faturamento.documento_nao_entregue done on done.cbdo_id = cbdo.cbdo_id "
					+ "where cbdo.imov_id = :idImovel and dotp.dotp_id = :idDocumentoTipo "
					+ "and (done.dotp_id is null or done.dotp_id <> dotp.dotp_id) "
					+ "and cbdo.cbdo_tmemissao <= :dataEmissao AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade "
					+ "and (cbdo.cast_id is null OR cbdo.cast_id <> "
					+ CobrancaAcaoSituacao.CANCELADA_PRAZO + ")";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setDate("dataEmissao", dataEmissao)
					.setDate("dataEmissaoValidade", dataEmissaoValidade)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	public Object[] pesquisarIdDocumentoCobranca(Integer idImovel,
			Integer idDocumentoTipo, Date dataEmissao)
			throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd.cbdo_id as idCobrancaDocumento, cd.cast_id as idCobrancaAcaoSituacao from cobranca.cobranca_documento cd "
					+ "where cd.imov_id = :idImovel and cd.dotp_id = :idDocumentoTipo "
					+ "and cd.cbdo_tmemissao > :dataEmissao";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("idCobrancaAcaoSituacao", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setDate("dataEmissao", dataEmissao).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	public Collection pesquisarImovelCobrancaSituacao(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select ics.cobrancaSituacao.id from ImovelCobrancaSituacao ics "
					+ "inner join ics.imovel im "
					+ "where im.id = :idImovel and ics.dataRetiradaCobranca is null ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	public DebitoTipo pesquisarDebitoTipo(Integer idDebitoTipo)
			throws ErroRepositorioException {

		DebitoTipo retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select debitoTipo from DebitoTipo debitoTipo "
					+ "where debitoTipo.id = :idDebitoTipo";

			retorno = (DebitoTipo) session.createQuery(consulta)
					.setInteger("idDebitoTipo", idDebitoTipo).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronograma(
			Integer idCronogramaAtividadeAcaoCobranca)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac "
					+ "where caac.id = :idCronogramaAtividadeAcaoCobranca";

			retorno = (CobrancaAcaoAtividadeCronograma) session
					.createQuery(consulta)
					.setInteger("idCronogramaAtividadeAcaoCobranca",
							idCronogramaAtividadeAcaoCobranca).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeComando pesquisarCobrancaAcaoAtividadeComando(
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeComando retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeComando caac "
					+ "where caac.id = :idCobrancaAcaoAtividadeComando";

			retorno = (CobrancaAcaoAtividadeComando) session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeComando",
							idCobrancaAcaoAtividadeComando).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	public Collection pesquisarCobrancaDocumentoItemContaGuiaPagamentoDebitoACobrar(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Collection retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cdi from CobrancaDocumentoItem cdi "
					+ "inner join cdi.cobrancaDocumento cd "
					+ "left join fetch cdi.contaGeral ctg "
					+ "left join fetch ctg.conta ct "
					+ "left join fetch cdi.guiaPagamentoGeral gpg "
					+ "left join fetch gpg.guiaPagamento gp "
					+ "left join fetch cdi.debitoACobrarGeral dacg "
					+ "left join fetch dacg.debitoACobrar dac "
					+ "where cd.id = :idCobrancaDocumento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaDocumento pesquisarCobrancaDocumento(Integer idImovel,
			Integer idDocumentoTipo) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select cd from CobrancaDocumento cd "
					+ "where cd.imovel.id = :idImovel "
					+ "and cd.documentoTipo.id = :idDocumentoTipo "
					+ "order by cd.emissao desc";

			retorno = (CobrancaDocumento) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	public CobrancaAcaoAtividadeCronograma pesquisarCobrancaAcaoAtividadeCronogramaId(
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcaoAtividadeCronograma retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select caac from CobrancaAcaoAtividadeCronograma caac "
					+ "inner join fetch caac.cobrancaAcaoCronograma cac "
					+ "inner join fetch cac.cobrancaAcao ca "
					+ "left join fetch ca.cobrancaAcaoPredecessora coAcPred "
					+ "left join fetch coAcPred.servicoTipo servicoTipo "
					+ "left join fetch ca.ligacaoAguaSituacao "
					+ "left join fetch ca.ligacaoEsgotoSituacao "
					+ "left join fetch ca.documentoTipo "
					+ "left join fetch caac.cobrancaAtividade cat "
					+ "left join fetch cat.processo "
					+ "left join fetch cac.cobrancaGrupoCronogramaMes cgcm "
					+ "left join fetch cgcm.cobrancaGrupo "
					+ "left join fetch ca.servicoTipo "
					+ "left join fetch ca.cobrancaAcaoPredecessoraAlternativa coAcPredAlter "
					+ "left join fetch coAcPredAlter.documentoTipo documentoTipoAlter "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma ";

			retorno = (CobrancaAcaoAtividadeCronograma) session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCronograma).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verifica de conta tem debito cobrado (CNTA_ID ocorre na tabela
	 * DEBITO_COBRADO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Conta verificarContaDebitoCobrado(Integer idConta)
			throws ErroRepositorioException {

		Conta retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select distinct conta " + "from DebitoCobrado db "
					+ "where db.conta.id = :idConta ";

			retorno = (Conta) session.createQuery(consulta)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * obtem o consumo m?dio do imovel CSHI_NNCONSUMOCONSUMOMEDIO da tabla
	 * CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior m?s/ano
	 * de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterConsumoMedioImovel(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.consumoMedio "
					+ "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel "
					+ "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterIdDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * DBCB_NNPRESTACAO da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta
	 * e DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID ocorrendo na
	 * tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR
	 * 
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroPrestacaoDebitoCobrado(Integer idConta)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select debitoCobrado.numeroPrestacao "
					+ "from DebitoCobrado debitoCobrado  "
					+ "where debitoCobrado.conta.id = :idConta " + "and  "
					+ "(select distinct(fiscalizacao.debitoTipo.id) "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)) is not null";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Metodo criado para pesquisar os parcelamentos q tenham juros e nao tenha
	 * criado o debito dos juros DBTP_ID = 44
	 * 
	 * @author Fl?vio Cordeiro
	 * @date 23/02/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSemDebitos()
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String sql = "select distinct(parc.parc_id) as idParcelamento,"
				+ " parc.parc_nnprestacoes as numeroPrestacao,"
				+ " parc.parc_txjuros as taxaJuros,"
				+ " imovel.loca_id as idLocalidade,"
				+ " quadra.qdra_id as idQuadra,"
				+ " quadra.qdra_nnquadra as numeroQuadra,"
				+ " setorComercial.stcm_id as idSetor,"
				+ " setorComercial.stcm_cdsetorcomercial as codigoSetor,"
				+ " imovel.imov_nnlote as lote,"
				+ " imovel.imov_nnsublote as subLote,"
				+ " parc.parc_vljurosparcelamento as valorJurosParcelamento,"
				+ " imovel.imov_id as idImovel"
				+ " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " inner join cadastro.imovel imovel on imovel.imov_id = parc.imov_id"
				+ " inner join cadastro.setor_comercial setorComercial on setorComercial.stcm_id = imovel.stcm_id"
				+ " inner join cadastro.quadra quadra on imovel.qdra_id = quadra.qdra_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)"
				+ " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and parc.parc_id "
				+ " not in "
				+ " (select parc.parc_id"
				+ " from cobranca.parcelamento parc"
				+ " left join faturamento.debito_a_cobrar debitoCobrar on debitoCobrar.parc_id = parc.parc_id"
				+ " where (parc.parc_tmparcelamento between :inicio and :fim)"
				+ " and parc.parc_vljurosparcelamento <> 0.00"
				+ " and debitoCobrar.dbtp_id = 44)";

		try {
			retorno = session
					.createSQLQuery(sql)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					// 0
					.addScalar("numeroPrestacao", Hibernate.SHORT)
					// 1
					.addScalar("taxaJuros", Hibernate.BIG_DECIMAL)
					// 2
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 3
					.addScalar("idQuadra", Hibernate.INTEGER)
					// 4
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					// 5
					.addScalar("idSetor", Hibernate.INTEGER)
					// 6
					.addScalar("codigoSetor", Hibernate.INTEGER)
					// 7
					.addScalar("lote", Hibernate.SHORT)
					// 8
					.addScalar("subLote", Hibernate.SHORT)
					// 9
					.addScalar("valorJurosParcelamento", Hibernate.BIG_DECIMAL)
					// 10
					.addScalar("idImovel", Hibernate.INTEGER)
					// 11
					.setDate("inicio",
							Util.converteStringParaDate("22/02/2007"))
					.setDate("fim", Util.converteStringParaDate("24/02/2007"))
					.list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a colecao de a??o de cobran?a passando o id da acao precedente
	 * 
	 * 
	 * 
	 * @author S?vio Luiz
	 * @created 27/02/2007
	 * 
	 * @param idCobracaoAcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesqsuisarAcaoCobrancaPelaPrecedente(
			Integer idCobracaoAcao) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select docTipo.id,cobAcao.numeroDiasValidade "
					+ "from CobrancaAcao cobAcao  "
					+ "inner join cobAcao.documentoTipo docTipo "
					+ "left join cobAcao.cobrancaAcaoPredecessora cobAcaoPrede "
					+ "where cobAcaoPrede.id = :idCobracaoAcao ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idCobracaoAcao", idCobracaoAcao).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * Obt?m a menor data de pagamento para as guias de pagamento
	 * 
	 * [UC0302] Gerar D?bitos a Cobrar de Acr?scimos por Impontualidade
	 * 
	 * @author Pedro Alexandre
	 * @date 19/03/2007
	 * 
	 * @param idGuiaPagamento
	 * @param idImovel
	 * @param idDebitoTipo
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Date pesquisarMenorDataPagamentoGuiaPagamento(
			Integer idGuiaPagamento, Integer idImovel, Integer idDebitoTipo)
			throws ErroRepositorioException {

		Date retorno = null;
		Date data1 = null;
		Date data2 = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov "
					+ "WHERE gpag.id = :idGuiaPagamento ";

			data1 = (Date) session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.uniqueResult();

			consulta = "SELECT MIN(pgmt.dataPagamento) "
					+ "FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.guiaPagamento gpag "
					+ "INNER JOIN gpag.imovel imov "
					+ "WHERE pgmt.imovel.id= :idImovel and pgmt.debitoTipo.id = :idDebitoTipo";

			data2 = (Date) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDebitoTipo", idDebitoTipo).uniqueResult();

			if (data2 == null) {
				retorno = data1;
			} else {
				if (data1 == null) {
					retorno = data2;
				} else {
					if (data1.before(data2)) {
						retorno = data1;
					} else {
						retorno = data2;
					}
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * obtem o numero de Consumo Faturado Mes CSHI_NNCONSUMOFATURADOMES da
	 * tabela CONSUMO_HISTORICO com IMOV_ID = IMOV_ID da tabela CONTA e o maior
	 * m?s/ano de consumo(CSHI_AMFATURAMENTO)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 19/03/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterNumeroConsumoFaturadoMes(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select consumoHistorico.numeroConsumoFaturadoMes "
					+ "from ConsumoHistorico consumoHistorico "
					+ "where consumoHistorico.imovel.id = :idImovel "
					+ "order by consumoHistorico.referenciaFaturamento desc";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) conta(s) parceladas j? est?o no hist?rico [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarContaHistoricoParcelamento(Integer idImovel,
			Integer idParcelamento) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.contaGeral cntaGeral "
					+ "left join cntaGeral.contaHistorico cntaHist "
					+ "where cntaHist.imovel.id = :idImovel and "
					+ "parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) debito(s) a cobrar parcelados j? est?o no hist?rico
	 * [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarDebitoACobrarHistoricoParcelamento(
			Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.debitoACobrarGeral dbacGeral "
					+ "left join dbacGeral.debitoACobrarHistorico dbacHist "
					+ "where dbacHist.imovel.id = :idImovel "
					+ "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * verificar se a(s) credito(s) a realizar utilizados no parcelados j? est?o
	 * no hist?rico [UC0252] Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 09/04/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection verificarCreditoARealizarHistoricoParcelamento(
			Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select distinct(parcItem.id) " + "from "
					+ "ParcelamentoItem parcItem "
					+ "inner join parcItem.creditoARealizarGeral cdarGeral "
					+ "left join cdarGeral.creditoARealizarHistorico cdarHist "
					+ "where cdarHist.imovel.id = :idImovel "
					+ "and parcItem.parcelamento.id = :idParcelamento ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * retorna referenciaContabil da conta cancelada por retifica??o [UC0252]
	 * Desfazer Parcelamentos de Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 13/04/2007
	 * 
	 * @param idImovel
	 * @param anoMesReferencia
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaCanceladaRetificacao(Integer idImovel,
			int anoMesReferencia) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select conta.referenciaContabil "
					+ "from Conta conta "
					+ "where conta.imovel = :idImovel and "
					+ "conta.referencia = :anoMesReferencia and "
					+ "conta.debitoCreditoSituacaoAtual.id = :debitoCreditoSituacaoAtual ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("debitoCreditoSituacaoAtual",
							DebitoCreditoSituacao.CANCELADA_POR_RETIFICACAO)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna o objeto ParcelamentoFaixaValor com o valor do debito(valorFaixa)
	 * com desconto maior q o da faixa e menor que pr?xima faixa
	 * 
	 * [UC0575] - Emitir Parcelamento em Atraso
	 * 
	 * @author S?vio Luiz
	 * @date 14/04/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosParcelamentoComMaiorTimestemp(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.parcelamento, "// 0
					+ "parc.valorConta, "// 1
					+ "parc.valorServicosACobrar, "// 2
					+ "parc.valorAtualizacaoMonetaria, "// 3
					+ "parc.valorJurosMora, "// 4
					+ "parc.valorMulta, "// 5
					+ "parc.valorDescontoAcrescimos, "// 6
					+ "parc.valorDescontoAntiguidade, "// 7
					+ "parc.valorDescontoInatividade, "// 8
					+ "parc.valorEntrada, "// 9
					+ "parc.numeroPrestacoes, "// 10
					+ "parc.valorPrestacao, "// 11
					+ "parc.valorJurosParcelamento, "// 12
					+ "parc.id "// 13
					+ "FROM Parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal "
					+ "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SF0003] - Processar Pagamento de Documento de Cobran?a
	 * 
	 * @author Ana Maria
	 * @created 13/04/2007
	 * 
	 * @param idCliente
	 * @param numeroSequencialDocumento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarCobrancaDocumentoItemCliente(Integer idCliente,
			int numeroSequencialDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "// 12
					+ "imov.id, "// 13
					+ "imovGuia.id, "// 14
					+ "imovDebito.id, "// 15
					+ "localidadeConta.id, "// 16
					+ "localidadeGuiaPagamento.id, "// 17
					+ "localidadeDebitoACobrar.id, "// 18
					+ "imovelHistorico.id, "// 19
					+ "localidadeContaHistorico.id, "// 20
					+ "imovGuiaHistorico.id, "// 21
					+ "localidadeGuiaPagamentoHistorico.id, "// 22
					+ "imovDebitoHistorico.id, "// 23
					+ "localidadeDebitoACobrarHistorico.id, "// 24
					+ "cd.id, "// 25
					+ "documentoTipo.id, "// 26
					+ "debitoACobrar.numeroPrestacaoDebito, " // 27
					+ "debitoACobrar.numeroPrestacaoCobradas, " // 28
					+ "cage.id, " // 29
					+ "localidade.id, " // 30
					+ "imovel.id "// 31

					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.cliente clie "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN conta.imovel imov "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN contaHistorico.imovel imovelHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN guiaPagamento.imovel imovGuia "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN guiaPagamentoHistorico.imovel imovGuiaHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN debitoACobrar.imovel imovDebito "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN debitoACobrarHistorico.imovel imovDebitoHistorico "
					+ "LEFT JOIN conta.localidade localidadeConta "
					+ "LEFT JOIN contaHistorico.localidade localidadeContaHistorico "
					+ "LEFT JOIN guiaPagamento.localidade localidadeGuiaPagamento "
					+ "LEFT JOIN guiaPagamentoHistorico.localidade localidadeGuiaPagamentoHistorico "
					+ "LEFT JOIN debitoACobrar.localidade localidadeDebitoACobrar "
					+ "LEFT JOIN debitoACobrarHistorico.localidade localidadeDebitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade localidade "
					+ "LEFT JOIN cd.imovel imovel "

					+ "WHERE cd.numeroSequenciaDocumento = :numeroSequencialDocumento AND "
					+ "clie.id = :idCliente";

			retorno = session
					.createQuery(consulta)
					.setInteger("numeroSequencialDocumento",
							numeroSequencialDocumento)
					.setInteger("idCliente", idCliente.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta o id e a situa??o da ordem de servi?o associada ao documento de
	 * cobran?a passado como par?metro
	 * 
	 * @author S?vio Luiz
	 * @created 13/04/2007
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Object[] pesquisarDadosOrdemServicoDocumentoCobranca(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Object[] retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select os.id,os.situacao from OrdemServico os "
					+ "inner join os.cobrancaDocumento cobrancaDoc "
					+ "where cobrancaDoc.id = :idDocumentoCobranca ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0394] - Gerar D?bitos a Cobrar de Doa??es
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsParcelamentosItemDebitoACobrar(
			Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select parcelamentoItem.id"
					+ " from ParcelamentoItem parcelamentoItem "
					+ " where parcelamentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta)
					.setParameterList("idsDebitoACobrar", idsDebitoACobrar)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar D?bitos a Cobrar de Doa??es
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsCobrancaDocumentoItemDebitoACobrar(
			Collection idsDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cobrancaDocumentoItem.id"
					+ " from CobrancaDocumentoItem cobrancaDocumentoItem "
					+ " where cobrancaDocumentoItem.debitoACobrarGeral.id in (:idsDebitoACobrar)";

			retorno = session.createQuery(consulta)
					.setParameterList("idsDebitoACobrar", idsDebitoACobrar)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0394] - Gerar D?bitos a Cobrar de Doa??es
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCobrancaDocumentoItemDebitoACobrar(
			Collection idsDocumentoItemDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "delete CobrancaDocumentoItem cobrancaDocumentoItem "
					+ "where cobrancaDocumentoItem.id in (:idsDocumentoItemDebitoACobrar) ";

			session.createQuery(consulta)
					.setParameterList("idsDocumentoItemDebitoACobrar",
							idsDocumentoItemDebitoACobrar).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0394] - Gerar D?bitos a Cobrar de Doa??es
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 09/05/2007
	 * 
	 * @param colecaoRotas
	 *            , Integer anoMesReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarParcelamentosItemDebitoACobrar(
			Collection idsParcelamentosItemDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String atualizarImovel = "update gcom.cobranca.parcelamento.ParcelamentoItem "
					+ "set dbac_id = null where pcit_id in (:idsParcelamentosItemDebitoACobrar)";

			session.createQuery(atualizarImovel)
					.setParameterList("idsParcelamentosItemDebitoACobrar",
							idsParcelamentosItemDebitoACobrar).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author S?vio Luiz,Vivianne Sousa
	 * @date 17/10/2006,30/08/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataPrevista(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " select"
					+ " (select osfs.fzst_id"
					+ " from atendimentopublico.ordem_servico_fisc_sit osfs"
					+ " inner join atendimentopublico.ordem_servico orse on osfs.orse_id = orse.orse_id"
					+ " where orse.cbdo_id  = cbdo.cbdo_id and ROWNUM <= 1 "
					+ " order by osfs_dtfiscalizacaosituacao ) as idFiscalizacaoSit,"// 0
					+ " cbdo.cbdo_icantesapos as indAntesApos,"// 1
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite,"// 2
					+ " casit.cast_id as idCobrancaAcaoSit,"// 3
					+ " cdst.cdst_id as idCobrancaDebitoSit,"// 4
					+ " catg.catg_id as idCategoria,"// 5
					+ " epod.epod_id as idEsferaPoder,"// 6
					+ " cbct.cbct_id as idCobrancaCriterio,"// 7
					+ " greg.greg_id as idGerencia,"// 8
					+ " loca.loca_id as idLocalidade,"// 9
					+ " stcm.stcm_id as idSetor,"// 10
					+ " rota.rota_id as idRota,"// 11
					+ " qdra.qdra_id as idQuadra,"// 12
					+ " qdra.qdra_nnquadra as numeroQuadra,"// 13
					+ " stcm.stcm_cdsetorcomercial as codigoSetor,"// 14
					+ " iper.iper_id as idPerfilImovel,"// 15
					+ " coalesce(last.last_id,imov.last_id) as idLigacaoAguaSit,"// 16
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit,"// 17
					+ " empr.empr_id as idEmpresa,"// 18
					+ " amen.amen_id as idAtendMotivoEnc,"// 19
					+ " loca.uneg_id as idUnidadeNegocio,"// 20
					+ " cbdo.demf_id as idDocEmissaoForma,"// 21
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento,"// 22
					+ " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"// 23
					+ " from"
					+ " cobranca.cobranca_documento cbdo"
					+ " left outer join cadastro.esfera_poder epod 				on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit 			on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst 			on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg 				on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_crg caac 		on cbdo.caac_id=caac.caac_id"
					+ " left outer join cobranca.cobranca_acao_cronograma cbcr 			on caac.cbcr_id=cbcr.cbcr_id"
					+ " left outer join cobranca.cobranca_acao cbac 				on cbcr.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_grupo_crg_mes cbcm 		on cbcr.cbcm_id=cbcm.cbcm_id"
					+ " left outer join cobranca.cobranca_grupo cbgr 				on cbcm.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cobranca.cobranca_criterio cbct 			on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov 					on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca 				on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg 			on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm 				on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra 					on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota 					on qdra.rota_id=rota.rota_id"
					+ " left outer join cadastro.imovel_perfil iper 				on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest  	on cbdo.lest_id=lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao last 		on cbdo.last_id=last.last_id"
					+ " left outer join cadastro.empresa empr 					on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id"
					+ " where"
					+ " caac.caac_id= :idCobrancaAtividadeAcaoCronograma"
					+ " group by"
					+ " idFiscalizacaoSit,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,casit.cast_id ,cdst.cdst_id ,catg.catg_id ,"
					+ " cbcm.cbcm_amreferencia ,cbcr.cbcr_id,caac.caac_dtprevista,cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,"
					+ " loca.loca_id ,stcm.stcm_id ,rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial,iper.iper_id ,"
					+ " last.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id, cbdo.demf_id"
					+ " order by"
					+ " idFiscalizacaoSit,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,cdst.cdst_id,"
					+ " catg.catg_id,epod.epod_id,greg.greg_id,loca.uneg_id,loca.loca_id,stcm.stcm_id,rota.rota_id,"
					+ " qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,iper.iper_id,last.last_id,lest.lest_id";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id, coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join cobrancaDocumento.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.dataPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.unidadeNegocio.id, loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author S?vio Luiz,Vivianne Sousa, Ivan Sergio
	 * @date 17/10/2006,30/08/2010, 23/12/2010
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoAgrupadoPorDataComando(
			int idCobrancaAtividadeAcaoCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// CRC4529 - query alterada por Vivianne Sousa - 30/08/2010

			consulta = " SELECT temp.fzst_id                   AS idfiscalizacaosit,"
					+ " cbdo.cbdo_icantesapos               AS indantesapos,"
					+ " cbdo.cbdo_icacimalimite             AS indacimalimite,"
					+ " casit.cast_id                       AS idcobrancaacaosit,"
					+ " cdst.cdst_id                        AS idcobrancadebitosit,"
					+ " catg.catg_id                        AS idcategoria,"
					+ " epod.epod_id                        AS idesferapoder,"
					+ " cbct.cbct_id                        AS idcobrancacriterio,"
					+ " greg.greg_id                        AS idgerencia,"
					+ " loca.loca_id                        AS idlocalidade,"
					+ " stcm.stcm_id                        AS idsetor,"
					+ " rota.rota_id                        AS idrota,"
					+ " qdra.qdra_id                        AS idquadra,"
					+ " qdra.qdra_nnquadra                  AS numeroquadra,"
					+ " stcm.stcm_cdsetorcomercial          AS codigosetor,"
					+ " iper.iper_id                        AS idperfilimovel,"
					+ " COALESCE(LLAST.last_id,imov.last_id) AS idligacaoaguasit,"
					+ " COALESCE(lest.lest_id,imov.lest_id) AS idligacaoesgotosit,"
					+ " empr.empr_id                        AS idempresa,"
					+ " amen.amen_id                        AS idatendmotivoenc,"
					+ " loca.uneg_id                        AS idunidadenegocio,"
					+ " cbdo.demf_id                        AS iddocemissaoforma,"
					+ " COUNT(cbdo.cbdo_id)                 AS qtdecobrancadocumento,"
					+ " SUM(cbdo.cbdo_vldocumento)          AS valorcobrancadoc,"

					+ " case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and"
					+ " cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and"
					+ " casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then"
					+ " 		cotp.cotp_id"
					+ " end 								   AS idCorteTipo"

					+ " FROM cobranca.cobranca_documento cbdo"
					+ " LEFT OUTER JOIN"
					+ " ("
					+ " SELECT osfs.fzst_id,"
					+ "        osfs.OSFS_DTFISCALIZACAOSITUACAO,"
					+ "        cbdo.cbdo_id "
					+ "   FROM cobranca.cobranca_acao_ativ_crg caac,"
					+ "       cobranca.cobranca_documento cbdo,"
					+ "       atendimentopublico.ordem_servico orse,"
					+ "       atendimentopublico.ordem_servico_fisc_sit osfs"
					+ "  WHERE "
					+ "    caac.caac_id = :idCobrancaAtividadeAcaoCronograma"
					+ "    AND cbdo.caac_id = cbdo.caac_id"
					+ "    AND orse.cbdo_id = cbdo.cbdo_id"
					+ "    AND osfs.orse_id = orse.orse_id"
					+ " ) temp ON temp.cbdo_id = cbdo.cbdo_id"
					+ " LEFT OUTER JOIN cadastro.esfera_poder epod"
					+ " ON cbdo.epod_id=epod.epod_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_situacao casit"
					+ " ON cbdo.cast_id=casit.cast_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_debito_situacao cdst"
					+ " ON cbdo.cdst_id=cdst.cdst_id"
					+ " LEFT OUTER JOIN cadastro.categoria catg"
					+ " ON cbdo.catg_id=catg.catg_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_ativ_crg caac"
					+ " ON cbdo.caac_id=caac.caac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao_cronograma cbcr"
					+ " ON caac.cbcr_id=cbcr.cbcr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_acao cbac"
					+ " ON cbcr.cbac_id=cbac.cbac_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo_crg_mes cbcm"
					+ " ON cbcr.cbcm_id=cbcm.cbcm_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_grupo cbgr"
					+ " ON cbcm.cbgr_id=cbgr.cbgr_id"
					+ " LEFT OUTER JOIN cobranca.cobranca_criterio cbct"
					+ " ON cbdo.cbct_id=cbct.cbct_id"
					+ " LEFT OUTER JOIN cadastro.imovel imov"
					+ " ON cbdo.imov_id=imov.imov_id"

					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua lagu"
					+ " ON imov.imov_id = lagu.lagu_id"
					+ " LEFT OUTER JOIN atendimentopublico.corte_tipo cotp"
					+ " ON lagu.cotp_id = cotp.cotp_id"
					+ " LEFT OUTER JOIN atendimentopublico.ordem_servico orse"
					+ " ON cbdo.cbdo_id = orse.cbdo_id"
					+ " LEFT OUTER JOIN atendimentopublico.servico_tipo svtp"
					+ " ON orse.svtp_id = svtp.svtp_id"

					+ " LEFT OUTER JOIN cadastro.localidade loca"
					+ " ON imov.loca_id=loca.loca_id"
					+ " LEFT OUTER JOIN cadastro.gerencia_regional greg"
					+ " ON loca.greg_id=greg.greg_id"
					+ " LEFT OUTER JOIN cadastro.setor_comercial stcm"
					+ " ON imov.stcm_id=stcm.stcm_id"
					+ " LEFT OUTER JOIN cadastro.quadra qdra"
					+ " ON imov.qdra_id=qdra.qdra_id"
					+ " LEFT OUTER JOIN micromedicao.rota rota"
					+ " ON qdra.rota_id=rota.rota_id"
					+ " LEFT OUTER JOIN cadastro.imovel_perfil iper"
					+ " ON imov.iper_id=iper.iper_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_esgoto_situacao lest"
					+ " ON cbdo.lest_id=lest.lest_id"
					+ " LEFT OUTER JOIN atendimentopublico.ligacao_agua_situacao LLAST"
					+ " ON cbdo.last_id=LLAST.last_id"
					+ " LEFT OUTER JOIN cadastro.empresa empr"
					+ " ON cbdo.empr_id=empr.empr_id"
					+ " LEFT OUTER JOIN atendimentopublico.atend_motivo_encmt amen"
					+ " ON cbdo.amen_id   =amen.amen_id"
					+ " WHERE caac.caac_id = :idCobrancaAtividadeAcaoCronograma "
					+ " GROUP BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos ,"
					+ "   cbdo.cbdo_icacimalimite ,"
					+ "   casit.cast_id ,"
					+ "   cdst.cdst_id ,"
					+ "   catg.catg_id ,"
					+ "   cbcm.cbcm_amreferencia ,"
					+ "   cbcr.cbcr_id ,"
					+ "   caac.caac_tmcomando ,"
					+ "   cbct.cbct_id ,"
					+ "   cbgr.cbgr_id ,"
					+ " 	 greg.greg_id ,"
					+ "   loca.loca_id ,"
					+ "   stcm.stcm_id ,"
					+ "   rota.rota_id ,"
					+ "   qdra.qdra_id ,"
					+ "   qdra.qdra_nnquadra ,"
					+ "   stcm.stcm_cdsetorcomercial ,"
					+ "   caac.caac_dtprevista ,"
					+ "   iper.iper_id ,"
					+ "   LLAST.last_id ,"
					+ "   lest.lest_id ,"
					+ "   epod.epod_id ,"
					+ "   cbac.cbac_id ,"
					+ "   empr.empr_id ,"
					+ "   amen.amen_id ,"
					+ "   loca.uneg_id ,"
					+ "   imov.last_id ,"
					+ "   imov.lest_id,"
					+ "   cbdo.demf_id,"

					+ "   case when (svtp.SVTP_NNCODIGOCONSTANTE = "
					+ ServicoTipo.TIPO_CORTE_LIGACAO_AGUA
					+ " and cbac.cbac_id = "
					+ CobrancaAcao.CORTE_FISICO
					+ " and casit.cast_id = "
					+ CobrancaAcaoSituacao.EXECUTADA
					+ ") then cotp.cotp_id end"

					+ " ORDER BY temp.fzst_id,"
					+ "   cbdo.cbdo_icantesapos,"
					+ "   cbdo.cbdo_icacimalimite,"
					+ "   casit.cast_id,"
					+ "   cdst.cdst_id,"
					+ "   catg.catg_id ,"
					+ "   epod.epod_id,"
					+ "   greg.greg_id,"
					+ "   loca.loca_id,"
					+ "   stcm.stcm_id,"
					+ "   rota.rota_id,"
					+ "   qdra.qdra_id,"
					+ "   qdra.qdra_nnquadra,"
					+ "   stcm.stcm_cdsetorcomercial,"
					+ "   iper.iper_id,"
					+ "   LLAST.last_id," + "   lest.lest_id";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("idDocEmissaoForma", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.addScalar("idCorteTipo", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoCronograma",
							idCobrancaAtividadeAcaoCronograma).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id),emp.id,moen.id, loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeCronograma cobAcaoAtivCron "
			// +
			// "left join cobAcaoAtivCron.cobrancaAcaoCronograma cobAcaoCronog "
			// + "left join cobAcaoCronog.cobrancaAcao cobAcao "
			// +
			// "left join cobAcaoCronog.cobrancaGrupoCronogramaMes cobGrupCronogramaMes "
			// + "left join cobGrupCronogramaMes.cobrancaGrupo cobGrupo "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivCron.id = :idCobrancaAtividadeAcaoCronograma "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// +
			// "cobAcaoSit.id,cobDebSit.id,categ.id,cobGrupCronogramaMes.anoMesReferencia,cobAcaoCronog.id,"
			// +
			// "cobAcaoAtivCron.comando,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,cobAcaoAtivCron.dataPrevista,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id";
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoCronograma",
			// idCobrancaAtividadeAcaoCronograma).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o sequencial de conta impress?o
	 * 
	 * @author S?vio Luiz
	 * @date 18/05/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarSequencialCobrancaDocumentoImpressao(
			Map<Integer, Integer> mapAtualizaSequencial)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta = "update gcom.cobranca.CobrancaDocumento "
				+ "set cbdo_nnsequencialimpressao =:sequencialCobrancaDocumento ,cbdo_tmultimaalteracao = :dataAtual "
				+ "where cbdo_id = :idCobrancaDocumento ";
		if (mapAtualizaSequencial != null && !mapAtualizaSequencial.isEmpty()) {
			Iterator iteMapAtualizaSequencia = mapAtualizaSequencial.keySet()
					.iterator();

			try {
				while (iteMapAtualizaSequencia.hasNext()) {
					Integer idCobrancaDocumento = (Integer) iteMapAtualizaSequencia
							.next();
					Integer sequencialCobrancaDocumento = mapAtualizaSequencial
							.get(idCobrancaDocumento);
					session.createQuery(consulta)
							.setInteger("idCobrancaDocumento",
									idCobrancaDocumento)
							.setInteger("sequencialCobrancaDocumento",
									sequencialCobrancaDocumento)
							.setDate("dataAtual", new Date()).executeUpdate();
				}
			} catch (HibernateException e) {
				throw new ErroRepositorioException(e, "Erro no Hibernate");
			} finally {
				HibernateUtil.closeSession(session);

			}
		}

	}

	/**
	 * Pesquisar rela??o de protocolos de documentos de cobran?a do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaCronograma(
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeCronograma caac "
					+ "inner join caac.cobrancaAcaoCronograma cbcr "
					+ "inner join cbcr.cobrancaAcao cbac"
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbcr.cobrancaGrupoCronogramaMes cbcm "
					+ "inner join cbdo.empresa empr "
					+ "where caac.id = :idCobrancaAcaoAtividadeCronograma "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeCronograma",
							idCobrancaAcaoAtividadeCronograma.intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar rela??o de protocolos de documentos de cobran?a do cronograma
	 * 
	 * @author Ana Maria
	 * @date 15/05/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarProtocoloDocumentoCobrancaEventual(
			Integer idCobrancaAcaoAtividadeComand)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " new "
					+ ProtocoloDocumentoCobrancaRelatorioHelper.class.getName()
					+ " ( "
					+ "greg.id, greg.nomeAbreviado, greg.nome, "
					+ "uneg.id, uneg.nome, loca.id, loca.descricao, "
					+ "cbdo.codigoSetorComercial, count(*), sum(cbdo.valorDocumento), "
					+ "min(cbdo.sequencialImpressao), max(cbdo.sequencialImpressao),"
					+ "empr.descricao) "
					+ "from CobrancaDocumento cbdo "
					+ "inner join cbdo.cobrancaAcaoAtividadeComando cacm "
					+ "inner join cacm.cobrancaAcao cbac "
					+ "inner join cbdo.localidade loca "
					+ "inner join loca.unidadeNegocio uneg "
					+ "inner join loca.gerenciaRegional greg "
					+ "inner join cbdo.empresa empr "
					+ "where cacm.id = :idCobrancaAcaoAtividadeComand "
					+ "group by empr.id, greg.id, greg.nomeAbreviado, greg.nome, uneg.id, uneg.nome, loca.id, loca.descricao, cbdo.codigoSetorComercial, empr.descricao "
					+ "order by empr.id, greg.id, uneg.id, loca.id, cbdo.codigoSetorComercial";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAcaoAtividadeComand",
							idCobrancaAcaoAtividadeComand.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera a cole??o de OS para o encerramento
	 * 
	 * [UC0478] - Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0007] - Determinar Situa??o da Ordem de Servi?o
	 * 
	 * @author S?vio Luiz
	 * @date 28/05/2007
	 * 
	 * @throws ControladorException
	 */
	public void atualizarParmsOS(Collection colecaoIdsOS,
			Integer idMotivoEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String atualizarOS = "";

			atualizarOS = "update gcom.atendimentopublico.ordemservico.OrdemServico "
					+ "set orse_tmultimaalteracao = :ultimaAlteracao, "
					+ "amen_id = :idMotivoEncerramento, "
					+ "orse_cdsituacao = :encerrado, "
					+ "orse_tmencerramento = :dataEncerramento ";

			atualizarOS = atualizarOS + " where orse_id in (:idsOrdemServico)";

			if (colecaoIdsOS.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + colecaoIdsOS.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) colecaoIdsOS, 999);

				int qtdQuebras = 999;
				int indice = colecaoIdsOS.size() / qtdQuebras;
				if (colecaoIdsOS.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE  "
							+ indice + " = " + particoes.get(i).size());

					session.createQuery(atualizarOS)
							.setParameterList("idsOrdemServico",
									particoes.get(i))
							.setTimestamp("ultimaAlteracao", new Date())
							.setInteger("idMotivoEncerramento",
									idMotivoEncerramento)
							.setShort("encerrado",
									OrdemServico.SITUACAO_ENCERRADO)
							.setTimestamp("dataEncerramento", new Date())
							.executeUpdate();
				}
			} else {
				session.createQuery(atualizarOS)
						.setParameterList("idsOrdemServico", colecaoIdsOS)
						.setTimestamp("ultimaAlteracao", new Date())
						.setInteger("idMotivoEncerramento",
								idMotivoEncerramento)
						.setShort("encerrado", OrdemServico.SITUACAO_ENCERRADO)
						.setTimestamp("dataEncerramento", new Date())
						.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os dados de documento item
	 * 
	 * @author S?vio Luiz
	 * @created 29/05/2006
	 * 
	 * @param matriculaImovel
	 *            Matr?cula do Imovel
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItem(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT "
					+ " contaG.indicadorHistorico,"// 0
					+ " guiaPagamentoG.indicadorHistorico,"// 1
					+ " debitoACobrarG.indicadorHistorico,"// 2
					+ " cdi.id,"// 3
					+ " cdi.valorItemCobrado,"// 4
					+ " contaG.id,"// 5
					+ " guiaPagamentoG.id,"// 6
					+ " debitoACobrarG.id "// 7
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cdi.contaGeral contaG "
					+ "LEFT JOIN cdi.guiaPagamentoGeral guiaPagamentoG "
					+ "LEFT JOIN cdi.debitoACobrarGeral  debitoACobrarG "
					+ "WHERE cd.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idRA
	 * @exception ErroRepositorioException
	 */
	public Object[] pesquisarRegistroAtendimentoTransferenciaDebitoCredito(
			Integer idRA) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " rgat.id," // 0
					+ " step.id,"// 1
					+ " step.descricao,"// 2
					+ " imov.id," // 3
					+ " rgat.codigoSituacao " // 4
					+ "FROM RegistroAtendimento rgat "
					+ "INNER JOIN rgat.solicitacaoTipoEspecificacao step "
					+ "LEFT JOIN rgat.imovel imov "
					+ "WHERE rgat.id = :idRA AND imov.indicadorExclusao <> :imovelExclusao ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idRA", idRA)
					.setShort("imovelExclusao", Imovel.IMOVEL_EXCLUIDO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC00609] Transferencia de Debitos/Creditos
	 * 
	 * [FS0004] Validar Registro Atendimento
	 * 
	 * @author Raphael Rossiter
	 * @created 05/06/2007
	 * 
	 * @param idSolicitacaoTipoEspecificacao
	 * @exception ErroRepositorioException
	 */
	public EspecificacaoTipoValidacao pesquisarEspecificacaoTipoValidacaoTransferenciaDebitoCredito(
			Integer idSolicitacaoTipoEspecificacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		EspecificacaoTipoValidacao retorno = null;

		String consulta = null;

		try {

			consulta = "SELECT "
					+ " estv " // 0
					+ "FROM EspecificacaoTipoValidacao estv "
					+ "INNER JOIN estv.solicitacaoTipoEspecificacao step "
					+ "WHERE step.id = :idSolicitacaoTipoEspecificacao AND "
					+ " estv.codigoConstante = :transferenciaDebito ";

			retorno = (EspecificacaoTipoValidacao) session
					.createQuery(consulta)
					.setInteger("idSolicitacaoTipoEspecificacao",
							idSolicitacaoTipoEspecificacao)
					.setCharacter("transferenciaDebito",
							EspecificacaoTipoValidacao.TRANSFERENCIA_DEBITO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisar rela??o de parcelamento
	 * 
	 * @author Ana Maria
	 * @date 01/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<RelacaoParcelamentoRelatorioHelper> pesquisarRelacaoParcelamento(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento)
			throws ErroRepositorioException {

		Collection<RelacaoParcelamentoRelatorioHelper> retorno = null;
		Collection<Object[]> retornoConsulta = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		String groupBy = " GROUP BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( l.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id as idMunicipio, \n  muni.muni_nmmunicipio as municipio";
			groupBy += "muni.muni_nmmunicipio, muni.muni_id, ";
			orderBy += " muni.muni_nmmunicipio, ";
		}
		Query query = null;

		Map parameters = new HashMap();

		try {
			consulta = " select pst.pcst_dsparcelamentosituacao AS situacao,"// 0
					+ " to_char(p.loca_id,'0000')||' - '||l.loca_nmlocalidade AS localidade,"// 1
					+ " UPPER(c.clie_nmcliente)AS cliente,"// 2
					+ " cf.cfon_cdddd AS ddd,"// 3
					+ " cf.cfon_nnfone AS fone,"// 4
					+ " substr(to_char(p.imov_id,'00000000'),1,8) ||'.'|| substr(to_char(p.imov_id,'00000000'),9,1) AS matricula,"// 5
					+ " p.parc_id AS idParcelamento,"// 6
					+ " p.parc_tmparcelamento AS dataParcelamento,"// 7
					+ " to_char(cnta.cnta_dtvencimentoconta, 'DD')AS vencimento,"// 8
					+ " p.parc_vldebitoatualizado AS valorDebito,"// 9
					+ " p.parc_vlentrada AS entrada,"// 10
					+ " p.parc_vlprestacao AS valorPrestacao,"// 11
					+ " p.parc_nnprestacoes AS numeroPrestacao,"// 12
					+ " p.loca_id as idLocalidade,"// 13
					+ " greg.greg_id as idGerencia, greg.greg_nmabreviado as gerencia,"// 14,15
					+ " unid.unid_dsunidade as unidade"// 16
					+ selectMunicipio
					+ " from cobranca.parcelamento p"
					+ " inner join faturamento.conta cnta ON p.imov_id = cnta.imov_id and p.parc_amreferenciafaturamento = cnta.cnta_amreferenciaconta"
					+ " inner join cadastro.cliente c ON c.clie_id = p.clie_id"
					+ " left join seguranca.usuario usur ON usur.usur_id = p.usur_id"
					+ " left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id"
					+ " inner join cadastro.localidade l ON p.loca_id = l.loca_id"
					+ joinMunicipio
					+ " inner join cadastro.gerencia_regional greg on l.greg_id = greg.greg_id"
					+ " inner join cadastro.unidade_negocio uneg on l.uneg_id = uneg.uneg_id"
					+ " inner join cobranca.parcelamento_situacao pst ON p.pcst_id = pst.pcst_id"
					+ " left join cadastro.cliente_fone cf ON c.clie_id = cf.clie_id and cf.cfon_icfonepadrao = 1"
					+ " inner join cadastro.imovel imov ON p.imov_id = imov.imov_id "
					+ " where 1=1";

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getParcelamentoSituacao().getId() != null) {
				consulta += " and p.pcst_id = :situacao ";
				parameters.put("situacao", filtrarRelacaoParcelamento
						.getParcelamento().getParcelamentoSituacao().getId());
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and p.loca_id = :idLocalidade ";
				parameters.put("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade());
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and l.muni_idprincipal IN ( :idMunicipios )";
				parameters.put("idMunicipios", filtrarRelacaoParcelamento
						.getColecaoMunicipiosAssociados());
				if (!temLocalidade) {
					consulta += " and p.loca_id = l.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and p.parc_cdsetorcomercial = :codigoSetorComercial ";
				parameters.put("codigoSetorComercial",
						filtrarRelacaoParcelamento.getParcelamento()
								.getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and p.parc_nnquadra = :numeroQuadra ";
				parameters.put("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if (filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null
					&& filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null) {
				consulta += " and p.parc_tmparcelamento between (:dataParcelamentoInicial) and (:dataParcelamentoFinal) ";
				parameters
						.put("dataParcelamentoInicial",
								filtrarRelacaoParcelamento
										.getDataParcelamentoInicial());
				parameters.put("dataParcelamentoFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getValorDebitoInicial() != null
					&& filtrarRelacaoParcelamento.getValorDebitoFinal() != null) {
				consulta += " and p.parc_vldebitoatualizado between (:valorDebitoInicial) and (:valorDebitoFinal) ";
				parameters.put("valorDebitoInicial",
						filtrarRelacaoParcelamento.getValorDebitoInicial());
				parameters.put("valorDebitoFinal",
						filtrarRelacaoParcelamento.getValorDebitoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdGerencia() != null) {
				consulta += " and greg.greg_id = :idGerencia ";
				parameters.put("idGerencia",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null) {
				consulta += " and uneg.uneg_id in (:idUnidadeNegocio) ";
				parameters.put("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdsMotivoDesfazimento() != null
					&& !filtrarRelacaoParcelamento.getIdsMotivoDesfazimento()
							.isEmpty()) {
				consulta += " and p.pmdz_id in (:idsMotivoDesfazimento) ";
				parameters.put("idsMotivoDesfazimento",
						filtrarRelacaoParcelamento.getIdsMotivoDesfazimento());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {
				consulta += " and imov.iper_id in (:idsPerfisImovel) ";
				parameters.put("idsPerfisImovel",
						filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and p.usur_id = :idUsuario ";
			}

			// Cole??o de Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional ";
				parameters
						.put("idUnidadeOrganizacional",
								filtrarRelacaoParcelamento
										.getIdUnidadeOrganizacional());
			}

			consulta += groupBy
					+ "p.parc_id, p.loca_id, l.loca_nmlocalidade, c.clie_nmcliente, pst.pcst_dsparcelamentosituacao, "
					+ "p.imov_id, p.parc_tmparcelamento, cnta.cnta_dtvencimentoconta, p.parc_vldebitoatualizado, p.parc_vlentrada, "
					+ "p.parc_vlprestacao, p.parc_nnprestacoes, cf.cfon_cdddd, cf.cfon_nnfone, greg.greg_id, greg.greg_nmabreviado, unid.unid_dsunidade "
					+ orderBy
					+ " greg.greg_id, l.loca_nmlocalidade, vencimento  ASC, "
					+ "valorDebito DESC, cliente, numeroPrestacao ASC ";

			query = session.createQuery(consulta);

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta)
						.addScalar("situacao", Hibernate.STRING)
						.addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING)
						.addScalar("ddd", Hibernate.STRING)
						.addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP)
						.addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
						.addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER)
						.addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING)
						.addScalar("unidade", Hibernate.STRING)
						.addScalar("idMunicipio", Hibernate.INTEGER)
						.addScalar("municipio", Hibernate.STRING);

			} else {
				query = session.createSQLQuery(consulta)
						.addScalar("situacao", Hibernate.STRING)
						.addScalar("localidade", Hibernate.STRING)
						.addScalar("cliente", Hibernate.STRING)
						.addScalar("ddd", Hibernate.STRING)
						.addScalar("fone", Hibernate.STRING)
						.addScalar("matricula", Hibernate.STRING)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.addScalar("dataParcelamento", Hibernate.TIMESTAMP)
						.addScalar("vencimento", Hibernate.STRING)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
						.addScalar("numeroPrestacao", Hibernate.SHORT)
						.addScalar("idLocalidade", Hibernate.INTEGER)
						.addScalar("idGerencia", Hibernate.INTEGER)
						.addScalar("gerencia", Hibernate.STRING)
						.addScalar("unidade", Hibernate.STRING);
			}

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}

			}

			retornoConsulta = query.list();

			if (retornoConsulta.size() > 0) {
				retorno = new ArrayList();
				RelacaoParcelamentoRelatorioHelper helper = null;
				for (Iterator iter = retornoConsulta.iterator(); iter.hasNext();) {
					Object[] element = (Object[]) iter.next();
					helper = new RelacaoParcelamentoRelatorioHelper();
					helper.setSituacao((String) element[0]);
					helper.setLocalidade((String) element[1]);
					helper.setCliente((String) element[2]);
					if (element[3] != null) {
						helper.setDdd((String) element[3]);
						helper.setTelefone((String) element[4]);
					}
					helper.setMatricula((String) element[5]);
					helper.setParcelamento((Integer) element[6]);
					helper.setDataParcelamento((Date) element[7]);
					helper.setVencimento((String) element[8]);
					helper.setDebitoTotal((BigDecimal) element[9]);
					helper.setValorEntrada((BigDecimal) element[10]);
					helper.setValorParcelamento((BigDecimal) element[11]);
					helper.setNumeroParcelamento((Short) element[12]);
					helper.setIdLocalidade((Integer) element[13]);
					helper.setIdGerencia((Integer) element[14]);
					helper.setGerencia((String) element[15]);
					if (element[16] != null) {
						helper.setUnidade((String) element[16]);
					}

					if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados())) {
						helper.setIdMunicipio((Integer) element[17]);
						helper.setMunicipio((String) element[18]);
					}
					retorno.add(helper);
				}
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0XXXX] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * @author S?vio Luiz, Anderson Italo
	 * @created 15/06/2006, 25/02/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarCobrancaAcaoAtividadeComandoSemRealizacao()
			throws ErroRepositorioException {

		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select cacm.id,ca.id,servTipo.id,doctipo.id,cacm.dataEncerramentoPrevista,"
					+ " cacm.realizacao, cacm.comando "
					+ "from CobrancaAcaoAtividadeComando cacm "
					+ " inner join cacm.cobrancaAcao ca"
					+ " left join ca.servicoTipo servTipo "
					+ " left join ca.documentoTipo doctipo "
					+ "where cacm.dataEncerramentoRealizada is null and cacm.realizacao is not null";

			// executa o hql
			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta).list()));

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das a??es de cobran?a
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobran?a
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author S?vio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<DadosPesquisaCobrancaDocumentoHelper> pesquisarCobrancaDocumentoEventual(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id,"
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.percentualValorMinimoPagoParceladoCancelado, "
					+ "cobCrit.percentualQuantidadeMinimoPagoParceladoCancelado, "
					+ "cobCrit.valorLimitePrioridade)  "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando "
					+ "order by cobrancaDocumento.id";

			retorno = session
					.createQuery(consulta)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das a??es de cobran?a
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobran?a
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author S?vio Luiz
	 * @date 18/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarOrdemServicoEventual(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select orse.orse_id as idOS,"
					+ " orse.orse_cdsituacao as codigoOS,"
					+ " orse.orse_dtfiscalizacaosituacao as dataFiscalizacao,"
					+ " orse.orse_tmencerramento as dataEncerramento,"
					+ " cob.cbdo_id as idCobDocumento,"
					+ " cob.cbdo_vldocumento as valorDocumento,"
					+ " cobCrit.cbct_pcvlminimopgparccanc as pec,"
					+ " cobCrit.cbct_pcqtminimopgparccanc as qdt,"
					+ " cobCrit.cbct_vllimiteprioridade as valorLimite,"
					+ " orse.fzst_id as idFiscalizacaoSit,"
					+ " atMotEnc.amen_icexecucao as indicadorExecucao,"
					+ " imov.imov_id as idImovel,"
					+ " imov.loca_id as idLocalidade, "
					+ " atMotEnc.amen_id as idMotivoEncerramento "
					+ "from atendimentopublico.ordem_servico orse "
					+ "inner join cobranca.cobranca_documento cob on cob.cbdo_id = orse.cbdo_id "
					+ "    and cob.cacm_id = :idCobrancaAtividadeAcaoComando "
					+ "left join cobranca.cobranca_criterio cobCrit "
					+ "     on cobCrit.cbct_id = cob.cbct_id "
					+ "left join cadastro.imovel imov "
					+ "      on imov.imov_id = orse.imov_id "
					+ "left join  atendimentopublico.atend_motivo_encmt atMotEnc "
					+ "      on atMotEnc.amen_id = orse.amen_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("codigoOS", Hibernate.SHORT)
					.addScalar("dataFiscalizacao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("idCobDocumento", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("pec", Hibernate.BIG_DECIMAL)
					.addScalar("qdt", Hibernate.BIG_DECIMAL)
					.addScalar("valorLimite", Hibernate.BIG_DECIMAL)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indicadorExecucao", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idMotivoEncerramento", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando)

					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das a??es de cobran?a
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void deletarResumoCobrancaAcaoEventual(int idCobrancaAcaoCronograma)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String consulta;

		try {
			consulta = "delete ResumoCobrancaAcaoEventual resumoCobrancaAcaoEventual "
					+ "where resumoCobrancaAcaoEventual.cobrancaAcaoAtividadeComando.id = :idCobrancaAcaoCronograma ";

			session.createQuery(consulta)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma).executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Pesquisa os dados de cobranca documento agrupado para pegar a quantidade
	 * e o valor dos documentos
	 * 
	 * @author S?vio Luiz
	 * @date 19/10/2006
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosCobrancaDocumentoEventualAgrupadoPorDataPrevista(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = " select temp.fzst_id as idFiscalizacaoSit,"
					+ " cbdo.cbdo_icantesapos as indAntesApos,"
					+ " cbdo.cbdo_icacimalimite as indAcimaLimite,"
					+ " casit.cast_id as idCobrancaAcaoSit,"
					+ " cdst.cdst_id as idCobrancaDebitoSit,"
					+ " catg.catg_id as idCategoria,"
					+ " epod.epod_id as idEsferaPoder,"
					+ " cbct.cbct_id as idCobrancaCriterio,"
					+ " cbgr.cbgr_id as idCobrancaGrupo,"
					+ " greg.greg_id as idGerencia,"
					+ " loca.loca_id as idLocalidade,"
					+ " stcm.stcm_id as idSetor,"
					+ " rota.rota_id as idRota,"
					+ " qdra.qdra_id as idQuadra,"
					+ " qdra.qdra_nnquadra as numeroQuadra,"
					+ " stcm.stcm_cdsetorcomercial as codigoSetor,"
					+ " iper.iper_id as idPerfilImovel,"
					+ " coalesce(llast.last_id,imov.last_id) as idLigacaoAguaSit,"
					+ " coalesce(lest.lest_id,imov.lest_id) as idLigacaoEsgotoSit,"
					+ " empr.empr_id as idEmpresa,"
					+ " amen.amen_id as idAtendMotivoEnc,"
					+ " loca.uneg_id as idUnidadeNegocio,"
					+ " count(cbdo.cbdo_id) as qtdeCobrancaDocumento,"
					+ " sum(cbdo.cbdo_vldocumento) as valorCobrancaDoc"
					+ " from cobranca.cobranca_documento cbdo"
					+ " left outer join atendimentopublico.ordem_servico orse on cbdo.cbdo_id = orse.cbdo_id"
					+ " left outer join atendimentopublico.fiscalizacao_situacao temp on temp.fzst_id = orse.fzst_id"
					+ " left outer join cadastro.esfera_poder epod                         on cbdo.epod_id=epod.epod_id"
					+ " left outer join cobranca.cobranca_acao_situacao casit             on cbdo.cast_id=casit.cast_id"
					+ " left outer join cobranca.cobranca_debito_situacao cdst             on cbdo.cdst_id=cdst.cdst_id"
					+ " left outer join cadastro.categoria catg                         on cbdo.catg_id=catg.catg_id"
					+ " left outer join cobranca.cobranca_acao_ativ_cmd cacm     on cbdo.cacm_id=cacm.cacm_id"
					+ " left outer join cobranca.cobranca_acao cbac                     on cacm.cbac_id=cbac.cbac_id"
					+ " left outer join cobranca.cobranca_criterio cbct                 on cbdo.cbct_id=cbct.cbct_id"
					+ " left outer join cadastro.imovel imov                             on cbdo.imov_id=imov.imov_id"
					+ " left outer join cadastro.localidade loca                         on imov.loca_id=loca.loca_id"
					+ " left outer join cadastro.gerencia_regional greg                 on loca.greg_id=greg.greg_id"
					+ " left outer join cadastro.setor_comercial stcm                     on imov.stcm_id=stcm.stcm_id"
					+ " left outer join cadastro.quadra qdra                             on imov.qdra_id=qdra.qdra_id"
					+ " left outer join micromedicao.rota rota                             on qdra.rota_id=rota.rota_id"
					+ " left outer join cobranca.cobranca_grupo cbgr                     on rota.cbgr_id=cbgr.cbgr_id"
					+ " left outer join cadastro.imovel_perfil iper                     on imov.iper_id=iper.iper_id"
					+ " left outer join atendimentopublico.ligacao_esgoto_situacao lest on cbdo.lest_id= lest.lest_id"
					+ " left outer join atendimentopublico.ligacao_agua_situacao llast     on cbdo.last_id= llast.last_id"
					+ " left outer join cadastro.empresa empr                             on cbdo.empr_id=empr.empr_id"
					+ " left outer join atendimentopublico.atend_motivo_encmt amen on cbdo.amen_id=amen.amen_id"
					+ " where "
					+ "  cacm.cacm_id = :idCobrancaAtividadeAcaoComando"
					+ " group by"
					+ " temp.fzst_id ,cbdo.cbdo_icantesapos ,cbdo.cbdo_icacimalimite ,"
					+ " casit.cast_id ,cdst.cdst_id ,catg.catg_id ,cacm.cacm_dtencerramentoprevista ,"
					+ " cbct.cbct_id ,cbgr.cbgr_id ,greg.greg_id ,loca.loca_id ,stcm.stcm_id ,"
					+ " rota.rota_id ,qdra.qdra_id ,qdra.qdra_nnquadra ,stcm.stcm_cdsetorcomercial ,"
					+ " iper.iper_id ,llast.last_id ,lest.lest_id ,epod.epod_id ,cbac.cbac_id ,empr.empr_id ,"
					+ " amen.amen_id ,loca.uneg_id ,imov.last_id ,imov.lest_id"
					+ " order by"
					+ " temp.fzst_id,cbdo.cbdo_icantesapos,cbdo.cbdo_icacimalimite,casit.cast_id,"
					+ " cdst.cdst_id,catg.catg_id,epod.epod_id,greg.greg_id,loca.loca_id,stcm.stcm_id,"
					+ " rota.rota_id,qdra.qdra_id,qdra.qdra_nnquadra,stcm.stcm_cdsetorcomercial,"
					+ " iper.iper_id, llast.last_id,lest.lest_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idFiscalizacaoSit", Hibernate.INTEGER)
					.addScalar("indAntesApos", Hibernate.SHORT)
					.addScalar("indAcimaLimite", Hibernate.SHORT)
					.addScalar("idCobrancaAcaoSit", Hibernate.INTEGER)
					.addScalar("idCobrancaDebitoSit", Hibernate.INTEGER)
					.addScalar("idCategoria", Hibernate.INTEGER)
					.addScalar("idEsferaPoder", Hibernate.INTEGER)
					.addScalar("idCobrancaCriterio", Hibernate.INTEGER)
					.addScalar("idCobrancaGrupo", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idPerfilImovel", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSit", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSit", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("idAtendMotivoEnc", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("qtdeCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("valorCobrancaDoc", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

			// consulta =
			// "select new gcom.cobranca.bean.DadosCobrancaDocumentoHelper(fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// +
			// "imovPerfil.id,coalesce(ligAguaSit.id, imov.ligacaoAguaSituacao.id),"
			// +
			// "coalesce(ligEsgSit.id, imov.ligacaoEsgotoSituacao.id), emp.id,moen.id,loc.unidadeNegocio.id,count(cobrancaDocumento.id),sum(cobrancaDocumento.valorDocumento)) "
			// + "from CobrancaDocumento cobrancaDocumento "
			// +
			// "left join cobrancaDocumento.fiscalizacaoSituacao fiscSituacao "
			// + "left join cobrancaDocumento.esferaPoder esfPoder "
			// + "left join cobrancaDocumento.cobrancaAcaoSituacao cobAcaoSit "
			// + "left join cobrancaDocumento.cobrancaDebitoSituacao cobDebSit "
			// + "left join cobrancaDocumento.categoria categ "
			// +
			// "left join cobrancaDocumento.cobrancaAcaoAtividadeComando cobAcaoAtivComando "
			// + "left join cobAcaoAtivComando.cobrancaAcao cobAcao "
			// + "left join cobrancaDocumento.cobrancaCriterio cobCrit "
			// + "left join cobrancaDocumento.imovel imov "
			// + "left join imov.localidade loc "
			// + "left join loc.gerenciaRegional gerenReg "
			// + "left join imov.setorComercial setComercial "
			// + "left join imov.quadra quad "
			// + "left join quad.rota rot "
			// + "left join rot.cobrancaGrupo cobGrupo "
			// + "left join imov.imovelPerfil imovPerfil "
			// + "left join cobrancaDocumento.ligacaoEsgotoSituacao ligEsgSit "
			// + "left join cobrancaDocumento.ligacaoAguaSituacao ligAguaSit "
			// + "left join cobrancaDocumento.empresa emp "
			// + "left join cobrancaDocumento.motivoEncerramento moen "
			// +
			// "where cobAcaoAtivComando.id = :idCobrancaAtividadeAcaoComando "
			// +
			// "group by fiscSituacao.id,cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,categ.id,"
			// +
			// "cobAcaoAtivComando.dataEncerramentoPrevista,cobCrit.id,cobGrupo.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// +
			// "quad.id,quad.numeroQuadra,setComercial.codigo,imovPerfil.id,ligAguaSit.id,ligEsgSit.id,esfPoder.id,"
			// +
			// "cobAcao.id,emp.id, moen.id, loc.unidadeNegocio.id, imov.ligacaoAguaSituacao.id, imov.ligacaoEsgotoSituacao.id  "
			// + "order by fiscSituacao.id,"
			// +
			// "cobrancaDocumento.indicadorAntesApos,cobrancaDocumento.indicadorLimite,"
			// + "cobAcaoSit.id,cobDebSit.id,"
			// +
			// "categ.id,esfPoder.id,gerenReg.id,loc.id,setComercial.id,rot.id,"
			// + "quad.id,quad.numeroQuadra,setComercial.codigo,"
			// + "imovPerfil.id,ligAguaSit.id,ligEsgSit.id ";
			//
			// retorno = session.createQuery(consulta).setInteger(
			// "idCobrancaAtividadeAcaoComando",
			// idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar os resumos das a??es de cobran?a
	 * eventuais.
	 * 
	 * [UC0XXXX] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * 
	 * @author S?vio Luiz
	 * @date 19/06/2007
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoAtividadeComando(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizar;

		try {
			atualizar = "update gcom.cobranca.CobrancaAcaoAtividadeComando "
					+ " set cacm_dtencerramentorealizada = :dataRealizacao,cacm_tmultimaalteracao = :dataAtual "
					+ " where cacm_id = :idCobrancaAtividadeAcaoComando";

			session.createQuery(atualizar)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando)
					.setDate("dataRealizacao", new Date())
					.setTimestamp("dataAtual", new Date()).executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
			// } catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			// throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Gerar Curva ABC de Debitos
	 * 
	 * [UC0621] Gerar Curva ABC de Debitos
	 * 
	 * @author Ivan S?rgio
	 * @date 01/08/2007
	 * 
	 */
	public Collection gerarCurvaAbcDebitos(String classificacao,
			String indicadorImovelMedicaoIndividualizada,
			String indicadorImovelParalizacaoFaturamentoCobranca,
			String[] gerenciaRegional, String idLocalidadeInicial,
			String idLocalidadeFinal, String idSetorComercialInicial,
			String idSetorComercialFinal, String idMunicipio,
			String[] situacaoLigacaoAgua, String[] situacaoLigacaoEsgoto,
			String intervaloConsumoMinimoFixadoEsgotoInicial,
			String intervaloConsumoMinimoFixadoEsgotoFinal,
			String indicadorMedicao, String idTipoMedicao,
			String idPerfilImovel, String idTipoCategoria, String[] categoria,
			String idSubCategoria) throws ErroRepositorioException {

		List retorno = null;
		Session session = HibernateUtil.getSession();
		String hqlAux = "";
		String orderBy = "";
		String joinMunicipio = " left join localidade.municipio municipio ";
		if (idMunicipio != null && !idMunicipio.equals("")) {
			joinMunicipio = " inner join localidade.municipio municipio ";
		}
		boolean finaliza = false;

		try {
			String hql = "select distinct"
					+ "	imovel.id, "
					+ "	ligacaoAguaSituacao.id, "
					+ "	ligacaoAgua.dataCorte, "
					+ "	ligacaoAgua.dataSupressao, "
					+ "	gerenciaRegional.id, "
					+ "	gerenciaRegional.nomeAbreviado, "
					+ "	gerenciaRegional.nome, "
					+ "	localidade.id, "
					+ "	localidade.descricao, "
					+ "   municipio.id, "
					+ "	municipio.nome, "
					+ "	setorComercial.id, "
					+ "	setorComercial.codigo, "
					+ "	setorComercial.descricao, "
					+ "	categoria.descricao, "
					+ "	subcategoria.descricao "
					+

					"from "
					+ "	ImovelSubcategoria imovelSubcategoria "
					+ "	inner join imovelSubcategoria.comp_id.imovel imovel "
					+ "	left  join imovelSubcategoria.comp_id.subcategoria subcategoria "
					+ "	left  join subcategoria.categoria categoria "
					+ " 	inner join imovel.localidade localidade "
					+ joinMunicipio
					+ " 	inner join localidade.gerenciaRegional gerenciaRegional "
					+ "	inner join imovel.setorComercial setorComercial "
					+ "	left  join imovel.ligacaoAguaSituacao ligacaoAguaSituacao "
					+ " 	left  join imovel.ligacaoAgua ligacaoAgua "
					+ " 	left  join imovel.ligacaoEsgotoSituacao ligacaoEsgotoSituacao "
					+ " 	left  join imovel.ligacaoEsgoto ligacaoEsgoto "
					+ "	left  join ligacaoAgua.hidrometroInstalacaoHistorico hidrometroInstalacaoHistorico "
					+ " 	left  join imovel.hidrometroInstalacaoHistorico hidrometroInstalacaoHistoricoImovel "
					+ " 	left  join imovel.imovelPerfil imovelPerfil "
					+ "   Where ";

			// Aplica as Condicoes da consulta
			// **************************************

			// Classificacao
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "";
			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = " Order By gerenciaRegional.id ";
			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = " Order By localidade.id ";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = " Order By setorComercial.id ";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = " Order By municipio.nome ";
			}

			// gerenciaRegional
			if ((gerenciaRegional != null) && (gerenciaRegional.length > 0)) {
				if (gerenciaRegional.length == 1
						&& !gerenciaRegional[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "gerenciaRegional.id = " + gerenciaRegional[0]
							+ " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < gerenciaRegional.length; i++) {
						if (!gerenciaRegional[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += gerenciaRegional[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "gerenciaRegional.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Localidade
			if ((idLocalidadeInicial != null && !idLocalidadeInicial.equals(""))
					&& (idLocalidadeFinal != null && !idLocalidadeFinal
							.equals(""))) {

				hql += "localidade.id >= " + idLocalidadeInicial + " and "
						+ "localidade.id <= " + idLocalidadeFinal + " and ";
				finaliza = true;
			}

			// Setor Comercial Inicial e Final
			if ((idSetorComercialInicial != null && !idSetorComercialInicial
					.equals(""))
					&& (idSetorComercialFinal != null && !idSetorComercialFinal
							.equals(""))) {

				hql += "setorComercial.id >= " + idSetorComercialInicial
						+ " and " + "setorComercial.id <= "
						+ idSetorComercialFinal + " and ";
				finaliza = true;
			}

			// Munic?pio
			if ((idMunicipio != null && !idMunicipio.equals(""))) {
				hql += "municipio.id = " + idMunicipio + " and ";
				finaliza = true;
			}

			// Imoveis com Medicao Individualizada
			if (indicadorImovelMedicaoIndividualizada.equals("1")) {
				hql += "imovel.imovelCondominio is not null and ";
				finaliza = true;
			}

			// Imoveis com Paralizacao de Faturamento/Cobranca
			if (indicadorImovelParalizacaoFaturamentoCobranca.equals("1")) {
				hql += "( (imovel.faturamentoSituacaoTipo.id in (1, 4, 5)) or ";
				// hql += "(imovel.cobrancaSituacao.id in (5, 7, 8, 9)) ) and ";
				hql += " (exists( select ics.id from ImovelCobrancaSituacao ics "
						+ " where ics.imovel.id = imovel.id  and ics.dataRetiradaCobranca is null "
						+ " and ics.cobrancaSituacao.id in (5, 7, 8, 9))) ) and ";
				finaliza = true;
			}

			// Situacao da Ligacao de Agua
			if ((situacaoLigacaoAgua != null)
					&& (situacaoLigacaoAgua.length > 0)) {
				if (situacaoLigacaoAgua.length == 1
						&& !situacaoLigacaoAgua[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "ligacaoAguaSituacao.id = " + situacaoLigacaoAgua[0]
							+ " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoAgua.length; i++) {
						if (!situacaoLigacaoAgua[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += situacaoLigacaoAgua[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoAguaSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Situacao da Ligacao de Esgoto
			if ((situacaoLigacaoEsgoto != null)
					&& (situacaoLigacaoEsgoto.length > 0)) {
				if (situacaoLigacaoEsgoto.length == 1
						&& !situacaoLigacaoEsgoto[0].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

					hql += "ligacaoEsgotoSituacao.id = "
							+ situacaoLigacaoEsgoto[0] + " and ";
					finaliza = true;
				} else {
					for (int i = 0; i < situacaoLigacaoEsgoto.length; i++) {
						if (!situacaoLigacaoEsgoto[i].trim().equalsIgnoreCase(
								new Integer(
										ConstantesSistema.NUMERO_NAO_INFORMADO)
										.toString())) {

							hqlAux += situacaoLigacaoEsgoto[i].toString() + ",";
						}
					}

					if (!hqlAux.equals("")) {
						hql += "ligacaoEsgotoSituacao.id in (" + hqlAux;
						hqlAux = "";

						// Retira a ultima virgula e finaliza a condicao
						hql = hql.substring(0, hql.length() - 1) + ") and ";
						finaliza = true;
					}
				}
			}

			// Intervalo de Consumo Minimo Fixado de Esgoto
			if ((intervaloConsumoMinimoFixadoEsgotoInicial != null)
					&& (!intervaloConsumoMinimoFixadoEsgotoInicial.equals(""))
					&& (intervaloConsumoMinimoFixadoEsgotoFinal != null)
					&& (!intervaloConsumoMinimoFixadoEsgotoFinal.equals(""))) {

				hql += "ligacaoEsgoto.consumoMinimo >= "
						+ intervaloConsumoMinimoFixadoEsgotoInicial + " and ";
				hql += "ligacaoEsgoto.consumoMinimo <= "
						+ intervaloConsumoMinimoFixadoEsgotoFinal + " and ";
				finaliza = true;
			}

			// indicador medi??o
			if (indicadorMedicao != null
					&& indicadorMedicao.equals("comMedicao")) {
				// tipo medicao
				// [SF0001 - Selecionar os Imoveis por Tipo de Medicao]
				if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.LIGACAO_AGUA
								.toString())) {
					hql += "hidrometroInstalacaoHistorico.id is not null and ";
					finaliza = true;
				} else if (idTipoMedicao != null
						&& idTipoMedicao.equals(MedicaoTipo.POCO.toString())) {
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null and ";
					finaliza = true;
				} else {
					hql += "(hidrometroInstalacaoHistorico.id is not null or ";
					hql += "hidrometroInstalacaoHistoricoImovel.id is not null) and ";
					finaliza = true;
				}
			} else if (indicadorMedicao != null
					&& indicadorMedicao.equals("semMedicao")) {
				hql += "(hidrometroInstalacaoHistorico.id is null and ";
				hql += "hidrometroInstalacaoHistoricoImovel.id is null) and ";
				finaliza = true;
			}

			// imovel Perfil
			if (idPerfilImovel != null
					&& !idPerfilImovel.equals("")
					&& !idPerfilImovel.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

				hql += "imovelPerfil.id = " + idPerfilImovel + " and ";
				finaliza = true;
			}

			// categoria
			if (categoria == null) {

				if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PARTICULAR
								.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT
							+ ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO
								.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else if ((categoria.length == 1)
					&& (categoria[0].trim().equalsIgnoreCase(new Integer(
							ConstantesSistema.NUMERO_NAO_INFORMADO).toString()))) {

				if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PARTICULAR
								.toString())) {
					hql += "( (categoria.id = " + Categoria.RESIDENCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.COMERCIAL_INT
							+ ") or ";
					hql += "  (categoria.id = " + Categoria.INDUSTRIAL_INT
							+ ") ) and ";
					finaliza = true;
				} else if (idTipoCategoria != null
						&& !idTipoCategoria.equals("")
						&& idTipoCategoria.equals(CategoriaTipo.PUBLICO
								.toString())) {
					hql += "categoria.id = " + Categoria.PUBLICO_INT + " and ";
					finaliza = true;
				}

			} else {
				for (int i = 0; i < categoria.length; i++) {
					if (!categoria[i].trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

						hqlAux += categoria[i].toString() + ",";
					}
				}

				if (!hqlAux.equals("")) {
					hql += "categoria.id in (" + hqlAux;
					hqlAux = "";

					// Retira a ultima virgula e finaliza a condicao
					hql = hql.substring(0, hql.length() - 1) + ") and ";
					finaliza = true;
				}
			}

			// SubCategoria
			if (idSubCategoria != null
					&& !idSubCategoria.equals("")
					&& !idSubCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {
				hql += "subcategoria.id = " + idSubCategoria + " and ";
				finaliza = true;
			} else if (idTipoCategoria != null
					&& !idTipoCategoria.equals("")
					&& !idTipoCategoria.trim().equalsIgnoreCase(
							new Integer(ConstantesSistema.NUMERO_NAO_INFORMADO)
									.toString())) {

				hql += "subcategoria.categoria.id = categoria.id and ";
				hql += "subcategoria.id = imovelSubcategoria.comp_id.subcategoria.id and ";
				finaliza = true;
			}

			// Finaliza a condicao
			if (finaliza) {
				hql = hql.substring(0, hql.length() - 5) + orderBy;
			} else {
				hql = hql.substring(0, hql.length() - 9) + orderBy;
			}
			retorno = session.createQuery(hql).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Ana Maria Data: 08/07/2007 Pesquisa os ID dos Imov?is pelo Cliente
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @return Cole??o de Ids dos Im?veis
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdsImoveisCliente(String codigoCliente)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imov.id " + "from ClienteImovel clieImov "
					+ "inner join clieImov.imovel imov "
					+ "inner join clieImov.cliente clie "
					+ "where clie.id = :codigoCliente";

			retorno = session
					.createQuery(consulta)
					.setInteger("codigoCliente",
							new Integer(codigoCliente).intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente Obtem os d?bitos dos im?veis
	 * Author: Ana Maria Data: 28/06/2006
	 * 
	 * @param idsImoveis
	 *            Matriculas dos Imoveis
	 * @param contaSituacaoNormal
	 *            Situa??o Normal de Conta
	 * @param contaSituacaoRetificada
	 *            Situa??o Retificada de Conta
	 * @param contaSituacaoIncluida
	 *            Situa??o Inclu?da de Conta
	 * @param anoMesInicialReferenciaDebito
	 *            Ano Mes Inicial Referencia Debito
	 * @param anoMesFinalReferenciaDebito
	 *            Ano Mes Final Referencia Debito
	 * @param anoMesInicialVecimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @param anoMesFinalVencimentoDebito
	 *            Ano Mes Inicial Vencimento Debito
	 * @return Cole??o de Contas do Imovel
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImoveis(Collection idsImoveis,
			int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " ORDER BY idImovel, referencia ";

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createSQLQuery(consulta)
							.addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE)
							.addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER)
							.setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal",
									new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada",
									new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida",
									new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada",
									new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia",
									new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia",
									new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento",
									anoMesInicialVecimentoDebito)
							.setDate("finalVencimento",
									anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.setParameterList("idsImoveis", idsImoveis)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Cole??o de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente,
			Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Date dataVencimentoInicial,
			Date dataVencimentoFinal) throws ErroRepositorioException {
		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
						+ "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
						+ "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = "
							+ idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao(
							(List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTI??ES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTI??O DE INDICE "
								+ indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session
								.createSQLQuery(consulta)
								.addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
								.addScalar("anoMesReferencia",
										Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE)
								.addScalar("indicadorCobrancaMulta",
										Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo",
										Hibernate.STRING)
								.addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER)
								.addScalar("numeroPrestacoesDebito",
										Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal",
										Hibernate.SHORT)
								.addScalar("valorPagamento",
										Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE)
								.setInteger("idCliente", idCliente)
								.setParameterList("idsImoveis",
										particoes.get(i))
								.setInteger("situacaoNormal",
										new Integer(situacaoNormal))
								.setDate("inicialVencimento",
										dataVencimentoInicial)
								.setDate("finalVencimento", dataVencimentoFinal)
								.list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session
							.createSQLQuery(consulta)
							.addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
							.addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING)
							.addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER)
							.addScalar("numeroPrestacoesDebito",
									Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal",
									new Integer(situacaoNormal))
							.setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal)
							.list();
				}

			} else {
				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING)
						.addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER)
						.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.setInteger("idCliente", idCliente)
						.setInteger("situacaoNormal",
								new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial)
						.setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Ana Maria Data:
	 * 08/08/2007
	 * 
	 * @param idImoveis
	 *            Matriculas dos Imoveis
	 * @prarm dataVencimentoInicial Data Vencimento Inicial
	 * @param situacaoNormal
	 *            Situa??o Normal
	 * @parm dataVencimentoFinal Data Vecimento Final
	 * @return Cole??o de Guias de Pagamentos
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiasPagamentoIdsImoveis(Integer idCliente,
			Collection idsImoveis, int indicadorPagamento,
			String situacaoNormal, Short clienteRelacaoTipo,
			Date dataVencimentoInicial, Date dataVencimentoFinal)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM cadastro.cliente_guia_pagamento clieGuia "
					+ "INNER JOIN faturamento.guia_pagamento guia on guia.gpag_id = clieGuia.gpag_id "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE clieGuia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			if (clienteRelacaoTipo != null) {
				consulta += " and clieGuia.crtp_id = "
						+ clienteRelacaoTipo.toString();
			}

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			consulta += "UNION ";

			consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
					+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
					+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
					+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
					+ "debTipo.dbtp_id as idDebitoTipo, "
					+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
					+ "FROM faturamento.guia_pagamento guia "
					+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
					+ "WHERE guia.clie_id = :idCliente "
					+ "and guia.dcst_idatual = :situacaoNormal "
					+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

			consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
					+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
			}

			if (idsImoveis != null && !idsImoveis.isEmpty()) {

				consulta += "UNION ";

				consulta += "SELECT guia.gpag_id as idGuia, guia.gpag_vldebito as valorDebito, "
						+ "guia.gpag_amreferenciacontabil as anoMesReferencia, guia.gpag_dtvencimento as dataVencimento, "
						+ "guia.gpag_iccobrancamulta as indicadorCobrancaMulta, "
						+ "debTipo.dbtp_dsdebitotipo as descricaoDebitoTipo, guia.gpag_dtemissao as dataEmissao, "
						+ "debTipo.dbtp_id as idDebitoTipo, "
						+ "guia.gpag_nnprestacaodebito as numeroPrestacoesDebito, guia.gpag_nnprestacaototal as numeroPrestacoesTotal, "
						+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, min(pagto.pgmt_dtpagamento) as dataPagamento "
						+ "FROM faturamento.guia_pagamento guia "
						+ "INNER JOIN faturamento.debito_tipo debTipo on debTipo.dbtp_id = guia.dbtp_id "
						+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.gpag_id = guia.gpag_id "
						+ "WHERE guia.imov_id in (:idsImoveis) "
						+ "and guia.dcst_idatual = :situacaoNormal "
						+ "and guia.gpag_dtvencimento between :inicialVencimento and :finalVencimento ";

				consulta += " GROUP BY guia.gpag_id, guia.gpag_vldebito, guia.gpag_amreferenciacontabil, guia.gpag_dtvencimento, guia.gpag_iccobrancamulta, debtipo.dbtp_dsdebitotipo, guia.gpag_dtemissao, "
						+ "debtipo.dbtp_id, guia.gpag_nnprestacaodebito, guia.gpag_nnprestacaototal";

				if (indicadorPagamento == 1) {
					consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < (coalesce(guia.gpag_vldebito, 0)) ";
				}

				if (idsImoveis.size() > 999) {

					System.out.println("## TAMANHO TOTAL = "
							+ idsImoveis.size());

					List<List<Integer>> particoes = CollectionUtil.particao(
							(List<Integer>) idsImoveis, 999);

					int qtdQuebras = 999;
					int indice = idsImoveis.size() / qtdQuebras;

					if (idsImoveis.size() % qtdQuebras != 0) {
						indice++;
					}

					System.out.println("## QUANTIDADE PARTI??ES = " + indice);

					for (int i = 0; i < indice; i++) {

						System.out.println("## TAMANHO PARTI??O DE INDICE "
								+ indice + " = " + particoes.get(i).size());

						Collection retornoPart = null;

						retornoPart = session
								.createSQLQuery(consulta)
								.addScalar("idGuia", Hibernate.INTEGER)
								.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
								.addScalar("anoMesReferencia",
										Hibernate.INTEGER)
								.addScalar("dataVencimento", Hibernate.DATE)
								.addScalar("indicadorCobrancaMulta",
										Hibernate.SHORT)
								.addScalar("descricaoDebitoTipo",
										Hibernate.STRING)
								.addScalar("dataEmissao", Hibernate.DATE)
								.addScalar("idDebitoTipo", Hibernate.INTEGER)
								.addScalar("numeroPrestacoesDebito",
										Hibernate.SHORT)
								.addScalar("numeroPrestacoesTotal",
										Hibernate.SHORT)
								.addScalar("valorPagamento",
										Hibernate.BIG_DECIMAL)
								.addScalar("dataPagamento", Hibernate.DATE)
								.setInteger("idCliente", idCliente)
								.setParameterList("idsImoveis",
										particoes.get(i))
								.setInteger("situacaoNormal",
										new Integer(situacaoNormal))
								.setDate("inicialVencimento",
										dataVencimentoInicial)
								.setDate("finalVencimento", dataVencimentoFinal)
								.list();

						retorno.addAll(retornoPart);
					}
				} else {

					retorno = session
							.createSQLQuery(consulta)
							.addScalar("idGuia", Hibernate.INTEGER)
							.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
							.addScalar("anoMesReferencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("descricaoDebitoTipo", Hibernate.STRING)
							.addScalar("dataEmissao", Hibernate.DATE)
							.addScalar("idDebitoTipo", Hibernate.INTEGER)
							.addScalar("numeroPrestacoesDebito",
									Hibernate.SHORT)
							.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", idsImoveis)
							.setInteger("situacaoNormal",
									new Integer(situacaoNormal))
							.setDate("inicialVencimento", dataVencimentoInicial)
							.setDate("finalVencimento", dataVencimentoFinal)
							.list();
				}

			} else {
				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idGuia", Hibernate.INTEGER)
						.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("descricaoDebitoTipo", Hibernate.STRING)
						.addScalar("dataEmissao", Hibernate.DATE)
						.addScalar("idDebitoTipo", Hibernate.INTEGER)
						.addScalar("numeroPrestacoesDebito", Hibernate.SHORT)
						.addScalar("numeroPrestacoesTotal", Hibernate.SHORT)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.setInteger("idCliente", idCliente)
						.setInteger("situacaoNormal",
								new Integer(situacaoNormal))
						.setDate("inicialVencimento", dataVencimentoInicial)
						.setDate("finalVencimento", dataVencimentoFinal).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem rala??o fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSemRelacaoFim(
			String codigoCliente, Short relacaoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id " + "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente ";

			if (relacaoTipo != null) {
				consulta = consulta
						+ " inner join ci.clienteRelacaoTipo clienteRelacaoTipo ";
			}

			consulta = consulta
					+ "where cliente.id = :codigo and ci.dataFimRelacao is null";

			if (relacaoTipo != null) {
				consulta = consulta + " and clienteRelacaoTipo = :relacao ";

				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue())
						.setShort("relacao",
								new Short(relacaoTipo).shortValue()).list();
			}
			if (relacaoTipo == null) {
				retorno = session
						.createQuery(consulta)
						.setInteger("codigo",
								new Integer(codigoCliente).intValue()).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem rala??o fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarIdImoveisClienteSuperiorSemRelacaoFim(
			String codigoCliente) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select imovel.id "
					+ "from ClienteImovel ci "
					+ "inner join ci.imovel imovel "
					+ "inner join ci.cliente cliente "
					+ "where ci.dataFimRelacao is null and (cliente.id =:codigo or cliente.cliente.id = :codigo) and ci.clienteRelacaoTipo.id = "
					+ ClienteRelacaoTipo.RESPONSAVEL;

			retorno = session
					.createQuery(consulta)
					.setInteger("codigo", new Integer(codigoCliente).intValue())
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Imovel ou Cliente Pesquisa os ID
	 * dos imoveis dos cliente sem rala??o fim
	 * 
	 * @param codigoCliente
	 *            Codigo Cliente
	 * @param relacaoTipo
	 *            Rela??o Tipo Cliente Imovel
	 * @return Cole??o de Debitos A Cobrar do Cliente
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosClienteResumido(String codigoCliente,
			String tipoRelacao, String anoMesInicial, String anoMesFinal,
			Date dataVencimentoDebitoInicial, Date dataVencimentoDebitoFinal)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null "
					+ " THEN conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - conta.cnta_vlimpostos "
					+ " END "
					+ " ) as valorDebito, 'CONTA' as tipoDebito "
					+ " FROM cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.conta conta "
					+ " on conta.imov_id = imov.imov_id and (conta.dcst_idatual = "
					+ DebitoCreditoSituacao.NORMAL.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.RETIFICADA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.INCLUIDA.toString()
					+ " or conta.dcst_idatual = "
					+ DebitoCreditoSituacao.PARCELADA.toString()
					+ " ) "
					+ " left outer join arrecadacao.pagamento pagtoConta "
					+ " on conta.cnta_id = pagtoConta.cnta_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CONTA' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(dbac.dbac_vldebito - (trunc(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*(dbac.dbac_nnprestacaocobradas + coalesce(dbac.dbac_nnparcelabonus,0)))) as valorDebito, "
					// +
					// " sum(dbac.dbac_vldebito - round(round(dbac.dbac_vldebito/dbac.dbac_nnprestacaodebito, 2)*dbac.dbac_nnprestacaocobradas, 2)) as valorDebito, "
					+ " 'D?BITO A COBRAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.debito_a_cobrar dbac "
					+ " on dbac.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'D?BITO A COBRAR' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum( "
					+ " CASE "
					+ " WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null "
					+ " THEN gpag.gpag_vldebito "
					+ " END "
					+ " ) as valorDebito, 'GUIA DE PAGAMENTO' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.guia_pagamento gpag "
					+ " on gpag.imov_id = imov.imov_id "
					+ " left outer join arrecadacao.pagamento pagtoGuia "
					+ " on gpag.gpag_id = pagtoGuia.gpag_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'GUIA DE PAGAMENTO' "
					+ " UNION "
					+ " SELECT imov.imov_id as idImovel, "
					+ " sum(crar.crar_vlcredito - round(round(crar.crar_vlcredito/crar.crar_nnprestacaocredito, 2)*crar.crar_nnprestacaorealizadas, 2)) as valorDebito, "
					+ " 'CR?DITO A REALIZAR' as tipoDebito "
					+ " from cadastro.imovel imov "
					+ " inner join cadastro.cliente_imovel clieImovUsuario "
					+ " on imov.imov_id = clieImovUsuario.imov_id and clieImovUsuario.crtp_id = "
					+ ClienteRelacaoTipo.USUARIO.toString()
					+ " left outer join cadastro.cliente_imovel clieImovResponsavel "
					+ " on imov.imov_id = clieImovResponsavel.imov_id and clieImovResponsavel.crtp_id = "
					+ ClienteRelacaoTipo.RESPONSAVEL.toString()
					+ " left outer join cadastro.cliente_imovel clieImovProprietario "
					+ " on imov.imov_id = clieImovProprietario.imov_id and clieImovProprietario.crtp_id = "
					+ ClienteRelacaoTipo.PROPRIETARIO.toString()
					+ " inner join cadastro.cliente clieUsuario "
					+ " on clieUsuario.clie_id = clieImovUsuario.clie_id "
					+ " left outer join cadastro.cliente clieResponsavel "
					+ " on clieResponsavel.clie_id = clieImovResponsavel.clie_id "
					+ " left outer join cadastro.cliente clieProprietario "
					+ " on clieProprietario.clie_id = clieImovProprietario.clie_id "
					+ " inner join atendimentopublico.ligacao_agua_situacao ligAguaSit "
					+ " on imov.last_id = ligAguaSit.last_id "
					+ " inner join atendimentopublico.ligacao_esgoto_situacao ligEsgSit "
					+ " on imov.lest_id = ligEsgSit.lest_id "
					+ " left outer join faturamento.credito_a_realizar crar "
					+ " on crar.imov_id = imov.imov_id "
					+ " where "
					+ " (clieProprietario.clie_id = :codigo or clieUsuario.clie_id = :codigo or clieResponsavel.clie_id = :codigo) "
					+ " group by imov.imov_id, 'CR?DITO A REALIZAR' "
					+ " order by idImovel, tipoDebito ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("tipoDebito", Hibernate.STRING)
					.setInteger("codigo", new Integer(codigoCliente).intValue())
					.setInteger("anoMesInicial", new Integer(anoMesInicial))
					.setInteger("anoMesFinal", new Integer(anoMesFinal))
					.setDate("dataVencimentoDebitoInicial",
							dataVencimentoDebitoInicial)
					.setDate("dataVencimentoDebitoInicial",
							dataVencimentoDebitoFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emiss?o do Extrato de D?bitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * Obtem os parcelamentos de d?bitos efetuados que estejam com situa??o
	 * normal
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarParcelamentosSituacaoNormal(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(parc) "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "WHERE parc.imovel.id = :idImovel "
					+ "AND parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0))  "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							ParcelamentoSituacao.NORMAL)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emiss?o do Extrato de D?bitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Cole??o de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarImovelParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join fetch dac.debitoTipo debitoTipo "
					+ "inner join dac.parcelamento parcelamento "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0))"
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id <> :debitoTipo ";

			retorno = session
					.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("debitoTipo",
							DebitoTipo.JUROS_SOBRE_PARCELAMENTO)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0630] - Solicitar Emiss?o do Extrato de D?bitos Author: Vivianne Sousa
	 * Data: 22/08/2007
	 * 
	 * @param idParcelamento
	 * 
	 * @return Cole??o de Creditos A Realizar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCreditosARealizarParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select car,creditoTipo.descricao, creditoTipo.id "
					+ "from CreditoARealizar car "
					+ "inner join car.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join car.creditoTipo creditoTipo "
					+ "inner join car.parcelamento parcelamento "
					+ "where parcelamento.id = :idParcelamento "
					+ "and (car.numeroPrestacaoRealizada < (car.numeroPrestacaoCredito "
					+ " - coalesce(car.numeroParcelaBonus,0)) or "
					+ "car.valorResidualMesAnterior > 0) "
					+ "and car.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author S?vio Luiz, Raphael Rossiter
	 * @data 26/05/2006, 04/01/2008
	 * 
	 * @param idBairro
	 *            , idLogradouro
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitirCAER(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando,
			Date dataEmissao, Integer idCobrancaAcao,
			int quantidadeCobrancaDocumentoInicio)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento as cbdo "
					+ "LEFT JOIN fetch cbdo.empresa as empr "
					+ "LEFT JOIN fetch cbdo.localidade as loca "
					+ "LEFT JOIN fetch loca.unidadeNegocio as uneg "
					+ "LEFT JOIN fetch loca.enderecoReferencia as enderecoReferenciaLocalidade "
					+ "LEFT JOIN fetch loca.logradouroCep as logCepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.cep as cepLocalidade "
					+ "LEFT JOIN fetch logCepLocalidade.logradouro as logLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTipo as logTipoLocalidade "
					+ "LEFT JOIN fetch logLocalidade.logradouroTitulo as logTituloLocalidade "
					+ "LEFT JOIN fetch loca.logradouroBairro as logBairroLocalidade "
					+ "LEFT JOIN fetch logBairroLocalidade.bairro as bairroLocalidade "
					+ "LEFT JOIN fetch bairroLocalidade.municipio as municipioLocalidade "
					+ "LEFT JOIN fetch municipioLocalidade.unidadeFederacao as unidadeFederacaoLocalidade "
					+ "LEFT JOIN fetch cbdo.imovel as imov "
					+ "LEFT JOIN fetch imov.leituraAnormalidade as ltan "
					+ "LEFT JOIN fetch imov.logradouroBairro logBairro "
					+ "LEFT JOIN fetch logBairro.bairro bai "
					+ "LEFT JOIN fetch bai.municipio mun "
					+ "LEFT JOIN fetch mun.unidadeFederacao  unidFed "
					+ "LEFT JOIN fetch imov.logradouroCep logCep "
					+ "LEFT JOIN fetch logCep.logradouro log "
					+ "LEFT JOIN fetch log.logradouroTipo "
					+ "LEFT JOIN fetch log.logradouroTitulo "
					+ "LEFT JOIN fetch logCep.cep "
					+ "LEFT JOIN fetch imov.enderecoReferencia "
					+ "LEFT JOIN fetch imov.ligacaoAguaSituacao "
					+ "LEFT JOIN fetch imov.ligacaoEsgotoSituacao "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN fetch rot.cobrancaGrupo "
					+ "LEFT JOIN fetch cbdo.imovelPerfil "
					+ "LEFT JOIN fetch cbdo.cobrancaAcao "
					+ "LEFT JOIN fetch loca.gerenciaRegional "
					+ "LEFT JOIN fetch imov.ligacaoAgua.hidrometroInstalacaoHistorico hih "
					+ "LEFT JOIN fetch hih.hidrometro "
					+ "LEFT JOIN fetch hih.hidrometroLocalInstalacao "
					+ "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			}
			if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}
			consulta = consulta
					+ " AND cbdo.emissao = :dataEmissao AND "
					+ " cbdo.cobrancaAcao.id = :idCorteAdministrativoOUFisico "
					+ "ORDER BY loca.id, cbdo.codigoSetorComercial, rot.codigo, imov.numeroSequencialRota, "
					+ "cbdo.numeroQuadra, imov.lote, imov.subLote, cbdo.id";

			retorno = new ArrayList(new CopyOnWriteArraySet(
					session.createQuery(consulta)
							.setInteger("idCorteAdministrativoOUFisico",
									idCobrancaAcao)
							.setTimestamp("dataEmissao", dataEmissao)
							.setFirstResult(quantidadeCobrancaDocumentoInicio)
							.setMaxResults(1000).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 01/09/2007
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer verificarRDUtilizadaPeloImovel(Integer idRD, Integer idImovel)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select parc.id "
					+ "from Parcelamento parc "
					+ "left join parc.resolucaoDiretoria rd "
					+ "where parc.imovel.id = :idImovel "
					+ "and rd.id = :idRD "
					+ "and rd.indicadorParcelamentoUnico = :indicadorParcelamentoUnico "
					+ "and parc.parcelamentoSituacao = :parcelamentoSituacao ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idRD", idRD)
					.setShort("indicadorParcelamentoUnico",
							ConstantesSistema.SIM)
					.setInteger("parcelamentoSituacao",
							ParcelamentoSituacao.NORMAL).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * (DBTP_ID da tabela DEBITO_COBRADO com CNTA_ID = CNTA_ID da conta a ser
	 * parcelada ocorrendo na tabela FISCALIZACAO_SITUACAO_SERVICO_A_COBRAR)
	 * 
	 * [UC0214] Efetuar Parcelamento Debito [SB0011] Verificar ?nica Fatura
	 * 
	 * @author Vivianne Sousa
	 * @created 15/02/2007
	 * 
	 * @param idConta
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoTipoDeFiscalizacaoSituacaoServicoACobrar(
			Integer idConta) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = "select fiscalizacao.debitoTipo.id "
					+ "from FiscalizacaoSituacaoServicoACobrar fiscalizacao "
					+ "where fiscalizacao.debitoTipo.id in "
					+ "(select debitoCobrado.debitoTipo "
					+ "from DebitoCobrado debitoCobrado "
					+ "where debitoCobrado.conta.id = :idConta)";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idConta", idConta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 01/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrarSancoes(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :sancoesRegulamentares or "
					+ " dbac.dbtp_id = :multaPorInfracao or "
					+ " dbac.dbtp_id = :instalSubstHidrometro or "
					+ " dbac.dbtp_id = :consumoNaoContabilizado) "
					+ " and dbac.dbac_nnprestacaocobradas < dbac.dbac_nnprestacaodebito "
					+ " and dbac.dcst_idatual = :normal "
					+ " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares",
							DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao",
							DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado",
							DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro",
							DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 06/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoACobrar(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum (dbac.dbac_vldebito) as valorDebito"
					+ " from faturamento.debito_a_cobrar  dbac where dbac.imov_id = :idImovel and"
					+ " (dbac.dbtp_id = :atualizacaoMonetaria or "
					+ " dbac.dbtp_id = :jurosMora or "
					+ " dbac.dbtp_id = :multaImpontualidade or "
					+ " dbac.dbtp_id = :acrescImpontualidade )"
					+ " and dbac.dbac_nnprestacaocobradas < (dbac.dbac_nnprestacaodebito - coalesce(dbac.dbac_nnparcelabonus,0)) "
					+ " and dbac.dcst_idatual = :normal "
					// +
					// " and dbac.dbac_amreferenciadebito >= :anoMesInicialReferenciaDebito "
					// +
					// " and dbac.dbac_amreferenciadebito <= :anoMesFinalReferenciaDebito ";
					// alterado por Vivianne Sousa 11/09/2008
					// analista Adriano
					+ " and dbac.dbac_amcobrancadebito >= :anoMesInicialReferenciaDebito "
					+ " and dbac.dbac_amcobrancadebito <= :anoMesFinalReferenciaDebito ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("atualizacaoMonetaria",
							DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA)
					.setInteger("multaImpontualidade",
							DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade",
							DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Faz parte de [UC0067] Obter D?bito do Im?vel ou Cliente Obtem os d?bitos
	 * total de um cliente
	 */
	public Collection pesquisarDebitosCliente(Integer idCliente,
			Short relacaoTipo, Collection idsImoveis, int indicadorPagamento,
			int indicadorConta, String contaSituacaoNormal,
			String contaSituacaoRetificada, String contaSituacaoIncluida,
			String contaSituacaoParcelada,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM cadastro.cliente_conta clieConta "
					+ "INNER JOIN faturamento.conta conta on conta.cnta_id = clieConta.cnta_id "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE clieConta.clie_id = :idCliente "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (relacaoTipo != null) {
				consulta += "and clieConta.crtp_id = " + relacaoTipo.toString();
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			consulta += " UNION ";

			consulta += "SELECT conta.cnta_id as idConta, conta.cnta_vlagua as valorAgua, conta.cnta_vlesgoto as valorEsgoto, "
					+ "conta.cnta_vldebitos as valorDebitos, conta.cnta_vlcreditos as valorCreditos, conta.cnta_dtrevisao as dataRevisao, "
					+ "conta.cnta_amreferenciaconta as referencia, conta.cnta_dtvencimentoconta as dataVencimento, "
					+ "conta.cnta_iccobrancamulta as indicadorCobrancaMulta, conta.dcst_idatual as idSituacaoAtual, "
					+ "conta.cnta_dgverificadorconta as digitoVerificador, conta.cmrv_id as idMotivoRevisao, "
					+ "conta.cnta_tmultimaalteracao as ultimaAlteracao, conta.imov_id as idImovel, "
					+ "conta.cnta_nnconsumoagua as consumoAgua, conta.cnta_vlimpostos as valorImpostos, conta.cnta_nnconsumoesgoto as consumoEsgoto, "
					+ "sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) as valorPagamento, "
					+ "min(pagto.pgmt_dtpagamento) as dataPagamento, conta.parc_id as idParcelamento "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id in (:idsImoveis) "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciacontabil is null ";
			}

			consulta += " GROUP BY conta.cnta_id, conta.cnta_vlagua, conta.cnta_vlesgoto, conta.cnta_vldebitos, conta.cnta_vlcreditos, conta.cnta_dtrevisao, conta.cnta_amreferenciaconta, conta.cnta_dtvencimentoconta, conta.cnta_iccobrancamulta, "
					+ "conta.dcst_idatual, conta.cnta_dgverificadorconta, conta.cmrv_id, conta.cnta_tmultimaalteracao, conta.imov_id, conta.cnta_nnconsumoagua, conta.cnta_vlimpostos, conta.cnta_nnconsumoesgoto, conta.parc_id ";

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			if (idsImoveis.size() > 999) {

				System.out.println("## TAMANHO TOTAL = " + idsImoveis.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsImoveis, 999);

				int qtdQuebras = 999;
				int indice = idsImoveis.size() / qtdQuebras;

				if (idsImoveis.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Collection retornoPart = null;

					retornoPart = session
							.createSQLQuery(consulta)
							.addScalar("idConta", Hibernate.INTEGER)
							.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
							.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
							.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
							.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
							.addScalar("dataRevisao", Hibernate.DATE)
							.addScalar("referencia", Hibernate.INTEGER)
							.addScalar("dataVencimento", Hibernate.DATE)
							.addScalar("indicadorCobrancaMulta",
									Hibernate.SHORT)
							.addScalar("idSituacaoAtual", Hibernate.INTEGER)
							.addScalar("digitoVerificador", Hibernate.SHORT)
							.addScalar("idMotivoRevisao", Hibernate.INTEGER)
							.addScalar("ultimaAlteracao", Hibernate.DATE)
							.addScalar("idImovel", Hibernate.INTEGER)
							.addScalar("consumoAgua", Hibernate.INTEGER)
							.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
							.addScalar("consumoEsgoto", Hibernate.INTEGER)
							.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
							.addScalar("dataPagamento", Hibernate.DATE)
							.addScalar("idParcelamento", Hibernate.INTEGER)
							.setInteger("idCliente", idCliente)
							.setParameterList("idsImoveis", particoes.get(i))
							.setInteger("situacaoNormal",
									new Integer(contaSituacaoNormal))
							.setInteger("situacaoRetificada",
									new Integer(contaSituacaoRetificada))
							.setInteger("situacaoIncluida",
									new Integer(contaSituacaoIncluida))
							.setInteger("situacaoParcelada",
									new Integer(contaSituacaoParcelada))
							.setInteger("inicialReferencia",
									new Integer(anoMesInicialReferenciaDebito))
							.setInteger("finalReferencia",
									new Integer(anoMesFinalReferenciaDebito))
							.setDate("inicialVencimento",
									anoMesInicialVecimentoDebito)
							.setDate("finalVencimento",
									anoMesFinalVencimentoDebito).list();

					retorno.addAll(retornoPart);
				}
			} else {

				retorno = session
						.createSQLQuery(consulta)
						.addScalar("idConta", Hibernate.INTEGER)
						.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
						.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
						.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
						.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
						.addScalar("dataRevisao", Hibernate.DATE)
						.addScalar("referencia", Hibernate.INTEGER)
						.addScalar("dataVencimento", Hibernate.DATE)
						.addScalar("indicadorCobrancaMulta", Hibernate.SHORT)
						.addScalar("idSituacaoAtual", Hibernate.INTEGER)
						.addScalar("digitoVerificador", Hibernate.SHORT)
						.addScalar("idMotivoRevisao", Hibernate.INTEGER)
						.addScalar("ultimaAlteracao", Hibernate.DATE)
						.addScalar("idImovel", Hibernate.INTEGER)
						.addScalar("consumoAgua", Hibernate.INTEGER)
						.addScalar("valorImpostos", Hibernate.BIG_DECIMAL)
						.addScalar("consumoEsgoto", Hibernate.INTEGER)
						.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
						.addScalar("dataPagamento", Hibernate.DATE)
						.addScalar("idParcelamento", Hibernate.INTEGER)
						.setInteger("idCliente", idCliente)
						.setParameterList("idsImoveis", idsImoveis)
						.setInteger("situacaoNormal",
								new Integer(contaSituacaoNormal))
						.setInteger("situacaoRetificada",
								new Integer(contaSituacaoRetificada))
						.setInteger("situacaoIncluida",
								new Integer(contaSituacaoIncluida))
						.setInteger("situacaoParcelada",
								new Integer(contaSituacaoParcelada))
						.setInteger("inicialReferencia",
								new Integer(anoMesInicialReferenciaDebito))
						.setInteger("finalReferencia",
								new Integer(anoMesFinalReferenciaDebito))
						.setDate("inicialVencimento",
								anoMesInicialVecimentoDebito)
						.setDate("finalVencimento", anoMesFinalVencimentoDebito)
						.list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 14/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoContas(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select sum(dbcb_vlprestacao) as valorDebito"
					+ " from faturamento.debito_cobrado dbcb"
					+ " where dbcb.cnta_id in "
					+ "    (select cnta_id from faturamento.conta c where imov_id = :idImovel and"
					+ " 	cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ "     and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito"
					+ "		and not exists (select pgmt_id from arrecadacao.pagamento p where c.cnta_id = p.cnta_id)"
					+ "     and(dcst_idatual = :situacaoNormal "
					+ "     or dcst_idatual = :situacaoRetificada "
					+ "     or dcst_idatual = :situacaoIncluida )";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :atualizacaoMonetaria or dbcb.dbtp_id = :jurosMora or "
					+ "dbcb.dbtp_id = :multaImpontualidade or dbcb.dbtp_id = :acrescImpontualidade) ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("atualizacaoMonetaria",
							DebitoTipo.ATUALIZACAO_MONETARIA)
					.setInteger("jurosMora", DebitoTipo.JUROS_MORA)
					.setInteger("multaImpontualidade",
							DebitoTipo.MULTA_IMPONTUALIDADE)
					.setInteger("acrescImpontualidade",
							DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento Debito
	 * 
	 * @author Vivianne Sousa
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @param anoMesInicialReferenciaDebito
	 * @param anoMesFinalReferenciaDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorDebitoCobradoSancoes(Integer idImovel,
			Integer anoMesInicialReferenciaDebito,
			Integer anoMesFinalReferenciaDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		BigDecimal retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select sum(dbcb_vlprestacao) valorDebito "
					+ " from faturamento.debito_cobrado dbcb "
					+ " where dbcb.cnta_id in "
					+ " (select cnta_id from faturamento.conta where imov_id = :idImovel and "
					+ " cnta_amreferenciaconta >= :anoMesInicialReferenciaDebito "
					+ " and cnta_amreferenciaconta <= :anoMesFinalReferenciaDebito "
					+ " and (dcst_idatual = :situacaoNormal "
					+ " or dcst_idatual = :situacaoRetificada "
					+ " or dcst_idatual = :situacaoIncluida )  ";

			if (indicadorDividaAtiva == 1) {
				consulta += " and cnta_amrerenciacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += " and cnta_amrerenciacontabil is null ";
			}

			consulta += ") and (dbcb.dbtp_id = :sancoesRegulamentares or "
					+ " dbcb.dbtp_id = :multaPorInfracao or "
					+ " dbcb.dbtp_id = :consumoNaoContabilizado or "
					+ " dbcb.dbtp_id = :instalSubstHidrometro) ";

			retorno = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("anoMesInicialReferenciaDebito",
							anoMesInicialReferenciaDebito)
					.setInteger("anoMesFinalReferenciaDebito",
							anoMesFinalReferenciaDebito)
					.setInteger("sancoesRegulamentares",
							DebitoTipo.SANCOES_REGULAMENTARES)
					.setInteger("multaPorInfracao",
							DebitoTipo.MULTA_POR_INFRACAO)
					.setInteger("consumoNaoContabilizado",
							DebitoTipo.CONSUMO_NAO_CONTABILIZADO)
					.setInteger("instalSubstHidrometro",
							DebitoTipo.INSTAL_SUBST_HIDROMETRO)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * [UC0701] Informar ?ndices dos Acr?scimos de Impontualidade
	 * 
	 * @author S?vio Luiz
	 * @created 26/09/2007
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarMaximoAnoMesIndicesAcerscimosImpontualidade()
			throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = " select max(anoMesReferencia)  "
					+ " from IndicesAcrescimosImpontualidade ";

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;

	}

	/**
	 * Retorna uma colecao de Debitos por Faixa de Valores dos Imoveis
	 * 
	 * @author Ivan Sergio
	 * @created 20/09/2007
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoImovelPorFaixaValores(String idImovel,
			String valorMinimoDebito, String anoMesReferenciaInicial,
			String anoMesReferenciaFinal, String classificacao,
			boolean pesquisaMunicipio) throws ErroRepositorioException {

		String sql;
		String orderBy;
		String joinMunicipio = " LEFT JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		if (pesquisaMunicipio) {
			joinMunicipio = " INNER JOIN cadastro.municipio muni on muni.muni_id = loca.muni_idprincipal ";
		}
		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {
			sql = "SELECT "
					+ "	dfv.dfvl_vlfaixainicio as faixaInicial, "
					+ "	dfv.dfvl_vlfaixafim as faixaFinal, "
					+ "	dfv.dfvl_id as idFaixa, "
					+ "	count( temp.idImovel ) as quantidadeLigacoes, "
					+ "	sum( temp.totalDebitos ) as total, "
					+ "	sum( temp.qtdeDebitos ) as qtdeDocumentos, "
					+ "	temp.idGerencia as idGerencia, "
					+ "	temp.nomeGerencia as nomeGerencia, "
					+ "	temp.idLocalidade as idLocalidade, "
					+ "	temp.nomeLocalidade as nomeLocalidade, "
					+ "	temp.idSetor as idSetor, "
					+ "	temp.codigoSetor as codigoSetor, "
					+ "	temp.nomeSetor as nomeSetor, "
					+ " 	temp.idMunicipio as idMunicipio, "
					+ " 	temp.nomeMunicipio as nomeMunicipio "
					+ "FROM "
					+ "	faturamento.debito_faixa_valores dfv "
					+ "	LEFT OUTER JOIN( "
					+ "		SELECT	debitos.idImovel, "
					+ "			    gerencia.greg_id as idGerencia, "
					+ "				gerencia.greg_nmabreviado as nomeGerencia, "
					+ "				loca.loca_id as idLocalidade, "
					+ "				loca.loca_nmlocalidade as nomeLocalidade, "
					+ "				setor.stcm_id as idSetor, "
					+ "				setor.stcm_cdsetorcomercial as codigoSetor, "
					+ "				setor.stcm_nmsetorcomercial as nomeSetor, "
					+ "				sum( debitos.valorDebitos ) as totalDebitos, "
					+ "				sum( debitos.qtdeDebitos )  as qtdeDebitos, "
					+ "				muni.muni_id as idMunicipio, "
					+ "				muni.muni_nmmunicipio as nomeMunicipio "
					+ "		FROM ("
					+ "			SELECT imov.imov_id as idImovel, "
					+ "					'CONTA' as tipoDebito, "
					+ "					sum( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN "
					+ "							conta.cnta_vlagua + "
					+ "							conta.cnta_vlesgoto + "
					+ "							conta.cnta_vldebitos - "
					+ "							conta.cnta_vlcreditos - "
					+ "							coalesce( conta.cnta_vlimpostos, 0 ) "
					+ "						ELSE "
					+ "							0.00 "
					+ "						END "
					+ "					) as valorDebitos, "
					+ "					count( "
					+ "						CASE WHEN pagtoConta.pgmt_id is null and conta.cnta_id is not null THEN "
					+ "							conta.cnta_id " + "						END "
					+ "					) as qtdeDebitos " + "			FROM "
					+ "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.conta conta "
					+ "					on conta.imov_id = imov.imov_id and "
					+ "					conta.dcst_idatual in ( 0, 1, 2 ) "
					+ "				LEFT OUTER JOIN arrecadacao.pagamento pagtoConta "
					+ "					on conta.cnta_id = pagtoConta.cnta_id "
					+ "			WHERE " + "				(conta.cnta_amreferenciaconta >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				conta.cnta_amreferenciaconta <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ "				'CONTA' "
					+ "			UNION "
					+

					"			SELECT "
					+ "				imov.imov_id as idImovel, "
					+ "				'GUIA' as tipoDebito, "
					+ "				sum( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_vldebito "
					+ "					ELSE "
					+ "						0.00 "
					+ "					END "
					+ "				) as valorDebitos, "
					+ "				count( "
					+ "					CASE WHEN pagtoGuia.pgmt_id is null and gpag.gpag_id is not null THEN "
					+ "						gpag.gpag_id "
					+ "					END "
					+ "				) as qtdeDebitos "
					+ "			FROM "
					+ "				cadastro.imovel imov "
					+ "				LEFT OUTER JOIN faturamento.guia_pagamento gpag "
					+ "					on gpag.imov_id = imov.imov_id "
					+ "				LEFT OUTER JOIN arrecadacao.pagamento pagtoGuia "
					+ "					on gpag.gpag_id = pagtoGuia.gpag_id "
					+ "			WHERE "
					+ "				(gpag.gpag_amreferenciacontabil >= "
					+ anoMesReferenciaInicial
					+ " and "
					+ "				gpag.gpag_amreferenciacontabil <= "
					+ anoMesReferenciaFinal
					+ ") and "
					+ "				imov.imov_id in ( "
					+ idImovel
					+ " ) "
					+ "			GROUP BY "
					+ "				imov.imov_id, "
					+ " 				'GUIA' "
					+ "		) debitos "
					+ "		INNER JOIN cadastro.imovel imov "
					+ "			on debitos.idImovel = imov.imov_id "
					+ "		INNER JOIN cadastro.setor_comercial setor "
					+ "			on imov.stcm_id = setor.stcm_id "
					+ "		INNER JOIN cadastro.localidade loca "
					+ "			on imov.loca_id = loca.loca_id "
					+ joinMunicipio
					+ "		INNER JOIN cadastro.gerencia_regional gerencia "
					+ "			on loca.greg_id = gerencia.greg_id "
					+ "		WHERE "
					+ "			debitos.valorDebitos is null or "
					+ "			debitos.valorDebitos > 0 "
					+ "		GROUP BY "
					+ "			debitos.idImovel, "
					+ "			gerencia.greg_id, "
					+ "			gerencia.greg_nmabreviado, "
					+ "			loca.loca_id, "
					+ "			loca.loca_nmlocalidade, "
					+ "			setor.stcm_id, "
					+ "			setor.stcm_cdsetorcomercial, "
					+ "			setor.stcm_nmsetorcomercial, "
					+ "			muni.muni_id, "
					+ "			muni.muni_nmmunicipio "
					+ "		) temp "
					+ "	on temp.totalDebitos between dfv.dfvl_vlfaixainicio and dfv.dfvl_vlfaixafim "
					+ "WHERE "
					+ "	temp.totalDebitos > "
					+ valorMinimoDebito
					+ " "
					+ "GROUP BY "
					+ "	temp.idGerencia, "
					+ "	temp.nomeGerencia, "
					+ "	temp.idLocalidade, "
					+ "	temp.nomeLocalidade, "
					+ "	temp.idSetor, "
					+ "	temp.codigoSetor, "
					+ "	temp.nomeSetor, "
					+ "	dfv.dfvl_vlfaixainicio, "
					+ "	dfv.dfvl_vlfaixafim, "
					+ "	dfv.dfvl_id, "
					+ "	temp.idMunicipio, "
					+ "	temp.nomeMunicipio " + "ORDER BY ";

			// Classificacao
			orderBy = "";
			if (classificacao.trim().equalsIgnoreCase("ESTADO")) {
				orderBy = "	dfv.dfvl_id, " + "	temp.idGerencia, "
						+ "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("REGIONAL")) {
				orderBy = "	temp.idGerencia, " + "	dfv.dfvl_id, "
						+ "	temp.idLocalidade, " + "	temp.idSetor";

			} else if (classificacao.trim().equalsIgnoreCase("LOCAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, "
						+ "	dfv.dfvl_id, " + "	temp.idSetor";
			} else if (classificacao.trim().equalsIgnoreCase("SETORCOMERCIAL")) {
				orderBy = "	temp.idGerencia, " + "	temp.idLocalidade, "
						+ "	temp.idSetor, " + "	dfv.dfvl_id";
			} else if (classificacao.trim().equalsIgnoreCase("MUNICIPIO")) {
				orderBy = "	temp.idGerencia, " + "	temp.idMunicipio, "
						+ "	dfv.dfvl_id, " + "	temp.idSetor";
			}

			sql += orderBy;

			retorno = session.createSQLQuery(sql)
					.addScalar("faixaInicial", Hibernate.BIG_DECIMAL)
					.addScalar("faixaFinal", Hibernate.BIG_DECIMAL)
					.addScalar("idFaixa", Hibernate.INTEGER)
					.addScalar("quantidadeLigacoes", Hibernate.INTEGER)
					.addScalar("total", Hibernate.BIG_DECIMAL)
					.addScalar("qtdeDocumentos", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("nomeGerencia", Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("nomeSetor", Hibernate.STRING)
					.addScalar("idMunicipio", Hibernate.INTEGER)
					.addScalar("nomeMunicipio", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC0216] Calcular Acr?scimo por Impontualidade
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Pesquisa os dados do Indices Acrescimo Impontualidade menor ao
	 *         ano mes referencia
	 * 
	 * @param anoMesReferenciaDebito
	 * @return O Indices Acrescimos por Impontualidade
	 * @throws ErroRepositorioException
	 */
	public IndicesAcrescimosImpontualidade pesquisarMenorIndiceAcrescimoImpontualidade()
			throws ErroRepositorioException {

		IndicesAcrescimosImpontualidade retornoIndicesAcrescimosImpontualidade = null;
		Object retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select iai "
					+ "from IndicesAcrescimosImpontualidade iai "
					+ "where iai.anoMesReferencia = (select min(iai2.anoMesReferencia) "
					+ "from IndicesAcrescimosImpontualidade iai2)";

			retorno = session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				retornoIndicesAcrescimosImpontualidade = (IndicesAcrescimosImpontualidade) retorno;

			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retornoIndicesAcrescimosImpontualidade;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotas(String codigoSetorComercial,
			String rotaInicial, String rotaFinal, String idLocalidade,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where rota.codigo between :rotaInicial and :rotaFinal "
					+ " and setor.codigo = :setorComercial "
					+ " and localidade.id = :idLocalidade"
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("setorComercial",
							new Integer(codigoSetorComercial))
					.setInteger("rotaInicial", new Integer(rotaInicial))
					.setInteger("rotaFinal", new Integer(rotaFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloSetor(
			String codigoSetorComercialInicial,
			String codigoSetorComercialFinal, String idLocalidade,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where setor.codigo between :codigoSetorComercialInicial and :codigoSetorComercialFinal "
					+ " and localidade.id = :idLocalidade"
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidade", new Integer(idLocalidade))
					.setInteger("codigoSetorComercialInicial",
							new Integer(codigoSetorComercialInicial))
					.setInteger("codigoSetorComercialFinal",
							new Integer(codigoSetorComercialFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloLocalidade(
			String idLocalidadeInicial, String idLocalidadeFinal,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade "
					+ " where localidade.id between :idLocalidadeInicial and :idLocalidadeFinal "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idLocalidadeInicial",
							new Integer(idLocalidadeInicial))
					.setInteger("idLocalidadeFinal",
							new Integer(idLocalidadeFinal))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGerencia(
			String idGerenciaRegional, String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade"
					+ " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " inner join unidadeNegocio.gerenciaRegional gerenciaRegional"
					+ " where gerenciaRegional.id = :idGerenciaRegional "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idGerenciaRegional",
							new Integer(idGerenciaRegional))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloGrupo(String idGrupoCobranca,
			String idCobrancaAcao) throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join rota.cobrancaGrupo cobrancaGrupo"
					+ " where cobrancaGrupo.id = :idGrupoCobranca "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idGrupoCobranca", new Integer(idGrupoCobranca))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// Fl?vio Cordeiro
	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasIntervaloUnidadeNegocio(
			String idUnidadeNegocio, String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " inner join rota.setorComercial setor "
					+ " inner join setor.localidade localidade"
					+ " inner join localidade.unidadeNegocio unidadeNegocio"
					+ " where unidadeNegocio.id = :idUnidadeNegocio "
					+ " and rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session
					.createQuery(consultaSemCriterio)
					.setInteger("idUnidadeNegocio",
							new Integer(idUnidadeNegocio))
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// caso de uso [UC0543] Associar Conjunto de Rotas a Criterio de Cobranca
	public Collection pesquisarRotasPorCobrancaAcao(String idCobrancaAcao)
			throws ErroRepositorioException {

		Collection retorno = null;
		// Cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();
		// Cria a vari?vel que vai conter o hql
		String consultaSemCriterio;
		try {

			consultaSemCriterio = "select distinct(rota.id) from Rota rota "
					+ " where rota.id not in ("
					+ " select rotaCriterio.rota.id from RotaAcaoCriterio rotaCriterio"
					+ " inner join rotaCriterio.cobrancaAcao cobrancaAcao "
					+ " where cobrancaAcao.id = :idCobrancaAcao and rotaCriterio.rota.id = rota.id)";

			retorno = session.createQuery(consultaSemCriterio)
					.setInteger("idCobrancaAcao", new Integer(idCobrancaAcao))
					.list();

			// Erro no hibernate
		} catch (HibernateException e) {
			// Levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// Fecha a sess?o com o hibernate
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente
	 * 
	 * @autor: Raphael Rossiter
	 * 
	 *         Verifica se existe uma devolu??o associada ao credito
	 * 
	 * @param creditoARealizar
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean existeDevolucao(CreditoARealizar creditoARealizar)
			throws ErroRepositorioException {

		Integer retornoHQL = null;
		boolean retorno = false;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT devl.id " + "FROM Devolucao devl "
					+ "INNER JOIN devl.creditoARealizarGeral crar "
					+ "WHERE crar.id = :idCreditoARealizar ";

			retornoHQL = (Integer) session.createQuery(consulta)
					.setInteger("idCreditoARealizar", creditoARealizar.getId())
					.setMaxResults(1).uniqueResult();

			if (retornoHQL != null) {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Inserir Comando Negaiva??o
	 * 
	 * @autor: Ana Maria
	 * 
	 *         [FS0019] Verificar exist?ncia de Parcelamento
	 * 
	 * @param idImovel
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClienteResponsavelParcelamento(Integer idImovel)
			throws ErroRepositorioException {

		Cliente retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie " + "from Parcelamento parc "
					+ "inner join parc.cliente clie "
					+ "where parc.imovel.id = :idImovel "
					+ "order by parc.parcelamento desc ";

			retorno = (Cliente) session.createQuery(consulta)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico
	 * 
	 * @autor Rodrigo Silveira
	 * @date 28/01/2008 [FS0006] Verificar Data de Op??o j? Exclu?da
	 * 
	 * @param matriculaImovel
	 * @param dataOpcao
	 * @return
	 * @throws ErroRepositorioException
	 */
	public String verificarDataOpcaoJaExcluida(String matriculaImovel,
			Date dataOpcao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String idDebitoAutomatico = null;
		Object retorno = null;
		String consultaDataOpcao;

		try {
			// Verifica se a Data
			consultaDataOpcao = "select deb.id from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "where imovel.id = :matricula AND "
					+ "deb.dataExclusao is not null "
					+ "and deb.dataOpcaoDebitoContaCorrente = :data";

			retorno = session
					.createQuery(consultaDataOpcao)
					.setInteger("matricula",
							new Integer(matriculaImovel).intValue())
					.setDate("data", dataOpcao).setMaxResults(1).uniqueResult();
			if (retorno != null) {
				idDebitoAutomatico = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idDebitoAutomatico;
	}

	/**
	 * [UC0737] Atualiza Quantdade de Parcela Paga Consecutiva e Parcela B?nus
	 * 
	 * Retorna dados dos parcelamentos com RD = 8 que estejam com situa??o
	 * normal e que n?o exista outro parcelamento com data posterior
	 * 
	 * @author Vivianne Sousa
	 * @date 31/01/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarParcelamentoRDEspecial(
			Integer situacaoParcelamento, Integer idLocalidade)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "SELECT parc.parc_id as idParc, "
					+ " parc.parc_tmparcelamento as dataParc, "
					+ " parc_nnprestacoes as numeroPrestacoesParc, "
					+ " parc.imov_id as idImovel, "
					+ " parc.parc_nnparcelaspagasconsecs as numeroparcelaspagasconsecutiva "
					+ "FROM cobranca.parcelamento parc "
					+ "WHERE parc.rdir_id = :idRD "
					+ " AND parc.pcst_id = :situacaoParcelamento "
					+ " AND parc.loca_id = :idLocalidade "
					+ " AND parc.parc_tmparcelamento = "
					+ "      (SELECT max(parc_tmparcelamento) "
					+ "       FROM cobranca.parcelamento "
					+ "       WHERE imov_id = parc.imov_id) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idParc", Hibernate.INTEGER)
					.addScalar("dataParc", Hibernate.DATE)
					.addScalar("numeroPrestacoesParc", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("numeroparcelaspagasconsecutiva",
							Hibernate.SHORT).setInteger("idRD", 8)
					.setInteger("situacaoParcelamento", situacaoParcelamento)
					.setInteger("idLocalidade", idLocalidade).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela B?nus
	 * 
	 * @author Vivianne Sousa
	 * @created 07/02/2008
	 * 
	 * @param idParcelamento
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public void atualizarNumeroParcelasPagasConsecutivasParcelamento(
			Integer idParcelamento, Short numeroParcelas)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaParcelamento;

		try {
			atualizaParcelamento = "update gcom.cobranca.parcelamento.Parcelamento "
					+ "set parc_nnparcelaspagasconsecs = :numeroParcelas, "
					+ "parc_tmultimaalteracao = :ultimaAlteracao  "
					+ "where parc_id = :idParcelamento";

			session.createQuery(atualizaParcelamento)
					.setInteger("idParcelamento", idParcelamento)
					.setShort("numeroParcelas", numeroParcelas)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0676] - Consultar Resumo da Negativacao
	 * 
	 * Pesquisa resumo Negativacao
	 * 
	 * @author Marcio Roberto
	 * @date 28/02/2008
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacao(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper,
			int tipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {

			switch (tipo) {
			case 1:
				// [SB0001] - Seleciona quantidade de negativa??es incluidas.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;
			case 2:
				// [SB0002] - Seleciona quantidade de negativa??es incluidas por
				// situa??o do D?bito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;

			case 3:
				// [SB0003] - Seleciona quantidade de negativa??es por situa??o
				// de Negativa??o - RNEG_ICNEGATIVCONFIRMADA = 1.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;

			case 4:
				// [SB0003] - Seleciona quantidade de negativa??es por situa??o
				// de Negativa??o - RNEG_ICNEGATIVCONFIRMADA = 2.
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (neg.id, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 2 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by neg.id " + " order by neg.id ";
				break;

			case 5:
				// [SB0004] - Seleciona quantidade de negativa??es por situa??o
				// de Negativa??o e cobranca do Debito.
				// [SB0002] - Seleciona quantidade de negativa??es incluidas por
				// situa??o do D?bito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 1 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;
			case 6:
				// [SB0002] - Seleciona quantidade de negativa??es incluidas por
				// situa??o do D?bito
				consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (stcb.id, stcb.descricao, "
						+ " sum(re.quantidadeInclusoes),sum(re.valorDebito), sum(re.valorPendente), "
						+ " sum(re.valorPago), sum(re.valorParcelado), sum(re.valorCancelado)) "
						+ " from ResumoNegativacao re "
						+ " inner join re.negativador neg "
						+ " inner join re.cobrancaDebitoSituacao stcb "
						+ " where 1 = 1 "
						+ " and re.indicadorNegativacaoConfirmada = 2 "
						+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
						+ " group by stcb.id, stcb.descricao "
						+ " order by stcb.id, stcb.descricao ";
				break;
			default:
				break;
			}

			if (tipo == 2) {
				// tipo 2

			} else if (tipo == 1) {
				// tipo 1

			}

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * <Breve descri??o sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * <Breve descri??o sobre o subfluxo>
	 * 
	 * <Identificador e nome do subfluxo>
	 * 
	 * <Breve descri??o sobre o fluxo secund?rio>
	 * 
	 * <Identificador e nome do fluxo secund?rio>
	 * 
	 * @author M?rcio Roberto
	 * @date 07/05/2008
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @return
	 */

	public String criarCondicionaisResumosHQL(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper) {

		String sql = " ";
		String restricao = "";
		/*
		 * A partir daqui sera montanda a parte dos condicionais da query estas
		 * condicionais ser?o usadas se necessarias, o q determina seus usos s?o
		 * os parametros que veem carregados no objeto
		 * InformarDadosGeracaoRelatorioConsultaHelper que ? recebido do caso de
		 * uso [UC0304] Informar Dados para Gera??o de Relatorio ou COnsulta
		 */
		if (dadosConsultaNegativacaoHelper != null) {

			// Inicio Parametros simples
			if (dadosConsultaNegativacaoHelper.getIdNegativador() != null) {
				sql = sql + " and re.negativador.id = "
						+ dadosConsultaNegativacaoHelper.getIdNegativador();
			} else {
				if (dadosConsultaNegativacaoHelper.getColecaoNegativador() != null
						&& !dadosConsultaNegativacaoHelper
								.getColecaoNegativador().isEmpty()) {
					boolean consulta = true;
					if (dadosConsultaNegativacaoHelper.getColecaoNegativador()
							.size() == 1) {
						Iterator it = dadosConsultaNegativacaoHelper
								.getColecaoNegativador().iterator();
						while (it.hasNext()) {
							Negativador obj = (Negativador) it.next();
							if (obj != null && obj.getId() == -1) {
								consulta = false;
							}
						}
					}
					if (consulta) {
						Iterator iterator = dadosConsultaNegativacaoHelper
								.getColecaoNegativador().iterator();
						Negativador negativador = null;
						restricao = restricao + " and re.negativador.id  in (";
						while (iterator.hasNext()) {
							negativador = (Negativador) iterator.next();
							restricao = restricao + negativador.getId() + ",";
						}
						restricao = Util.removerUltimosCaracteres(restricao, 1);
						restricao = restricao + ") ";
					}
				}
			}

			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoInicio()
			// != null) {
			// if
			// (dadosConsultaNegativacaoHelper.getPeriodoEnvioNegativacaoFim()
			// != null) {
			// sql = sql
			// +
			// " and (re.dataProcessamentoEnvio >= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoInicio())+"'"
			// +
			// " and re.dataProcessamentoEnvio <= '"+Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
			// .getPeriodoEnvioNegativacaoFim())+"'"
			// + ")";
			// }
			//
			// }

			if (dadosConsultaNegativacaoHelper
					.getPeriodoEnvioNegativacaoInicio() != null
					&& dadosConsultaNegativacaoHelper
							.getPeriodoEnvioNegativacaoFim() != null) {
				sql = sql
						+ " and (re.dataProcessamentoEnvio >= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
								.getPeriodoEnvioNegativacaoInicio())
						+ "','YYYY-MM-DD')"
						+ " and re.dataProcessamentoEnvio <= to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
								.getPeriodoEnvioNegativacaoFim())
						+ "','YYYY-MM-DD')" + ")";

			} else {
				if (dadosConsultaNegativacaoHelper
						.getPeriodoEnvioNegativacaoInicio() != null) {
					sql = sql
							+ " and re.dataProcessamentoEnvio >= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
									.getPeriodoEnvioNegativacaoInicio()) + "'";
				}
				if (dadosConsultaNegativacaoHelper
						.getPeriodoEnvioNegativacaoFim() != null) {
					sql = sql
							+ " and re.dataProcessamentoEnvio <= '"
							+ Util.formatarDataComTracoAAAAMMDD(dadosConsultaNegativacaoHelper
									.getPeriodoEnvioNegativacaoFim()) + "'";
				}
			}

			if (dadosConsultaNegativacaoHelper
					.getNumeroExecucaoResumoNegativacao() != null) {
				sql = sql
						+ " and re.numeroExecucaoResumoNegativacao = "
						+ dadosConsultaNegativacaoHelper
								.getNumeroExecucaoResumoNegativacao();
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCobrancaGrupo()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().iterator();
					while (it.hasNext()) {
						CobrancaGrupo obj = (CobrancaGrupo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoCobrancaGrupo().iterator();
					CobrancaGrupo cobrancaGrupo = null;
					restricao = restricao + " and re.cobrancaGrupo.id in (";
					while (iterator.hasNext()) {
						cobrancaGrupo = (CobrancaGrupo) iterator.next();
						restricao = restricao + cobrancaGrupo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoGerenciaRegional()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().iterator();
					while (it.hasNext()) {
						GerenciaRegional gerReg = (GerenciaRegional) it.next();
						if (gerReg != null && gerReg.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoGerenciaRegional().iterator();
					GerenciaRegional gerenciaRegional = null;
					restricao = restricao + " and re.gerenciaRegional.id in (";
					while (iterator.hasNext()) {
						gerenciaRegional = (GerenciaRegional) iterator.next();
						restricao = restricao + gerenciaRegional.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoUnidadeNegocio()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().iterator();
					while (it.hasNext()) {
						UnidadeNegocio obj = (UnidadeNegocio) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoUnidadeNegocio().iterator();
					UnidadeNegocio unidadeNegocio = null;
					restricao = restricao + " and re.unidadeNegocio.id in (";
					while (iterator.hasNext()) {
						unidadeNegocio = (UnidadeNegocio) iterator.next();
						restricao = restricao + unidadeNegocio.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";

				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoCategoria() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoCategoria()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoCategoria().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoCategoria().iterator();
					while (it.hasNext()) {
						Categoria obj = (Categoria) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoCategoria().iterator();
					Categoria categoria = null;
					restricao = restricao + " and re.categoria.id in (";
					while (iterator.hasNext()) {
						categoria = (Categoria) iterator.next();
						restricao = restricao + categoria.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoClienteTipo()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoClienteTipo()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoClienteTipo().iterator();
					while (it.hasNext()) {
						ClienteTipo obj = (ClienteTipo) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoClienteTipo().iterator();
					ClienteTipo clienteTipo = null;
					restricao = restricao + " and re.clienteTipo.id in (";
					while (iterator.hasNext()) {
						clienteTipo = (ClienteTipo) iterator.next();
						restricao = restricao + clienteTipo.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoEsferaPoder()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoEsferaPoder()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoEsferaPoder().iterator();
					while (it.hasNext()) {
						EsferaPoder obj = (EsferaPoder) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoEsferaPoder().iterator();
					EsferaPoder esferaPoder = null;
					restricao = restricao + " and re.esferaPoder.id  in (";
					while (iterator.hasNext()) {
						esferaPoder = (EsferaPoder) iterator.next();
						restricao = restricao + esferaPoder.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			// *******************************************************
			// RM3755
			// Autor: Ivan Sergio
			// Data: 14/01/2011
			// "or" por se LEFT
			// *********************************************************
			if (dadosConsultaNegativacaoHelper.getColecaoLigacaoAguaSituacao() != null
					&& !dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper
						.getColecaoLigacaoAguaSituacao().size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					while (it.hasNext()) {
						LigacaoAguaSituacao obj = (LigacaoAguaSituacao) it
								.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoLigacaoAguaSituacao().iterator();
					LigacaoAguaSituacao ligacaoAguaSituacao = null;
					restricao = restricao
							+ " or re.ligacaoAguaSituacao.id  in (";
					while (iterator.hasNext()) {
						ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator
								.next();
						restricao = restricao + ligacaoAguaSituacao.getId()
								+ ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}
			// *******************************************************

			if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil() != null
					&& !dadosConsultaNegativacaoHelper.getColecaoImovelPerfil()
							.isEmpty()) {
				boolean consulta = true;
				if (dadosConsultaNegativacaoHelper.getColecaoImovelPerfil()
						.size() == 1) {
					Iterator it = dadosConsultaNegativacaoHelper
							.getColecaoImovelPerfil().iterator();
					while (it.hasNext()) {
						ImovelPerfil obj = (ImovelPerfil) it.next();
						if (obj != null && obj.getId() == -1) {
							consulta = false;
						}
					}
				}
				if (consulta) {
					Iterator iterator = dadosConsultaNegativacaoHelper
							.getColecaoImovelPerfil().iterator();
					ImovelPerfil imovelPerfil = null;
					restricao = restricao + " and re.imovelPerfil.id  in (";
					while (iterator.hasNext()) {
						imovelPerfil = (ImovelPerfil) iterator.next();
						restricao = restricao + imovelPerfil.getId() + ",";
					}
					restricao = Util.removerUltimosCaracteres(restricao, 1);
					restricao = restricao + ") ";
				}
			}

			if (dadosConsultaNegativacaoHelper.getIdEloPolo() != null) {
				sql = sql + " and re.localidade.localidade.id = "
						+ dadosConsultaNegativacaoHelper.getIdEloPolo();
			}

			if (dadosConsultaNegativacaoHelper.getIdLocalidade() != null) {
				sql = sql + " and re.localidade.id = "
						+ dadosConsultaNegativacaoHelper.getIdLocalidade();
			}

			if (dadosConsultaNegativacaoHelper.getIdSetorComercial() != null) {
				sql = sql + " and re.setorComercial.id = "
						+ dadosConsultaNegativacaoHelper.getIdSetorComercial();
			}

			if (dadosConsultaNegativacaoHelper.getIdQuadra() != null) {
				sql = sql + " and re.quadra.id = "
						+ dadosConsultaNegativacaoHelper.getIdQuadra();
			}

			// if (dadosConsultaNegativacaoHelper.getIdGrupoCobranca() != null)
			// {
			// sql = sql
			// + " and re.cobrancaGrupo.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGrupoCobranca();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdGerenciaRegional() !=
			// null) {
			// sql = sql
			// + " and re.gerenciaRegional.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdGerenciaRegional();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdImovelPerfil() != null) {
			// sql = sql
			// + " and re.imovelPerfil.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdImovelPerfil();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdCategoria() != null) {
			// sql = sql
			// + " and re.categoria.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdCategoria();
			// }
			//
			// if (dadosConsultaNegativacaoHelper.getIdEsferaPoder() != null) {
			// sql = sql
			// + " and re.esferaPoder.id = "
			// + dadosConsultaNegativacaoHelper
			// .getIdEsferaPoder();
			// }
		}

		String retorno = sql + restricao;

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * [SB0001] - Processar Documentos Cobran?a Consultar os documentos de
	 * cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CAAC_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_CRONOGRAMA
	 * 
	 * @author Rafael Santos,S?vio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 22/05/2008, 08/07/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoResumoAcaoCobranca(
			int idCobrancaAtividadeAcaoCronograma,
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select new gcom.cobranca.bean.DadosPesquisaCobrancaDocumentoHelper(cobrancaDocumento.id, "
					+ "cobrancaDocumento.emissao, "
					+ "cobrancaDocumento.imovel.id, "
					+ "cobrancaDocumento.valorDocumento, "
					+ "cobCrit.id, "
					+ "cas.id, "
					+ "loc.id, "
					+ "cobrancaDocumento.categoria.id, "
					+ "cobrancaDocumento.esferaPoder.id, "
					+ "cobrancaDocumento.cobrancaDebitoSituacao.id ) "
					+ "from CobrancaDocumento cobrancaDocumento "
					+ "left join cobrancaDocumento.localidade loc "
					+ "left join cobrancaDocumento.cobrancaCriterio cobCrit "
					+ "left join cobrancaDocumento.cobrancaAcaoSituacao cas "
					+ (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO ? "where cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id = :idCobrancaAtividadeAcaoCronograma "
							: "where cobrancaDocumento.cobrancaAcaoAtividadeComando.id = :idCobrancaAtividadeAcaoComando ")
					// +
					// " and (cobrancaDocumento.cobrancaDebitoSituacao is null or "
					// + "      cobrancaDocumento.cobrancaDebitoSituacao.id = "
					// + CobrancaDebitoSituacao.PENDENTE + " ) "
					+ "order by cobrancaDocumento.id";

			if (idCobrancaAtividadeAcaoCronograma != ConstantesSistema.NUMERO_NAO_INFORMADO) {
				retorno = session
						.createQuery(consulta)
						.setInteger("idCobrancaAtividadeAcaoCronograma",
								idCobrancaAtividadeAcaoCronograma).list();
			} else {
				retorno = session
						.createQuery(consulta)
						.setInteger("idCobrancaAtividadeAcaoComando",
								idCobrancaAtividadeAcaoComando).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este caso de uso permite gerar o resumo das a??es de cobran?a com a
	 * atividade emitir j? realizada e a atividade encerrar ainda n?o realizada
	 * e realizar a atividade encerrar das a??es que estejam comandadas.
	 * 
	 * [UC0478] Gerar Resumo das A??es de Cobran?a Eventuais
	 * 
	 * [SB0001] - Processar Documentos Cobran?a Eventual Consultar os documentos
	 * de cobranca sem carregar os criterios de cobranca
	 * 
	 * Retorna os CBDO_ID da tabela COBRANCA_DOCUMENTO com CACM_ID da tabela
	 * COBRANCA_ATIVIDADE_ACAO_COMANDO
	 * 
	 * @author Rafael Santos,S?vio Luiz, Francisco do Nascimento
	 * @date 17/10/2006,28/05/2007, 04/06/2008
	 * 
	 * @return Collection retorno
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoEventualSemCriterio(
			int idCobrancaAtividadeAcaoComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "select cbdo_id as idCobrancaDocumento, "
					+ // 0
					"cbdo_tmemissao as emissao, "
					+ // 1
					"imov_id as idImovel, "
					+ // 2
					"cbdo_vldocumento as valorDocumento, "
					+ // 3
					"cbct_id as idCriterio, "
					+ // 4
					"cast_id as idSituacaoAcao " // 5
					+ " from cobranca.cobranca_documento cobranca"
					+ " where cacm_id = :idCobrancaAtividadeAcaoComando ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idCobrancaDocumento", Hibernate.INTEGER)
					.addScalar("emissao", Hibernate.DATE)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("idCriterio", Hibernate.INTEGER)
					.addScalar("idSituacaoAcao", Hibernate.INTEGER)
					.setInteger("idCobrancaAtividadeAcaoComando",
							idCobrancaAtividadeAcaoComando).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * M?todo para atualizar a situacao do documento item de acordo com a
	 * situacao da conta / guia de pagamento / debito a cobrar. Este m?todo ser?
	 * usado nos m?todos cancelar/desfazer cancelamento conta, incluir /
	 * desfazer parcelamento, incluir / excluir pagamento, movimento de
	 * arrecadadores
	 * 
	 * @param situacaoDebito
	 * @param dataSituacao
	 * @param idConta
	 * @param idGuiaPagamento
	 * @param idDebitoACobrar
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 26/05/2008
	 * 
	 */
	public void atualizarSituacaoCobrancaDocumentoItem(Integer situacaoDebito,
			Date dataSituacao, Integer idConta, Integer idGuiaPagamento,
			Integer idDebitoACobrar) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Atualizar apenas o item do documento do cobranca com a maior data de
		// emissao
		String queryAtualizar = "";
		String queryConsultar = "";
		try {

			/*
			 * * Altera??o em 10/02/09 Por Francisco / Ana Breda Alterado para
			 * atualizar apenas itens contidos em documentos do tipo Aviso de
			 * corte, corte administrativo e corte fisico, por conta do Resumo
			 * de A??o de cobran?a.
			 */
			String dataSituacaoParaSQL = Util
					.formatarDataComTracoAAAAMMDD(dataSituacao);

			queryConsultar = "select cobrancado1_.cdit_id as idItem "
					+ " from cobranca.cobranca_documento_item cobrancado1_ "
					+ " inner join cobranca.cobranca_documento cobrancado0_ on cobrancado0_.cbdo_id = cobrancado1_.cbdo_id ";

			if (idConta != null) {

				queryConsultar = queryConsultar
						+ " inner join (select conta3_.cnta_id as idConta "
						+ " from faturamento.conta conta2_, faturamento.conta conta3_ "
						+ " where conta2_.cnta_id = "
						+ idConta
						+ " and conta2_.imov_id = conta3_.imov_id "
						+ " and conta2_.cnta_amreferenciaconta = conta3_.cnta_amreferenciaconta) conta on conta.idConta = cobrancado1_.cnta_id ";

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS')  ";
			} else if (idGuiaPagamento != null) {

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.gpag_id = " + idGuiaPagamento;
			} else if (idDebitoACobrar != null) {

				queryConsultar = queryConsultar
						+ " where cobrancado0_.dotp_id <> "
						+ DocumentoTipo.EXTRATO_DE_DEBITO + " and "
						+ "cobrancado0_.cbdo_tmemissao <= to_date('"
						+ dataSituacaoParaSQL + "','YYYY-MM-DD HH24:MI:SS') "
						+ "and cobrancado1_.dbac_id = " + idDebitoACobrar;
			} else {
				return;
			}

			queryConsultar = queryConsultar
					+ " order by cobrancado0_.cbdo_tmemissao desc ";

			Collection pesquisa = session.createSQLQuery(queryConsultar)
					.addScalar("idItem", Hibernate.INTEGER).setMaxResults(1)
					.list();

			session.clear();

			if (pesquisa != null && !pesquisa.isEmpty()) {
				Integer idItem = (Integer) pesquisa.iterator().next();
				queryAtualizar = "update gcom.cobranca.CobrancaDocumentoItem cdi "
						+ " set cobrancaDebitoSituacao = :situacaoDebito, dataSituacaoDebito = :dataSituacaoDebito ,"
						+ " ultimaAlteracao = :ultimaAlteracao "
						+ "	where cdit_id = " + idItem;

				session.createQuery(queryAtualizar)
						.setInteger("situacaoDebito", situacaoDebito)
						.setDate("dataSituacaoDebito", dataSituacao)
						.setTimestamp("ultimaAlteracao", new Date())
						.executeUpdate();

			}
			session.flush();

		} catch (HibernateException e) {
			System.out.println("Erro: " + e.getMessage());

			throw new ErroRepositorioException(e, "Erro no Hibernate: "
					+ e.getMessage());
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Recupera os dados de documento item com situacao atualizada
	 * 
	 * @author Francisco do Nascimento
	 * @created 19/05/08
	 * 
	 * @param idDocumentoCobranca
	 *            id do documento de cobranca
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection pesquisarDadosCobrancaDocumentoItemSituacaoJaAtualizada(
			Integer idDocumentoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cdi.id,"// 0
					+ " cdi.valorItemCobrado,"// 1
					+ " cdi.cobrancaDebitoSituacao.id, " // 2
					+ " cdi.dataSituacaoDebito " // 3
					+ "FROM CobrancaDocumentoItem cdi "
					+ "WHERE cdi.cobrancaDocumento.id = :idDocumentoCobranca ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoCobranca", idDocumentoCobranca)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE D?BITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND "
					+ "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = (Object[]) session.createQuery(consulta)
					.setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE D?BITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Object[]
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsCobrancaDocumento(Integer idImovel,
			BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT cd.valorAcrescimos,cd.valorDesconto,cd.emissao,cd.id,cd.valorTaxa,loca.id,documentoTipo.id "
					+ "FROM CobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cd.localidade loca "
					+ "WHERE cd.valorDocumento = :valorDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = (Object[]) session.createQuery(consulta)
					.setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue())
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE D?BITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			Date dataEmissao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE to_date(cd.emissao, 'yyyy-MM-dd') = :dataEmissao AND "
					+ "imovel.id = :idImovel";

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

			retorno = session.createQuery(consulta)
					.setString("dataEmissao", sdf.format(dataEmissao))
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UCXXXX] - Emitir Documento de Cobran?a
	 * 
	 * @author Rafael Corr?a
	 * @date 02/09/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarCobrancaDocumentoItem(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Conta> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT conta " + "FROM CobrancaDocumentoItem cdi "
					+ "INNER JOIN cdi.cobrancaDocumento cd "
					+ "INNER JOIN cdi.contaGeral contaGeral "
					+ "INNER JOIN contaGeral.conta conta "
					+ "WHERE cd.id = :idCobrancaDocumento "
					+ "ORDER BY conta.referencia ";

			retorno = session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Verificar se existe pagamento para contas de um imovel as quais foram
	 * utilizadas como entrada num parcelamento
	 * 
	 * @param idImovel
	 * @param dataParcelamento
	 * @return
	 * @throws ErroRepositorioException
	 * 
	 * @author Francisco do Nascimento
	 * @date 03/07/2008
	 * 
	 */
	public boolean exitePagamentoContaEntradaParcelamento(Integer idImovel,
			Date dataParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;
		boolean existe = false;

		try {
			/*
			 * SELECT * FROM cobranca.parcelamento parc, faturamento.conta c,
			 * arrecadacao.pagamento pag where parc.parc_id = c.parc_id and
			 * pag.cnta_id = c.cnta_id and c.imov_id = 18604620 and
			 * cast(parc.parc_tmparcelamento as Date) = '2008-06-12'
			 */
			consulta = "SELECT parc.parc_id as id FROM cobranca.parcelamento parc, "
					+ "faturamento.conta c, arrecadacao.pagamento pag "
					+ "where parc.parc_id = c.parc_id and pag.cnta_id = c.cnta_id and "
					+ "c.imov_id = "
					+ idImovel
					+ " and "
					+ "cast(parc.parc_tmparcelamento as Date) = to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(dataParcelamento)
					+ "','YYYY-MM-DD')";
			// consulta = "SELECT parc.id FROM Parcelamento parc, "
			// + "Conta c, "
			// + "Pagamento pag "
			// + "WHERE parc.id = c.parcelamento.id "
			// + " and c.id = pag.conta.id "
			// + " and c.imovel.id = :idImovel and c.parcelamento is not null "
			// + " and cast(c.parcelamento as Date) = :dataParcelamento ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER).setMaxResults(1)
					.uniqueResult();

			if (retorno != null) {
				existe = true;
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return existe;

	}

	/**
	 * Consulta as contas transferidas
	 * 
	 * [UC0204] - Consultar Transfer?ncias do D?bito
	 * 
	 * @author Rafael Corr?a
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarContasTransferidas(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT contaOrigem.cnta_amreferenciaconta as anoMesReferencia, contaOrigem.imov_id as idImovelOrigem, "
					+ " contaDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaOrigem.cnta_tmultimaalteracao as dataTransferencia, contaOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta contaDestino "
					+ " INNER JOIN faturamento.conta contaOrigem "
					+ " on contaDestino.cnta_idorigem = contaOrigem.cnta_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " contaOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " contaDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " contaOrigem.cnta_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT contaHistOrigem.cnhi_amreferenciaconta as anoMesReferencia, contaHistOrigem.imov_id as idImovelOrigem, "
					+ " contaHistDestino.imov_id as idImovelDestino, usuario.usur_nmusuario as nomeUsuario, "
					+ " contaHistOrigem.cnhi_tmultimaalteracao as dataTransferencia, contaHistOrigem.cnta_id as idConta "
					+ " FROM faturamento.conta_historico contaHistDestino "
					+ " INNER JOIN faturamento.conta_historico contaHistOrigem "
					+ " on contaHistDestino.cnta_idorigem = contaHistOrigem.cnta_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on contaHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " contaHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " contaHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " contaHistOrigem.cnhi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, anoMesReferencia ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("anoMesReferencia", Hibernate.INTEGER)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idConta", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os d?bitos a cobrar transferidos
	 * 
	 * [UC0204] - Consultar Transfer?ncias do D?bito
	 * 
	 * @author Rafael Corr?a
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarDebitosACobrarTransferidos(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoDestino.imov_id as idImovelDestino, "
					+ " debitoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoOrigem.dbac_tmultimaalteracao as dataTransferencia, debitoOrigem.dbac_id as idDebito "
					+ " FROM faturamento.debito_a_cobrar debitoDestino "
					+ " INNER JOIN faturamento.debito_a_cobrar debitoOrigem "
					+ " on debitoDestino.dbac_idorigem = debitoOrigem.dbac_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " debitoOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " debitoDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " debitoOrigem.dbac_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, debitoHistDestino.imov_id as idImovelDestino, "
					+ " debitoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " debitoHistOrigem.dahi_tmultimaalteracao as dataTransferencia, debitoHistOrigem.dbac_id as idDebito "
					+ " FROM faturamento.deb_a_cobrar_hist debitoHistDestino "
					+ " INNER JOIN faturamento.deb_a_cobrar_hist debitoHistOrigem "
					+ " on debitoHistDestino.dbac_idorigem = debitoHistOrigem.dbac_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on debitoHistOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on debitoHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " debitoHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " debitoHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " debitoHistOrigem.dahi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idDebito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta as guias de pagamento transferidas
	 * 
	 * [UC0204] - Consultar Transfer?ncias do D?bito
	 * 
	 * @author Rafael Corr?a
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarGuiasDePagamentoTransferidas(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaDestino.imov_id as idImovelDestino, "
					+ " guiaOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaOrigem.gpag_tmultimaalteracao as dataTransferencia, guiaOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento guiaDestino "
					+ " INNER JOIN faturamento.guia_pagamento guiaOrigem "
					+ " on guiaDestino.gpag_idorigem = guiaOrigem.gpag_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaOrigem.usur_id = usuario.usur_id " + " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " guiaOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " guiaDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " guiaOrigem.gpag_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT debitoTipo.dbtp_dsdebitotipo as debitoTipo, guiaHistDestino.imov_id as idImovelDestino, "
					+ " guiaHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " guiaHistOrigem.gphi_tmultimaalteracao as dataTransferencia, guiaHistOrigem.gpag_id as idGuia "
					+ " FROM faturamento.guia_pagamento_historico guiaHistDestino "
					+ " INNER JOIN faturamento.guia_pagamento_historico guiaHistOrigem "
					+ " on guiaHistDestino.gpag_idorigem = guiaHistOrigem.gpag_id "
					+ " INNER JOIN faturamento.debito_tipo debitoTipo "
					+ " on guiaHistOrigem.dbtp_id = debitoTipo.dbtp_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on guiaHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " guiaHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " guiaHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " guiaHistOrigem.gphi_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, debitoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("debitoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idGuia", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Consulta os cr?ditos a realizar transferidos
	 * 
	 * [UC0204] - Consultar Transfer?ncias do D?bito
	 * 
	 * @author Rafael Corr?a
	 * @date 22/08/2008
	 */
	public Collection<Object[]> consultarCreditosARealizarTransferidos(
			ConsultarTransferenciasDebitoHelper consultarTransferenciasDebitoHelper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoDestino.imov_id as idImovelDestino, "
					+ " creditoOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoOrigem.crar_tmultimaalteracao as dataTransferencia, creditoOrigem.crar_id as idCredito "
					+ " FROM faturamento.credito_a_realizar creditoDestino "
					+ " INNER JOIN faturamento.credito_a_realizar creditoOrigem "
					+ " on creditoDestino.crar_idorigem = creditoOrigem.crar_id "
					+ " INNER JOIN faturamento.credito_tipo creditoTipo "
					+ " on creditoOrigem.crti_id = creditoTipo.crti_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on creditoOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " creditoOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " creditoDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " creditoOrigem.crar_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " UNION "
					+ " SELECT creditoTipo.crti_dscreditotipo as creditoTipo, creditoHistDestino.imov_id as idImovelDestino, "
					+ " creditoHistOrigem.imov_id as idImovelOrigem, usuario.usur_nmusuario as nomeUsuario, "
					+ " creditoHistOrigem.carh_tmultimaalteracao as dataTransferencia, creditoHistOrigem.crar_id as idCredito "
					+ " FROM faturamento.cred_a_realiz_hist creditoHistDestino "
					+ " INNER JOIN faturamento.cred_a_realiz_hist creditoHistOrigem "
					+ " on creditoHistDestino.crar_idorigem = creditoHistOrigem.crar_id "
					+ " INNER JOIN faturamento.credito_tipo creditoTipo "
					+ " on creditoHistOrigem.crti_id = creditoTipo.crti_id "
					+ " LEFT OUTER JOIN seguranca.usuario usuario "
					+ " on creditoHistOrigem.usur_id = usuario.usur_id "
					+ " WHERE ";

			if (consultarTransferenciasDebitoHelper.getIdImovelOrigem() != null) {
				consulta = consulta
						+ " creditoHistOrigem.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelOrigem() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdImovelDestino() != null) {
				consulta = consulta
						+ " creditoHistDestino.imov_id = "
						+ consultarTransferenciasDebitoHelper
								.getIdImovelDestino() + " and ";
			}

			if (consultarTransferenciasDebitoHelper.getIdUsuario() != null) {
				consulta = consulta + " usuario.usur_id = "
						+ consultarTransferenciasDebitoHelper.getIdUsuario()
						+ " and ";
			}

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				consulta = consulta
						+ " creditoHistOrigem.carh_tmultimaalteracao between :dataInicial and :dataFinal and ";
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			consulta = consulta
					+ " ORDER BY idImovelOrigem, idImovelDestino, creditoTipo ";

			if (consultarTransferenciasDebitoHelper.getDataInicial() != null) {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER)
						.setTimestamp(
								"dataInicial",
								consultarTransferenciasDebitoHelper
										.getDataInicial())
						.setTimestamp(
								"dataFinal",
								consultarTransferenciasDebitoHelper
										.getDataFinal()).list();
			} else {
				retorno = (Collection<Object[]>) session
						.createSQLQuery(consulta)
						.addScalar("creditoTipo", Hibernate.STRING)
						.addScalar("idImovelOrigem", Hibernate.INTEGER)
						.addScalar("idImovelDestino", Hibernate.INTEGER)
						.addScalar("nomeUsuario", Hibernate.STRING)
						.addScalar("dataTransferencia", Hibernate.TIMESTAMP)
						.addScalar("idCredito", Hibernate.INTEGER).list();
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 15/07/2008
	 */
	public Collection<Object[]> obterNomeCPFTestemunhas(Integer unidadeUsuario)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select usur.nomeUsuario,usur.cpf "
					+ " from UnidadeOrganizacionalTestemunha unte "
					+ " inner join unte.unidadeOrganizacional un "
					+ " inner join unte.usuario usur "
					+ " where un.id = :unidadeUsuario and "
					+ " unte.dataFimRelacao is null " + " order by unte.id ";

			retorno = (Collection<Object[]>) session.createQuery(consulta)
					.setInteger("unidadeUsuario", unidadeUsuario).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir D?bito a Cobrar de Entrada de Parcelamento N?o Paga
	 * 
	 * Cancela uma guia de pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void cancelarGuiaPagamento(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String cancelarGuia;

		try {
			cancelarGuia = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set dcst_idanterior = (SELECT debitoCreditoSituacaoAtual.id FROM GuiaPagamento gpag "
					+ "WHERE gpag.id = :idGuiaPagamento), "
					+ "dcst_idatual = :idCancelada, "
					+ "gpag_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(cancelarGuia)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.setInteger("idCancelada", DebitoCreditoSituacao.CANCELADA)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0852] Incluir D?bito a Cobrar de Entrada de Parcelamento N?o Paga
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param parcelamento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContaDoParcelamentoNaoPago(Integer parcelamento)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT cnta FROM Conta cnta "
					+ "INNER JOIN cnta.parcelamento parc "
					+ "WHERE parc.id = :parcelamento "
					+ "and cnta.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", parcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa as contas associadas ao im?vel
	 * 
	 * @author: Rafael Corr?a
	 * @date: 28/10/2008
	 */
	public Collection<Object[]> pesquisarContasInformarContasEmCobranca(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			Collection<Integer> idsImoveis, SistemaParametro sistemaParametro,
			ComandoEmpresaCobrancaContaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT conta.cnta_id as idConta, (  	coalesce( conta.cnta_vlagua, 0 ) + "
					+ " 	coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - "
					+ " 	coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) "
					+ " ) as valorConta, 1 as indicadorPagamentoValido, conta.imov_id as idImovel, "
					+ "conta.cnta_amreferenciaconta as referenciaConta, imov.stcm_id as idSetorComercialImovel, aux.qtde as quantidade "
					+ " FROM faturamento.conta conta "
					+ " INNER JOIN cadastro.imovel imov on imov.imov_id = conta.imov_id "
					+ " INNER JOIN cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto "
					+ " on pagto.cnta_id = conta.cnta_id and pagto.pgst_idatual is not null "

					+ " left join ( select ecco.imov_id, count (distinct ecco.cecc_id) as qtde "
					+ " from COBRANCA.empresa_cobranca_conta ecco group by ecco.imov_id) aux on aux.imov_id = imov.imov_id "

					+ " WHERE conta.imov_id = :idImovel "
					+ " and conta.cnta_amreferenciaconta < :amReferenciaArrecadacao "
					+ " and conta.cmrv_id is null and conta.cnta_dtrevisao is null "
					+ " and pagto.pgmt_id is null and conta.dcst_idatual in (:incluida,:normal,:retificada) ";

			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {

				// 2.1.19.1. Caso o indicador para incluir contas fora do
				// vencimento para cobran?a corresponda a N?O
				if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca()
						.compareTo(ConstantesSistema.NAO) == 0) {

					consulta = consulta
							+ " and conta.cnta_dtvencimentoconta <= to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()))
							+ "','YYYY-MM-DD') ";
				} else {

					consulta = consulta
							+ " and exists (select distinct cnta2.imov_id "
							+ " 			from faturamento.conta cnta2 "
							+ "				where cnta2.cnta_dtvencimentoconta <= to_date('"
							+ Util.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()))
							+ "','YYYY-MM-DD') "
							+ "					and cnta2.imov_id = conta.imov_id "
							+ " 				and cnta2.cnta_amreferenciaconta < :amReferenciaArrecadacao "
							+ " 				and cnta2.cmrv_id is null and cnta2.cnta_dtrevisao is null ";

					consulta = consulta
							+ " and conta.dcst_idatual in (:incluida,:normal,:retificada) ";

					if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

						consulta = consulta
								+ " and conta.cnta_amreferenciaconta between "
								+ comandoEmpresaCobrancaConta
										.getReferenciaContaInicial()
								+ " and "
								+ comandoEmpresaCobrancaConta
										.getReferenciaContaFinal();
					}

					if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

						consulta = consulta
								+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
								+ comandoEmpresaCobrancaConta
										.getValorMinimoConta()
								+ " and "
								+ comandoEmpresaCobrancaConta
										.getValorMaximoConta();
					}
					consulta = consulta + " ) ";
				}
			} else {

				consulta = consulta
						+ " and conta.cnta_dtvencimentoconta < to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(new Date())
						+ "','YYYY-MM-DD') ";
			}

			consulta = consulta
					+ criarCondicionaisPesquisarContasInformarContasEmCobranca(
							comandoEmpresaCobrancaConta, helper);

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorPagamentoValido", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("referenciaConta", Hibernate.INTEGER)
					.addScalar("idSetorComercialImovel", Hibernate.INTEGER)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idImovel", idsImoveis.iterator().next())
					.setInteger("incluida", DebitoCreditoSituacao.INCLUIDA)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("amReferenciaArrecadacao",
							sistemaParametro.getAnoMesArrecadacao()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	private String criarCondicionaisPesquisarContasInformarContasEmCobranca(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			ComandoEmpresaCobrancaContaHelper helper) {

		String retorno = "";

		/*
		 * Collection<SetorComercial> setoresComponent = null; try {
		 * setoresComponent =
		 * pesquisarSetoresComerciaisComandoEmpresaCobrancaContaSetorComercial
		 * (comandoEmpresaCobrancaConta.getId()); } catch (Exception ex) {
		 * ex.printStackTrace(); }
		 */

		if (helper.getColecaoSetoresComponent() != null
				&& !helper.getColecaoSetoresComponent().isEmpty()) {
			retorno += " and stcm.stcm_cdsetorcomercial  in( ";
			for (SetorComercial setor : helper.getColecaoSetoresComponent()) {
				retorno += setor.getCodigo() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1);
			retorno += ") ";
		} else {
			if (comandoEmpresaCobrancaConta.getCodigoSetorComercialInicial() != null) {
				retorno = retorno
						+ " and stcm.stcm_cdsetorcomercial  between "
						+ comandoEmpresaCobrancaConta
								.getCodigoSetorComercialInicial()
						+ " and "
						+ comandoEmpresaCobrancaConta
								.getCodigoSetorComercialFinal();
			}

			if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {
				retorno = retorno
						+ " and qdra.qdra_nnquadra between "
						+ comandoEmpresaCobrancaConta.getQuadraInicial()
								.getNumeroQuadra()
						+ " and "
						+ comandoEmpresaCobrancaConta.getQuadraFinal()
								.getNumeroQuadra();
			}
		}

		if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {
			retorno = retorno + "  and conta.cnta_amreferenciaconta between "
					+ comandoEmpresaCobrancaConta.getReferenciaContaInicial()
					+ " and "
					+ comandoEmpresaCobrancaConta.getReferenciaContaFinal();
		}

		if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {
			retorno = retorno
					+ "  and conta.cnta_dtvencimentoconta between to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaInicial())
					+ "','YYYY-MM-DD') and to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
							.getDataVencimentoContaFinal()) + "','YYYY-MM-DD')";
		}

		if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {
			retorno = retorno
					+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between "
					+ comandoEmpresaCobrancaConta.getValorMinimoConta()
					+ " and "
					+ comandoEmpresaCobrancaConta.getValorMaximoConta();
		}

		return retorno;
	}

	/**
	 * [UC0852] Incluir D?bito a Cobrar de Entrada de Parcelamento N?o Paga
	 * 
	 * Desassociar a conta do parcelamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/08/2008
	 * 
	 * @param idConta
	 * @throws ErroRepositorioException
	 */
	public void desassociarContaParcelamento(Integer idConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String desassociarConta;

		try {
			desassociarConta = "update gcom.faturamento.conta.Conta "
					+ "set parc_id = null, cnta_tmultimaalteracao = :ultimaAlteracao "
					+ "where cnta_id = :idConta";

			session.createQuery(desassociarConta)
					.setInteger("idConta", idConta.intValue())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Collection<Object[]> pesquisarItensParcelamentos(
			Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			// consulta = "select cg.id,"
			// + " dacg.id, "
			// + "CASE WHEN cg.indicadorHistorico = 2  "
			// +
			// " THEN (conta.valorAgua + conta.valorEsgoto + conta.debitos - (conta.valorCreditos - coalesce(conta.valorImposto,0))) "
			// +
			// " ELSE (ch.valorAgua + ch.valorEsgoto + ch.valorDebitos - (ch.valorCreditos - coalesce(ch.valorImposto,0))) "
			// + " END "
			// + " from ParcelamentoItem pi "
			// + " inner join pi.documentoTipo dotp "
			// + " left join pi.debitoACobrarGeral dacg "
			// + " left join pi.contaGeral cg "
			// + " left join cg.contaHistorico ch "
			// + " left join cg.conta conta "
			// +
			// " where pi.parcelamento.id = :idParcelamento and dotp.id in (6,1) ";

			consulta = "SELECT "
					+ "parcItem.cnta_id as idConta, "
					+ "parcItem.dbac_id as idDebito, "
					+ "CASE WHEN (conta.cnta_id is not null) "
					+ "THEN (conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce(conta.cnta_vlimpostos,0)) "
					+ "ELSE (contaHist.cnhi_vlagua + contaHist.cnhi_vlesgoto + contaHist.cnhi_vldebitos - contaHist.cnhi_vlcreditos - coalesce(contaHist.cnhi_vlimpostos,0)) "
					+ "END as valorConta "
					+ "FROM cobranca.parcelamento_item parcItem "
					+ "LEFT JOIN faturamento.conta_historico contaHist on contaHist.cnta_id = parcItem.cnta_id "
					+ "LEFT JOIN faturamento.conta conta on conta.cnta_id = parcItem.cnta_id "
					+ "WHERE parcItem.parc_id = :idParcelamento AND "
					+ "parcItem.dotp_id in (6,1) ";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("idDebito", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa se a conta está na tabela de empresa cobranca conta
	 * 
	 * @author Sávio Luiz, Raimundo Martins, Mariana Victor
	 * @date 23/10/2008, 03/10/2011, 25/06/2012
	 */
	public Integer pesquisarEmpresaCobrancaConta(Integer idConta,
			Date dataPagamentoParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select ecc.ecco_id AS idEmprCobCnta "
					+ " from cobranca.empresa_cobranca_conta ecc "
					+ "   inner join COBRANCA.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecc.cecc_id "
					+ "   inner join cadastro.imovel_cobranca_situacao iscb on ecc.imov_id = iscb.imov_id and iscb.cbst_id = 20 "
					+ " where ecc.cnta_id = :idConta "
					+ "   and ((iscb.iscb_dtretiradacobranca is null and :dtPagamentoParcelamento >= iscb.iscb_dtimplantacaocobranca ) "
					+ "   or (:dtPagamentoParcelamento between iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca)) "
					+ "   and ((cecc.cecc_dtencerramento is null and :dtPagamentoParcelamento >= cecc.cecc_dtexecucao ) "
					+ "   or (:dtPagamentoParcelamento between cecc.cecc_dtexecucao and cecc.cecc_dtencerramento)) "
					+ "   and cecc.cecc_icgeracaotxt = :indicadorGeracaoTxt ";

			Query q = session
					.createSQLQuery(consulta)
					.addScalar("idEmprCobCnta", Hibernate.INTEGER)
					.setInteger("idConta", idConta)
					.setDate("dtPagamentoParcelamento",
							dataPagamentoParcelamento)
					.setInteger("indicadorGeracaoTxt", ConstantesSistema.SIM);

			retorno = (Integer) q.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os dados do debito a cobrar
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Object[] pesquisarDadosDebitoACobrar(Integer idDebitoACobrar)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Object[] retorno = null;
		String consulta = null;

		try {
			consulta = "select parc.id, " + " dabh.prestacaoDebito, "
					+ " dabh.prestacaoCobradas "
					+ " from DebitoACobrarHistorico dabh "
					+ " inner join dabh.parcelamento parc "
					+ " where dabh.id = :idDebitoACobrar";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Recupera os itens do parcelamento a partir do parcelamento
	 * 
	 * @author Sávio Luiz
	 * @date 23/10/2008
	 */
	public Collection<Object[]> pesquisarItensParcelamentosNivel2(
			Integer idParcelamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			// consulta = "select cg.id,"// 0
			// + " dacg.id, "// 1
			// + " CASE WHEN cg.indicadorHistorico = 2  " // 2
			// +
			// " THEN (conta.valorAgua + conta.valorEsgoto + conta.debitos - (conta.valorCreditos - coalesce(conta.valorImposto,0))) "
			// +
			// " ELSE (ch.valorAgua + ch.valorEsgoto + ch.valorDebitos - (ch.valorCreditos - coalesce(ch.valorImposto,0))) END "
			// + " from ParcelamentoItem pi "
			// + " left join pi.debitoACobrarGeral dacg "
			// + " inner join pi.parcelamento parc "
			// + " left join pi.contaGeral cg "
			// + " left join cg.contaHistorico ch "
			// + " left join cg.conta conta "
			// + " where parc.id = :idParcelamento";

			consulta = "SELECT "
					+ "parcItem.cnta_id as idConta, "
					+ "parcItem.dbac_id as idDebito, "
					+ "CASE WHEN (conta.cnta_id is not null) "
					+ "THEN (conta.cnta_vlagua + conta.cnta_vlesgoto + conta.cnta_vldebitos - conta.cnta_vlcreditos - coalesce(conta.cnta_vlimpostos,0)) "
					+ "ELSE (contaHist.cnhi_vlagua + contaHist.cnhi_vlesgoto + contaHist.cnhi_vldebitos - contaHist.cnhi_vlcreditos - coalesce(contaHist.cnhi_vlimpostos,0)) "
					+ "END as valorConta "
					+ "FROM cobranca.parcelamento_item parcItem "
					+ "LEFT JOIN faturamento.conta_historico contaHist on contaHist.cnta_id = parcItem.cnta_id "
					+ "LEFT JOIN faturamento.conta conta on conta.cnta_id = parcItem.cnta_id "
					+ "WHERE parcItem.parc_id = :idParcelamento";

			retorno = (Collection<Object[]>) session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("idDebito", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobranca(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que j? monta uma cole??o de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que ?
		 * necess?rio **
		 */
		try {
			consulta = "select new gcom.cobranca.GerarArquivoTextoContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					+ " count(ecco.comandoEmpresaCobrancaConta.id),"
					+ " sum(ecco.valorOriginalConta),"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from EmpresaCobrancaConta ecco "
					+ "inner join ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					+ "inner join ecco.contaGeral contaGeral "
					+ "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa "
					+ "and conta.debitoCreditoSituacaoAtual.id in ("
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA
					+ ", "
					+ DebitoCreditoSituacao.INCLUIDA
					+ " ) "
					+ "and  NOT EXISTS (select pg.contaGeral.id from Pagamento pg  where pg.contaGeral.id = conta.id) ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta
					+ "group by new,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 29/10/2008
	 */
	public Collection pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobrancaResumido(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que j? monta uma cole??o de
		 * GerarArquivoTextoContasCobrancaEmpresaHelper com tudo que ?
		 * necess?rio **
		 */
		try {
			consulta = "select new gcom.cobranca.GerarArquivoTextoContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id,"
					+ " comandoEmpresaCobrancaConta.empresa.id,"
					+ " comandoEmpresaCobrancaConta.empresa.descricao,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial,"
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal,"
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta,"
					+ " comandoEmpresaCobrancaConta.valorMaximoConta,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial,"
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial,"
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal,"
					+ " comandoEmpresaCobrancaConta.dataExecucao,"
					+ " comandoEmpresaCobrancaConta.imovel.id,"
					+ " comandoEmpresaCobrancaConta.cliente.id,"
					+ " comandoEmpresaCobrancaConta.cliente.nome,"
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id,"
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id,"
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome,"
					// + " count(ecco.comandoEmpresaCobrancaConta.id),"
					// + " sum(ecco.valorOriginalConta),"
					+ " comandoEmpresaCobrancaConta.ultimaAlteracao) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					// +
					// "inner join ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					// + "inner join ecco.contaGeral contaGeral "
					// + "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa "
					+ " and comandoEmpresaCobrancaConta.dataExecucao is not null "
			/*
			 * + "and conta.debitoCreditoSituacaoAtual.id in (" +
			 * DebitoCreditoSituacao.NORMAL + ", " +
			 * DebitoCreditoSituacao.RETIFICADA +", " +
			 * DebitoCreditoSituacao.INCLUIDA + " ) " +
			 * "and  NOT EXISTS (select pg.conta.id from Pagamento pg  where pg.conta.id = conta.id) "
			 */;

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			/*
			 * consulta = consulta + "group by new," +
			 * " comandoEmpresaCobrancaConta.empresa.id," +
			 * " comandoEmpresaCobrancaConta.empresa.descricao," +
			 * " comandoEmpresaCobrancaConta.codigoSetorComercialInicial," +
			 * " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," +
			 * "	comandoEmpresaCobrancaConta.valorMinimoConta," +
			 * " comandoEmpresaCobrancaConta.valorMaximoConta," +
			 * "	comandoEmpresaCobrancaConta.referenciaContaInicial," +
			 * "	comandoEmpresaCobrancaConta.referenciaContaFinal," +
			 * " comandoEmpresaCobrancaConta.dataVencimentoContaInicial," +
			 * "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," +
			 * " comandoEmpresaCobrancaConta.dataExecucao," +
			 * " comandoEmpresaCobrancaConta.imovel.id," +
			 * " comandoEmpresaCobrancaConta.cliente.id," +
			 * " comandoEmpresaCobrancaConta.cliente.nome," +
			 * " comandoEmpresaCobrancaConta.localidadeInicial.id," +
			 * " comandoEmpresaCobrancaConta.localidadeFinal.id," +
			 * " comandoEmpresaCobrancaConta.unidadeNegocio.id," +
			 * " comandoEmpresaCobrancaConta.unidadeNegocio.nome," +
			 * " comandoEmpresaCobrancaConta.ultimaAlteracao ";
			 */

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice * quantidadeRegistros).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 29/10/2008
	 */
	public Collection<Object[]> pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCriterio(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select comandoEmpresaCobrancaConta.id, "
					+ "count(ecco.comandoEmpresaCobrancaConta.id), "
					+ "sum(ecco.valorOriginalConta) "
					+ "from EmpresaCobrancaConta ecco "
					+ "inner JOIN ecco.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					// + "inner join ecco.contaGeral contaGeral "
					// + "inner join contaGeral.conta conta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa and ecco.indicadorPagamentoValido = 1 "
			/*
			 * + "and conta.debitoCreditoSituacaoAtual.id in (" +
			 * DebitoCreditoSituacao.NORMAL + ", " +
			 * DebitoCreditoSituacao.RETIFICADA +", " +
			 * DebitoCreditoSituacao.INCLUIDA + " )" +
			 * "and  NOT EXISTS (select pg.conta.id from Pagamento pg where pg.conta.id = conta.id)"
			 */;

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + " group by comandoEmpresaCobrancaConta.id  ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 29/10/2008
	 */
	public Integer pesquisarDadosGerarArquivoTextoContasCobrancaEmpresaParaCobrancaCount(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT comandoEmpresaCobrancaConta.id) "
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio, Mariana Victor
	 * @date: 29/10/2008, 02/05/2011
	 */
	public Collection<Object[]> pesquisarDadosArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idUnidadeNegocio, Integer numeroPagina,
			int quantidadeRegistros, Integer idProgramaEspecial)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select ecco.ecco_id as idEmpresaCobrancaConta, "// 0
					+ "unidadeNegocio.uneg_id as idUnidadeNegocio, "// 1
					+ "unidadeNegocio.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 2
					+ "rota.ftgr_id as idGrupoFaturamento, "// 3
					+ "localidade.loca_id as idLocalidade, "// 4
					+ "localidade.loca_nmlocalidade as nomeLocalidade, "// 5
					+ "rota.rota_cdrota as codigoRota, "// 6
					+ "imovel.imov_nnsequencialrota as numeroSequencial, "// 7
					+ "conta.imov_id as idImovel, "// 8
					+ "cliente.clie_nmcliente as nomeCliente, "// 9
					+ "clienteTipo.cltp_icpessoafisicajuridica as indicadorPessoaFisicaJuridica, "// 10
					+ "cliente.clie_nncpf as numeroCpf, "// 11
					+ "cliente.clie_nncnpj as numeroCnpj, "// 12
					+ "cliente.clie_nnrg as numeroRg, "// 13
					+ "quadra.qdra_nnquadra as numeroQuadra, "// 14
					+ "conta.cnta_id as idConta, "// 15
					+ "clienteFone.cfon_nnfone as numeroFone, "// 16
					+ "cliente.clie_nmabreviado as nomeAbreviadoCliente, "// 17
					+ "conta.cnta_amreferenciaconta as anoMesConta, "// 18
					+ "conta.cnta_dtvencimentoconta as vencimentoConta, "// 19
					+ "conta.cnta_vlagua as valorAgua, "// 20
					+ "conta.cnta_vlesgoto as valorEsgoto, "// 21
					+ "conta.cnta_vldebitos as valorDebitos, "// 22
					+ "conta.cnta_vlcreditos as valorCreditos, "// 23
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_cdsetorcomercial "
					+ "else stcm.stcm_cdsetorcomercial "
					+ "end as codigoSetorComercial, "// 24
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_nnlote "
					+ "else imovel.imov_nnlote "
					+ "end as numeroLote, "// 25
					+ "case when emco.emco_cdlayouttxt is null or emco.emco_cdlayouttxt = 1 "
					+ "  then conta.cnta_nnsublote "
					+ "else imovel.imov_nnsublote "
					+ "end as numeroSublote, "// 26
					+ "cliente.clie_id as idCliente, "// 27
					+ "gerenciaRegional.greg_id AS idGerenciaRegional, "// 28
					+ "gerenciaRegional.greg_nmregional AS nomeGerenciaRegional, "// 29
					+ "emco.emco_cdlayouttxt AS codigoLayout, "// 30
					+ "ecco.orse_id AS idOrdemServico " // 31
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "inner join cadastro.cliente_imovel clienteImovel   on clienteImovel.imov_id  = imovel.imov_id and (clienteImovel.crtp_id = 2 AND clienteImovel.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente cliente  on cliente.clie_id = clienteImovel.clie_id "
					+ "left outer join cadastro.cliente_fone clienteFone on (clienteFone.clie_id = cliente.clie_id and (clienteFone.cfon_icfonepadrao=1)) "
					+ "inner join cadastro.cliente_tipo clienteTipo on clienteTipo.cltp_id = cliente.cltp_id "
					+ "inner join cadastro.localidade localidade  on localidade.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio unidadeNegocio  on unidadeNegocio.uneg_id  = localidade.uneg_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on gerenciaRegional.greg_id = localidade.greg_id "
					+ "inner join cadastro.quadra quadra on quadra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = quadra.rota_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.cecc_id in (:ids) ";

			if (idUnidadeNegocio != null) {
				consulta = consulta
						+ " and localidade.uneg_id = :idUnidadeNegocio ";
			}

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			if (idProgramaEspecial != null) {
				consulta += "and imovel.iper_id <> :idProgramaEspecial ";
			}

			consulta += " order by ecco.ecco_id, conta.imov_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idEmpresaCobrancaConta", Hibernate.INTEGER)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idGrupoFaturamento", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencial", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("indicadorPessoaFisicaJuridica", Hibernate.SHORT)
					.addScalar("numeroCpf", Hibernate.STRING)
					.addScalar("numeroCnpj", Hibernate.STRING)
					.addScalar("numeroRg", Hibernate.STRING)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("numeroFone", Hibernate.STRING)
					.addScalar("nomeAbreviadoCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("vencimentoConta", Hibernate.DATE)
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroLote", Hibernate.SHORT)
					.addScalar("numeroSublote", Hibernate.SHORT)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("codigoLayout", Hibernate.SHORT)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.setParameterList("ids", ids);

			if (idUnidadeNegocio != null) {
				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);
			}

			if (idProgramaEspecial != null) {
				query.setInteger("idProgramaEspecial", idProgramaEspecial);
			}

			retorno = query.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPagina).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author Mariana Victor
	 * @date 25/11/2011
	 */
	public Collection<Object[]> pesquisarDadosImoveisArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idUnidadeNegocio, Integer numeroPagina,
			int quantidadeRegistros, Integer idProgramaEspecial)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select "
					+ "unidadeNegocio.uneg_id as idUnidadeNegocio, "// 0
					+ "unidadeNegocio.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 1
					+ "rota.ftgr_id as idGrupoFaturamento, "// 2
					+ "localidade.loca_id as idLocalidade, "// 3
					+ "localidade.loca_nmlocalidade as nomeLocalidade, "// 4
					+ "rota.rota_cdrota as codigoRota, "// 5
					+ "imovel.imov_nnsequencialrota as numeroSequencial, "// 6
					+ "ecco.imov_id as idImovel, "// 7
					+ "cliente.clie_nmcliente as nomeCliente, "// 8
					+ "clienteTipo.cltp_icpessoafisicajuridica as indicadorPessoaFisicaJuridica, "// 9
					+ "cliente.clie_nncpf as numeroCpf, "// 10
					+ "cliente.clie_nncnpj as numeroCnpj, "// 11
					+ "cliente.clie_nnrg as numeroRg, "// 12
					+ "quadra.qdra_nnquadra as numeroQuadra, "// 13
					+ "clienteFone.cfon_nnfone as numeroFone, "// 14
					+ "cliente.clie_nmabreviado as nomeAbreviadoCliente, "// 15
					+ "cliente.clie_id as idCliente, "// 16
					+ "gerenciaRegional.greg_id AS idGerenciaRegional, "// 17
					+ "gerenciaRegional.greg_nmregional AS nomeGerenciaRegional, "// 18
					+ "emco.emco_cdlayouttxt AS codigoLayout, "// 19
					+ "ecco.orse_id AS idOrdemServico " // 20
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "inner join cadastro.cliente_imovel clienteImovel   on clienteImovel.imov_id  = imovel.imov_id and (clienteImovel.crtp_id = 2 AND clienteImovel.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente cliente  on cliente.clie_id = clienteImovel.clie_id "
					+ "left outer join cadastro.cliente_fone clienteFone on (clienteFone.clie_id = cliente.clie_id and (clienteFone.cfon_icfonepadrao=1)) "
					+ "inner join cadastro.cliente_tipo clienteTipo on clienteTipo.cltp_id = cliente.cltp_id "
					+ "inner join cadastro.localidade localidade  on localidade.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio unidadeNegocio  on unidadeNegocio.uneg_id  = localidade.uneg_id "
					+ "inner join cadastro.gerencia_regional gerenciaRegional on gerenciaRegional.greg_id = localidade.greg_id "
					+ "inner join cadastro.quadra quadra on quadra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = quadra.rota_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.cecc_id in (:ids) ";

			if (idUnidadeNegocio != null) {
				consulta = consulta
						+ " and localidade.uneg_id = :idUnidadeNegocio ";
			}

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			if (idProgramaEspecial != null) {
				consulta += "and imovel.iper_id <> :idProgramaEspecial ";
			}

			consulta += " group by unidadeNegocio.uneg_id,  unidadeNegocio.uneg_nmunidadenegocio, "
					+ "  rota.ftgr_id,  localidade.loca_id,  localidade.loca_nmlocalidade,  rota.rota_cdrota, "
					+ "  imovel.imov_nnsequencialrota,  ecco.imov_id,  cliente.clie_nmcliente,  clienteTipo.cltp_icpessoafisicajuridica, "
					+ "  cliente.clie_nncpf,  cliente.clie_nncnpj,  cliente.clie_nnrg,  quadra.qdra_nnquadra, "
					+ "  clienteFone.cfon_nnfone,  cliente.clie_nmabreviado,  cliente.clie_id, "
					+ "  gerenciaRegional.greg_id,  gerenciaRegional.greg_nmregional,  emco.emco_cdlayouttxt, "
					+ "  ecco.orse_id" + " order by ecco.imov_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idGrupoFaturamento", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("codigoRota", Hibernate.SHORT)
					.addScalar("numeroSequencial", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("indicadorPessoaFisicaJuridica", Hibernate.SHORT)
					.addScalar("numeroCpf", Hibernate.STRING)
					.addScalar("numeroCnpj", Hibernate.STRING)
					.addScalar("numeroRg", Hibernate.STRING)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("numeroFone", Hibernate.STRING)
					.addScalar("nomeAbreviadoCliente", Hibernate.STRING)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("codigoLayout", Hibernate.SHORT)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.setParameterList("ids", ids);

			if (idUnidadeNegocio != null) {
				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);
			}

			if (idProgramaEspecial != null) {
				query.setInteger("idProgramaEspecial", idProgramaEspecial);
			}

			retorno = query.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroPagina).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author Mariana Victor
	 * @date 25/11/2011
	 */
	public Collection<Object[]> pesquisarDadosContasArquivoTextoContasCobrancaEmpresa(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select "
					+ "   ecco.ecco_id                    	   AS idEmpresaCobrancaConta, " // 0
					+ "   conta.cnta_id                        AS idConta, " // 1
					+ "   conta.cnta_amreferenciaconta         AS anoMesConta, " // 2
					+ "   conta.cnta_dtvencimentoconta         AS vencimentoConta, " // 3
					+ "   conta.cnta_vlagua                    AS valorAgua, " // 4
					+ "   conta.cnta_vlesgoto                  AS valorEsgoto, " // 5
					+ "   conta.cnta_vldebitos                 AS valorDebitos, " // 6
					+ "   conta.cnta_vlcreditos                AS valorCreditos, " // 7
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_cdsetorcomercial "
					+ "     ELSE stcm.stcm_cdsetorcomercial "
					+ "   END 							   AS codigoSetorComercial, " // 8
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_nnlote "
					+ "     ELSE imovel.imov_nnlote "
					+ "   END 							   AS numeroLote, " // 9
					+ "   CASE "
					+ "     WHEN emco.emco_cdlayouttxt IS NULL "
					+ "     OR emco.emco_cdlayouttxt    = 1 "
					+ "     THEN conta.cnta_nnsublote "
					+ "     ELSE imovel.imov_nnsublote "
					+ "   END                              AS numeroSublote " // 10
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ "inner join cadastro.imovel imovel  on imovel.imov_id  = conta.imov_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = ecco.empr_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imovel.stcm_id "
					+ "where ecco.imov_id = :idImovel and ecco.cecc_id = :idComando ";

			consulta = consulta
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			consulta += " order by conta.cnta_amreferenciaconta ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idEmpresaCobrancaConta", Hibernate.INTEGER)
					// 0
					.addScalar("idConta", Hibernate.INTEGER)
					// 1
					.addScalar("anoMesConta", Hibernate.INTEGER)
					// 2
					.addScalar("vencimentoConta", Hibernate.DATE)
					// 3
					.addScalar("valorAgua", Hibernate.BIG_DECIMAL)
					// 4
					.addScalar("valorEsgoto", Hibernate.BIG_DECIMAL)
					// 5
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					// 6
					.addScalar("valorCreditos", Hibernate.BIG_DECIMAL)
					// 7
					.addScalar("codigoSetorComercial", Hibernate.INTEGER)
					// 8
					.addScalar("numeroLote", Hibernate.SHORT)
					// 9
					.addScalar("numeroSublote", Hibernate.SHORT)
					// 10
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisa se a conta est? na tabela de empresa cobranca conta
	 * 
	 * @author S?vio Luiz
	 * @date 23/10/2008
	 */
	public void removerEmpresaCobrancaContaPagamentos(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {
			consulta = "delete EmpresaCobrancaContaPagamentos empresaCobrancaContaPagamentos "
					+ "where empresaCobrancaContaPagamentos.anoMesPagamentoArrecadacao = :anoMesReferenciaArrecadacao and "
					+ "empresaCobrancaContaPagamentos.idImovel in("
					+ "select pagamento.imovel.id from Pagamento pagamento "
					+ "where pagamento.localidade.id = :idLocalidade and pagamento.anoMesReferenciaArrecadacao <= :anoMesReferenciaArrecadacao )";

			session.createQuery(consulta)
					.setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao)
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos
	 * 
	 * @author Raphael Rossiter
	 * @date 13/11/2008
	 * 
	 * @return Collection<ResolucaoDiretoria>
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicioPermissaoEspecial()
			throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where (rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ " and not exists (select rdlg.id from RdLimitacaoGeografica rdlg where rdlg.resolucaoDiretoria.id = rd.id)"
					+ " and not exists (select rdru.id from RdRestricaoUsuario rdru where rdru.resolucaoDiretoria.id = rd.id)"
					+ "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session.createQuery(consulta)
					.setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Pesquisa a quantidade de Rotas que nao possui um Criterio definido para
	 * cada uma das Acoes de Cobrancas passadas no filtro
	 * 
	 * @author Victor Cisneiros
	 * @date 10/12/2008
	 */
	public Integer pesquisarQtdeRotasSemCriteriosParaAcoesCobranca(
			PesquisarQtdeRotasSemCriteriosParaAcoesCobranca filtro)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (filtro.getIdGrupoCobranca() != null) {
			where += " AND r.cbgr_id = :idGrupoCobranca ";
		}
		if (filtro.getIdsRotas() != null && filtro.getIdsRotas().size() > 0) {
			where += " AND r.rota_id IN ( :idsRotas ) ";
		}

		try {
			String consulta = "SELECT count(*) as contador FROM ( "
					+

					"SELECT "
					+ "r.rota_id, "
					+ "( SELECT count(*) FROM cobranca.rota_acao_criterio rac WHERE rac.rota_id = r.rota_id AND rac.cbac_id IN (:idsAcoesCobranca) ) as existe_criterio "
					+ "FROM micromedicao.rota r WHERE 1 = 1 " + where
					+ ") numero_criterios_por_rotas WHERE existe_criterio < "
					+ filtro.getIdsAcoesCobranca().size();

			if (filtro.getIdsRotas() != null
					&& filtro.getIdsRotas().size() > 999) {

				System.out.println("## TAMANHO TOTAL = "
						+ filtro.getIdsRotas().size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) filtro.getIdsRotas(), 999);

				int qtdQuebras = 999;
				int indice = filtro.getIdsRotas().size() / qtdQuebras;

				if (filtro.getIdsRotas().size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					SQLQuery retornoPart = null;

					retornoPart = session.createSQLQuery(consulta);

					retornoPart.addScalar("contador", Hibernate.INTEGER);

					if (filtro.getIdGrupoCobranca() != null) {
						retornoPart.setInteger("idGrupoCobranca",
								filtro.getIdGrupoCobranca());
					}
					if (filtro.getIdsRotas() != null
							&& filtro.getIdsRotas().size() > 0) {
						retornoPart.setParameterList("idsRotas",
								particoes.get(i));
					}
					retornoPart.setParameterList("idsAcoesCobranca",
							filtro.getIdsAcoesCobranca());

					retorno = retorno + (Integer) retornoPart.uniqueResult();

				}

			} else {

				SQLQuery q = session.createSQLQuery(consulta);

				q.addScalar("contador", Hibernate.INTEGER);

				if (filtro.getIdGrupoCobranca() != null) {
					q.setInteger("idGrupoCobranca", filtro.getIdGrupoCobranca());
				}
				if (filtro.getIdsRotas() != null
						&& filtro.getIdsRotas().size() > 0) {
					q.setParameterList("idsRotas", filtro.getIdsRotas());
				}
				q.setParameterList("idsAcoesCobranca",
						filtro.getIdsAcoesCobranca());

				retorno = (Integer) q.uniqueResult();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Deleta as OrdemServicoUnidade geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoUnidadeGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServicoUnidade ou "
					+ "WHERE ou.ordemServico.id IN "
					+ "( SELECT o.id FROM OrdemServico o WHERE o.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ) ";

			if (idsDocumentosCobranca.size() > 999) {

				System.out.println("## TAMANHO TOTAL = "
						+ idsDocumentosCobranca.size());

				List<List<Integer>> particoes = CollectionUtil.particao(
						(List<Integer>) idsDocumentosCobranca, 999);

				int qtdQuebras = 999;
				int indice = idsDocumentosCobranca.size() / qtdQuebras;

				if (idsDocumentosCobranca.size() % qtdQuebras != 0) {
					indice++;
				}

				System.out.println("## QUANTIDADE PARTI??ES = " + indice);

				for (int i = 0; i < indice; i++) {

					System.out.println("## TAMANHO PARTI??O DE INDICE "
							+ indice + " = " + particoes.get(i).size());

					Query q = session.createQuery(consulta);
					q.setParameterList("idsDocumentosCobranca",
							particoes.get(i));

					retorno = (Integer) q.executeUpdate();
				}
			} else {
				Query q = session.createQuery(consulta);
				q.setParameterList("idsDocumentosCobranca",
						idsDocumentosCobranca);
				retorno = (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Remover os debitos a cobrar das ordens de servico geradas pelos
	 * documentos
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void removerDebitoACobrarOrdemServicoGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "delete from DebitoACobrar dac where dac.ordemServico.id in "
					+ "  (SELECT os.id FROM OrdemServico os "
					+ "   where os.cobrancaDocumento.id in (:idsDocumentoCobranca) )";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentoCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Deleta as OrdemServico geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarOrdemServicoGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM OrdemServico "
					+ "WHERE cobrancaDocumento IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as DebitoACobrar geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarDebitoACobrarGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca, Integer anoMesReferencia)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		Collection<Integer> idsDebitoACobrar = null;

		try {

			String consulta = "SELECT id FROM DebitoACobrar d "
					+ "WHERE d.imovel.id IN "
					+ "( SELECT c.imovel.id FROM CobrancaDocumento c WHERE c.id IN ( :idsDocumentosCobranca ) ORDER BY c.id ) "
					+ " and d.anoMesReferenciaDebito = :anoMesReferenciaDebito"
					+ " and d.debitoTipo.id = " + DebitoTipo.TAXA_COBRANCA;

			Query q = session
					.createQuery(consulta)
					.setParameterList("idsDocumentosCobranca",
							idsDocumentosCobranca)
					.setInteger("anoMesReferenciaDebito", anoMesReferencia);

			idsDebitoACobrar = q.list();

			if (idsDebitoACobrar != null && idsDebitoACobrar.size() > 0) {

				String exclusao1 = "DELETE FROM DebitoACobrarCategoria dac "
						+ "WHERE dac.id.debitoACobrar IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao1).setParameterList(
						"idsDebitosACobrar", idsDebitoACobrar);

				q.executeUpdate();

				String exclusao2 = "DELETE FROM DebitoACobrar dac "
						+ "WHERE dac.id IN ( :idsDebitosACobrar ) ";

				q = session.createQuery(exclusao2).setParameterList(
						"idsDebitosACobrar", idsDebitoACobrar);

				retorno += (Integer) q.executeUpdate();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta as CobrancaDocumentoItem geradas pelos DocumentosCobranca
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentoItemGeradasPelosDocumentosCobranca(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoItem cdi "
					+ "WHERE cdi.cobrancaDocumento.id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deleta os Documentos de Cobranca com os Ids passados como parametro
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer deletarCobrancaDocumentos(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumento "
					+ "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			retorno = (Integer) q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Deletar os registros de imoveis nao gerados
	 * 
	 * @author Francisco do Nascimento
	 * @date 17/11/2009
	 */
	public void removerImoveisNaoGerados(Integer idCobrancaComandoCronograma,
			Integer idCobrancaComandoEventual) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM ImovelNaoGerado ing WHERE ";
			if (idCobrancaComandoCronograma != null) {
				consulta += " ing.cobrancaAcaoAtividadeCronograma.id =  "
						+ idCobrancaComandoCronograma;
			} else {
				consulta += " ing.cobrancaAcaoAtividadeComando.id =  "
						+ idCobrancaComandoEventual;
			}

			Query q = session.createQuery(consulta);
			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Inserir os registros de imoveis nao gerados dos documentos excedentes
	 * 
	 * @author Francisco do Nascimento
	 * @date 18/11/2009
	 */
	public void inserirImoveisNaoGeradosParaDocumentosExcedentes(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		String sequence = Util
				.obterNextValSequence("cobranca.seq_imovel_nao_gerado");
		try {
			stmt = con.createStatement();

			String consulta = " insert into cobranca.imovel_nao_gerado "
					+ " select " + sequence + ", caac_id, cacm_id, "
					+ " imov_id, " + MotivoNaoGeracaoDocCobranca.EXCEDEU_METAS
					+ ", " + Util.obterSQLDataAtual()
					+ " FROM cobranca.cobranca_documento where cbdo_id in (-1 ";
			for (Iterator iter = idsDocumentosCobranca.iterator(); iter
					.hasNext();) {
				Integer id = (Integer) iter.next();
				consulta += ", " + id;
			}
			consulta += ")";

			stmt.executeUpdate(consulta);

		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no SQL");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Pesquisar Quantidade de Ordens de Servi?o Encerradas
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadeOrdensServicoEncerradasPorCobrancaAcaoAtividade(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where += " AND cd.caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where += " AND cd.cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT orse_id FROM atendimentopublico.ordem_servico os "
					+ "INNER JOIN cobranca.cobranca_documento cd ON (os.cbdo_id = cd.cbdo_id) "
					+ "WHERE os.orse_cdsituacao <> "
					+ OrdemServico.SITUACAO_PENDENTE
					+ " "
					+ where
					+ " and ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);

			q.addScalar("orse_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Pagamentos por Documentos de Cobran?a
	 * 
	 * @author Victor Cisneiros
	 * @date 19/12/2008
	 */
	public Integer pesquisarQuantidadePagamentosPorDocumentosCobranca(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = "caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT pgmt_id from arrecadacao.pagamento where "
					+ "cbdo_id IN ( SELECT cbdo_id FROM cobranca.cobranca_documento cd WHERE "
					+ where + " ) " + " AND ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("pgmt_id", Hibernate.INTEGER);
			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Pesquisar Quantidade de Comandos realizados de A??es de Cobran?a
	 * sucessoras
	 * 
	 * @author Victor Cisneiros
	 * @date 23/12/2008
	 */
	public Integer pesquisarQuantidadeComandosSucessores(
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		String where = "";
		if (idCobrancaAcaoAtividadeCronograma != null) {
			where = " caac_id = :idCobrancaAcaoAtividadeCronograma ";
		}
		if (idCobrancaAcaoAtividadeComando != null) {
			where = " cacm_id = :idCobrancaAcaoAtividadeComando ";
		}

		try {
			String consulta = "SELECT cd1.cbdo_id id FROM cobranca.cobranca_documento cd1 "
					+ "WHERE "
					+ where
					+ "AND exists ( "
					+ "SELECT cd2.cbdo_id FROM cobranca.cobranca_documento cd2 "
					+ "WHERE cd1.imov_id = cd2.imov_id AND cd2.cbdo_tmemissao > cd1.cbdo_tmemissao "
					+ "AND cbac_id IN ( "
					+ "SELECT ca.cbac_id FROM cobranca.cobranca_acao ca WHERE cd1.cbac_id = ca.cbac_idacaoprecedente "
					+ ") " + ") and ROWNUM <= 1";

			SQLQuery q = session.createSQLQuery(consulta);
			q.addScalar("id", Hibernate.INTEGER);

			if (idCobrancaAcaoAtividadeCronograma != null) {
				q.setInteger("idCobrancaAcaoAtividadeCronograma",
						idCobrancaAcaoAtividadeCronograma);
			}
			if (idCobrancaAcaoAtividadeComando != null) {
				q.setInteger("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresa(
			RelatorioPagamentosContasCobrancaEmpresaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select ecc.imov_id as idImovel, " // 0
					+ "c.clie_nmcliente as nomeCliente, " // 1
					+ "eccp.eccp_amreferenciapagamento as anoMesConta, "// 2
					+ "ecc.ecco_vloriginalconta as valorConta, "// 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "(select sum( coalesce(eccp_vlpagamentomes,0)) "
					+ "from cobranca.empr_cobr_conta_pagto eccp_sub "
					+ "where (eccp_sub.dbtp_id not in ( 80, 91, 94, 100 ) or eccp_sub.dbtp_id is null) and eccp_sub.ecco_id = ecc.ecco_id and eccp_sub.eccp_id = eccp.eccp_id ) as valorPrincipal, "// 5
					+ "(select sum(coalesce(eccp_vlpagamentomes,0) ) from cobranca.empr_cobr_conta_pagto eccp_sub "
					+ "where eccp_sub.dbtp_id in ( 80, 91, 94, 100 ) and eccp_sub.ecco_id = ecc.ecco_id and eccp_sub.eccp_id = eccp.eccp_id) as valorEncargos, "// 6
					+ "ecc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "imovel.loca_id, " // 8
					+ "loca.loca_nmlocalidade "// 9
					+ "loca.greg_id, " // 10
					+ "greg.greg_nmregional, " // 11
					+ "loca.uneg_id, " // 12
					+ "uneg.uneg_nmunidadenegocio, " // 13
					+ "rota.rota_id " // 14
					+ "from cobranca.empr_cobr_conta_pagto eccp "
					+ "inner join cadastro.cliente_imovel ci on ( ci.imov_id = eccp.imov_id and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente c on ( c.clie_id = ci.clie_id ) "
					+ "inner join cobranca.empresa_cobranca_conta ecc on ( ecc.ecco_id  = eccp.ecco_id )  "
					+ "inner join cadastro.imovel imovel on imovel.imov_id = eccp.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imovel.loca_id "
					+ "inner join cadastro.unidade_negocio uneg on uneg.uneg_id = loca.uneg_id "
					+ "inner join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "inner join cadastro.quadra qdra on qdra.qdra_id = imovel.qdra_id "
					+ "inner join micromedicao.rota rota on rota.rota_id = qdra.rota_id "
					+ "where (eccp.eccp_ampagamento between :referenciaPagamentoInicial and :referenciaPagamentoFinal) and ecc.empr_id = :idEmpresa ";

			if (helper.getOpcaoTotalizacao() != null
					&& !helper.getOpcaoTotalizacao().equals("")) {

				if (helper.getOpcaoTotalizacao().equalsIgnoreCase("estado")) {

					consulta = consulta + " ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoGerencia")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoUnidadeNegocio")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"estadoLocalidade")) {

					consulta = consulta
							+ "order by loca.loca_id, imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"gerenciaRegional")) {

					consulta = consulta + "greg.gre_id = "
							+ helper.getCodigoGerencia()
							+ "greg.greg_id, uneg.uneg_id, imovel.imov_id, "
							+ "eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"gerenciaRegionalLocalidade")) {

					consulta = consulta
							+ "order by greg.greg_id, uneg.uneg_id, loca.loca_id, "
							+ "imovel.imov_id, eccp.eccp_amreferenciapagamento ";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"unidadeNegocio")) {

					consulta = consulta
							+ " and uneg.uneg_id =  "
							+ helper.getUnidadeNegocio()
							+ " "
							+ "order by uneg.uneg_id, loca.loca_id, imovel.imov_id, "
							+ "eccp.eccp_amreferenciapagamento";

				} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
						"localidade")) {

					consulta = consulta
							+ " and loca.loca_id =  "
							+ helper.getCodigoLocalidade()
							+ " "
							+ "order by  loca.loca_id, imovel.imov_id, eccp.eccp_amreferenciapagamento ";
				}

			}

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.setInteger("idEmpresa", helper.getEmpresa().getId())
					.setInteger("referenciaPagamentoInicial",
							helper.getReferenciaPagamentoInicial())
					.setInteger("referenciaPagamentoFinal",
							helper.getReferenciaPagamentoFinal()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresaCount(
			Integer idEmpresa, Integer referenciaPagamentoInicial,
			Integer referenciaPagamentoFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select count(ecc.imov_id) as qtdeRelatorio " // 0
					+ "from cobranca.empresa_cobranca_conta ecc "
					+ "inner join cadastro.cliente_imovel ci on ( ci.imov_id = ecc.imov_id and ci.crtp_id = 2 and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente c on ( c.clie_id = ci.clie_id ) "
					+ "inner join cobranca.empr_cobr_conta_pagto eccp on ( eccp.ecco_id = ecc.ecco_id ) "
					+ "where (eccp.eccp_ampagamento between :referenciaPagamentoInicial and :referenciaPagamentoFinal) and ecc.empr_id = :idEmpresa ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("qtdeRelatorio", Hibernate.INTEGER)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("referenciaPagamentoInicial",
							referenciaPagamentoInicial)
					.setInteger("referenciaPagamentoFinal",
							referenciaPagamentoFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0879] Gerar Extensao Comando Contas em Cobranca por Empresa
	 * 
	 * 
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 02/02/2009
	 */

	public Collection<Object[]> pesquisarDadosGerarExtensaoComandoContasCobrancaEmpresaParaCobranca(
			Integer idComandoEmpresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "select ccce.ccce_id as idExtensao, " // 0
					+ "ccce.ccce_amreferenciacontainicial as referenciaInicial, "// 1
					+ "ccce.ccce_amreferenciacontafinal as referenciaFinal, " // 2
					+ "ccce.ccce_dtexecucao as dataExecucao," // 3
					+ "ccce.ccce_nndiasvencimentocontas as diasVencimentoContas " // 4
					// + "count(ecco.cecc_id) as valorOriginalConta, " //4
					// + "sum(ecco.ecco_vloriginalconta) as somaContas "//5
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "left join cobranca.empresa_cobranca_conta ecco on ecco.ccce_id = ccce.ccce_id "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta "
					+ "group by ccce.ccce_id, ccce.ccce_amreferenciacontainicial, ccce.ccce_amreferenciacontafinal, ccce.ccce_dtexecucao,ccce.ccce_nndiasvencimentocontas ";

			/*
			 * consulta = "select ccce.id, " // 0 +
			 * "ccce.referenciaContaInicial, "//1 +
			 * "ccce.referenciaContaFinal, " //2 + "ccce.dataExecucao, " //3 +
			 * "count(ecco.comandoEmpresaCobrancaConta.id), " //4 +
			 * "sum(ecco.valorOriginalConta) "//5 +
			 * "from EmpresaCobrancaConta ecco " +
			 * "left join ecco.comandoEmpresaCobrancaContaExtensao ccce " +
			 * "where ccce.id = :idComandoEmpresaCobrancaConta " +
			 * "group by ,,, ";
			 */

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idExtensao", Hibernate.INTEGER)
					.addScalar("referenciaInicial", Hibernate.INTEGER)
					.addScalar("referenciaFinal", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("diasVencimentoContas", Hibernate.INTEGER)
					// .addScalar("somaContas",Hibernate.BIG_DECIMAL)
					.setInteger("idComandoEmpresaCobrancaConta",
							idComandoEmpresaCobrancaConta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer retornaAnoMesContaUltimaExtensao(
			Integer idComandoEmpresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select max(ccce.ccce_amreferenciacontafinal) as anoMesFinal "
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "where ccce.cecc_id = :idComandoEmpresaCobrancaConta";

			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("anoMesFinal", Hibernate.INTEGER)
					.setInteger("idComandoEmpresaCobrancaConta",
							idComandoEmpresaCobrancaConta).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Rela??o de Parcelamento - Vis?o Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 04/02/2009
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoAnalitico(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento,
			Integer anoMesReferenciaFaturamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select \n"
					+ "  distinct \n"
					+
					// 0
					"  parc.parc_id, \n"
					+
					// 1
					"  loca.loca_id, \n"
					+
					// 2
					"  loca.loca_nmlocalidade, \n"
					+
					// 3
					"  geRe.greg_id, \n"
					+
					// 4
					"  geRe.greg_nmregional, \n"
					+
					// 5
					"  clie.clie_nmcliente, \n"
					+
					// 6
					"  parc.imov_id, \n"
					+
					// 7
					"  coalesce( clieFone.cfon_cdddd || ' ' || clieFone.cfon_nnfone, '-' ) as telefone, \n"
					+
					// 8
					"  cast( to_char( cnta.cnta_dtvencimentoconta, 'dd' ) as integer ) as diaVencimento, \n"
					+
					// 9
					"  parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+
					// 10
					"  parc.parc_vlprestacao as valorParcela, \n"
					+
					// 11
					"  parc.parc_vlentrada as entrada, \n"
					+
					// 12
					"  parc.parc_tmparcelamento as dataParcelamento, \n"
					+
					// 13
					"  parc.parc_nnprestacoes as qtdParcelas, \n"
					+
					// 14
					"  case when deAC.dbac_id is not null then \n"
					+ "    coalesce( deAC.dbac_nnprestacaocobradas, 0 ) \n"
					+ "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaocobradas, 0 ) \n"
					+ "  end as prestacoesCobradas, \n"
					+
					// 15
					"  case when deAC.dbac_id is not null then \n"
					+ "    coalesce( deAC.dbac_nnprestacaodebito - deAC.dbac_nnprestacaocobradas, 0 ) \n"
					+ "  else \n"
					+ "    coalesce( deACH.dahi_nnprestacaodebito - deACH.dahi_nnprestacaocobradas, 0 ) \n"
					+ "  end as qtdNaoCobradas, \n" +
					// 16
					"  unNe.uneg_nmabreviado as nomeUnidade, \n" +
					// 17
					"  usur.usur_nmlogin as login, \n" +
					// 18
					"  deAC.dbac_id as idDebitoACobrar, \n" +
					// 19
					"  deACH.dbac_id as idDebitoACobrarHistorico \n"
					+

					selectMunicipio
					+ "from \n"
					+ "    cobranca.parcelamento parc \n"
					+ "    inner join cadastro.localidade loca on ( loca.loca_id = parc.loca_id ) \n"
					+ joinMunicipio
					+ "    inner join cadastro.gerencia_regional geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "    inner join cadastro.unidade_negocio unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "    inner join cadastro.cliente clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "    left join seguranca.usuario usur ON usur.usur_id = parc.usur_id \n"
					+ "    left join cadastro.unidade_organizacional unid ON usur.unid_id = unid.unid_id \n"
					+ "    inner join cadastro.imovel imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "    inner join cadastro.quadra qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "	 left join cadastro.cliente_fone clieFone on ( clieFone.clie_id = clie.clie_id and \n"
					+ "	 clieFone.cfon_icfonepadrao = 1 ) \n"
					+ "	 left join faturamento.conta cnta on ( cnta.imov_id = parc.imov_id and cnta. \n"
					+ "	 cnta_amreferenciaconta = :anoMesReferenciaFaturamento ) \n"
					
					+ "    left join (select auxiliar.parc_id, min(auxiliar.dbac_id) as dbac_id from faturamento.debito_a_cobrar auxiliar \n" 
					+ "	   where  auxiliar.dcst_idatual in (1,0) and auxiliar.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ) \n"
					+ "    group by auxiliar.parc_id) aux on aux.parc_id = parc.parc_id "
					
					+ "    left join faturamento.debito_a_cobrar deAC on ( deAC.parc_id = parc.parc_id and deAC.dcst_idatual in (1,0) \n"
					+ "    and deAC.dbtp_id in ( 40, 41,42, 43, 45, 47,50 ) \n"
					+ "    and deAC.dbac_id = aux.dbac_id) \n"
					
					+ "    left join (select auxiliarHistorico.parc_id, min(auxiliarHistorico.dbac_id) as dbac_id from faturamento.deb_a_cobrar_hist auxiliarHistorico \n" 
					+ "	   where auxiliarHistorico.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) group by auxiliarHistorico.parc_id) auxHist on auxHist.parc_id = parc.parc_id \n"
					
					+ "    left join faturamento.deb_a_cobrar_hist deACH on ( deACH.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) \n"
					+ "    and deACH.parc_id = parc.parc_id and deACH.dbac_id = auxHist.dbac_id) \n"
					
					+ "where \n"
					+ "  parc.pcst_id = 1 and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deAC.dbac_id ) and \n"
					+ "  not exists ( select 'a' from cobranca.parcelamento_item parcItem where parcItem.dbac_id = deACH.dbac_id ) \n";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {
				consulta += " and imo.iper_id in (:idsPerfisImovel) \n";

			}

			// Cole??o Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n"
					+ "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session
						.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER)
						.addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING)
						.addScalar("login", Hibernate.STRING)
						.addScalar("muni_id", Hibernate.INTEGER)
						.addScalar("muni_nmmunicipio", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER)
						.addScalar("idDebitoACobrarHistorico",
								Hibernate.INTEGER);
			} else {
				query = session
						.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.INTEGER)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.INTEGER)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("telefone", Hibernate.STRING)
						.addScalar("diaVencimento", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("entrada", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.INTEGER)
						.addScalar("prestacoesCobradas", Hibernate.INTEGER)
						.addScalar("qtdNaoCobradas", Hibernate.INTEGER)
						.addScalar("nomeUnidade", Hibernate.STRING)
						.addScalar("login", Hibernate.STRING)
						.addScalar("idDebitoACobrar", Hibernate.INTEGER)
						.addScalar("idDebitoACobrarHistorico",
								Hibernate.INTEGER);
			}

			query.setInteger("anoMesReferenciaFaturamento",
					anoMesReferenciaFaturamento);

			// Adicionamos os parametros necess?rios
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				query.setInteger("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios",
						filtrarRelacaoParcelamento
								.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento
						.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial",
						filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if (filtrarRelacaoParcelamento.getColecaoPerfilImovel() != null
					&& !filtrarRelacaoParcelamento.getColecaoPerfilImovel()
							.isEmpty()) {

				query.setParameterList("idsPerfisImovel",
						filtrarRelacaoParcelamento.getColecaoPerfilImovel());
			}

			// cole??o Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				query.setInteger("idUnidadeOrganizacional",
						filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {

				query.setInteger("idUsuario",
						filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Object[] obterParcelamentoMaisAtualDoImovel(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parc.id, "// 0
					+ "rdir.id, "// 1
					+ "rdir.numeroResolucaoDiretoria "// 2
					+ "FROM Parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "INNER JOIN parc.parcelamentoSituacao parcSit "
					+ "LEFT JOIN parc.resolucaoDiretoria rdir "
					+ "WHERE imov.id = :idImovel AND parcSit.id = :parcNormal "
					+ "ORDER BY parc.parcelamento desc ";

			retorno = (Object[]) session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("parcNormal", ParcelamentoSituacao.NORMAL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos [FS0028] Verifica se
	 * existeParcelas em atraso [FS0029] Verificar se existe parcelamento em
	 * andamento
	 * 
	 * verificar se existe parcelas a serem cobradas (selecionar na tabela de
	 * debito a cobrar (FATURAMENTO.DEBITO_A_COBRAR), a linha que tenha o
	 * PARC_ID = PARC_ID da tabela COBRANCA.PARCELAMENTO e o tipo de d?bito
	 * (DBTP_ID) = 40) e caso o n?mero de presta??es do d?bito n?o seja igual ao
	 * n?mero de presta??es cobradas
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Cole??o de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterDebitoACobrarDoParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac.id "
					+ " from DebitoACobrar dac "
					+ " inner join dac.debitoTipo debitoTipo "
					+ " inner join dac.parcelamento parcelamento "
					+ " where parcelamento.id = :idParcelamento "
					+ " and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ " and debitoTipo.id = :debitoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("debitoTipo", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos [FS0028] Verifica se
	 * existeParcelas em atraso
	 * 
	 * verificar se existe parcelas em atraso, ou seja, verificar nas contas que
	 * ir?o fazer parte do parcelamento, se existe algum d?bito de parcelamento
	 * da RDIR_ID = RDIR_IDPARCELASEMATRASO
	 * 
	 * @author Vivianne Sousa
	 * @date 10/02/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Cole??o de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection obterContasComParcelasEmAtrasoDoParcelamento(
			Integer idImovel, Integer refInicialInformada,
			Integer refFinalInformada) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			// consulta =
			// "select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada  "
			// +
			// " and exists (select dbcb_id from faturamento.debito_cobrado d "
			// + " 	        where d.cnta_id = c.cnta_id "
			// + " 		    and dbtp_id = :idDebitoTipo "
			// + " 		    and d.dbac_id in (select dbac_id "
			// + "								  from faturamento.debito_a_cobrar_historico h "
			// + "								  where h.parc_id = :idParcelamento) "
			// + " 		    ) ";

			// consulta =
			// " select c.cnta_id as idConta from faturamento.conta c "
			// +
			// " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
			// + " and current_timestamp > cnta_dtvencimentoconta "
			// +
			// " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
			// +
			// "                where dbtp_id = :idDebitoTipo and d.dbac_id in (select dbac_id  "
			// +
			// "                                                     from faturamento.debito_a_cobrar_historico h "
			// +
			// "                                                     where h.parc_id = :idParcelamento) )"
			// ;

			consulta = " select c.cnta_id as idConta from faturamento.conta c "
					+ " where cnta_amreferenciaconta between :refInicialInformada and :refFinalInformada "
					+ " and current_timestamp > cnta_dtvencimentoconta "
					+ " and imov_id = :idImovel "
					+ " and cnta_id in(select cnta_id from faturamento.debito_cobrado d "
					+ "                where dbtp_id = :idDebitoTipo )";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("refInicialInformada", refInicialInformada)
					.setInteger("refFinalInformada", refFinalInformada)
					.setInteger("idDebitoTipo", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0880] Gerar Movimento de Extens?o de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa as contas associadas ao im?vel
	 * 
	 * @author: R?mulo Aur?lio
	 * @throws SQLException
	 * @date: 13/02/2009
	 */
	public void inserirMovimentoExtensaoContasEmCobranca(Integer idLocalidade,
			Integer idPerfil) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		// Collection<Object[]> retorno = null;
		String consulta = null;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();

		try {
			stmt = con.createStatement();
			String sequence = Util
					.obterNextValSequence("cobranca.seq_empresa_cobranca_conta");
			String dataAtualBanco = Util.obterSQLDataAtual();
			consulta = "INSERT into cobranca.empresa_cobranca_conta ( ecco_id,"
					+ "empr_id, " + "cnta_id, " + "ecco_vloriginalconta, "
					+ "ecco_pcempresaconta, " + "ecco_tmultimaalteracao, "
					+ "cecc_id, " + "ecco_icpagamentovalido, " + "ccce_id, "
					+ "imov_id," + "ecco_amreferenciaconta,"
					+ "ecco_dtenvioconta) " + "select "
					+ sequence
					+ ", "
					+ "aux.idEmpresa as idEmpresa, " // 1
					+ "cnta.cnta_id as idConta, " // 2
					+ "( coalesce( cnta.cnta_vlagua, 0 ) + "
					+ "coalesce( cnta.cnta_vlesgoto, 0 ) + "
					+ "coalesce( cnta.cnta_vldebitos, 0 ) - "
					+ "coalesce( cnta.cnta_vlcreditos, 0 ) - "
					+ "coalesce( cnta.cnta_vlimpostos, 0 ) "
					+ ") as valorConta, " // 3
					+ "aux.pcEmpresaConta as pcEmpresaConta, " // 4
					+ dataAtualBanco
					+ " as ultimaAlteracao, " // 5
					+ "aux.idComando as idComando, " // 6
					+ "1 as indicadorPagamentoValido, " // 7
					+ "aux.idExtensao as idExtensao, " // 8
					+ "aux.idImovel as idImovel," // 9
					+ "cnta.cnta_amreferenciaconta as referenciaConta, " // 10
					+ dataAtualBanco
					+ " as dataEnvioConta " // 11
					+ "from faturamento.conta cnta "
					+ "inner join (select DISTINCT ecco.imov_id as idImovel, "
					+ "ecco.empr_id as idEmpresa, "
					+ "ecco.ecco_pcempresaconta as pcEmpresaConta, "
					+ "ecco.cecc_id as idComando, "
					+ "ccce.ccce_id as idExtensao, "
					+ "ccce.ccce_amreferenciacontainicial as referencialInicialExtensao, "
					+ "ccce.ccce_amreferenciacontafinal as referencialFinalExtensao, "
					+ "coalesce(ccce.ccce_nndiasvencimentocontas, 0 )   AS numDiasVenContas "
					+ "from cobranca.cmd_empr_cobr_conta_ext ccce "
					+ "inner join cobranca.empresa_cobranca_conta ecco on ecco.cecc_id = ccce.cecc_id "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "where imov.loca_id =  "
					+ idLocalidade
					+ " "
					+ "and ccce.ccce_dtexecucao is null ";

			if (idPerfil != null) {
				consulta = consulta + " and imov.iper_id <> " + idPerfil;
			}

			if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca() == 1) {

				consulta = consulta
						+ " and ("
						+ " ccce.ccce_nndiasvencimentocontas is null or"
						+ " exists("
						+ "		select cnta2.cnta_id from faturamento.conta cnta2 "
						+ "        where cnta2.cnta_dtvencimentoconta <= to_date("
						+ dataAtualBanco
						+ ",'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas "
						+ "        and cnta2.dcst_idatual in (0,1,2) "
						+ "        and NOT EXISTS (select pgmt.cnta_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta2.cnta_id) "
						+ "        and NOT EXISTS (select ecco.cnta_id from cobranca.empresa_cobranca_conta ecco where ecco.cnta_id = cnta2.cnta_id and ecco.ecco_dtretiradaconta is null) "
						+ "        and cnta2.cnta_amreferenciaconta between ccce.ccce_amreferenciacontainicial and ccce.ccce_amreferenciacontafinal"
						+ "        and cnta2.imov_id = ecco.imov_id  "
						+ " 	  ))";

			}

			consulta = consulta
					+ " ) aux "
					+ "on aux.idimovel = cnta.imov_id "
					+ "where  cnta.cnta_amreferenciaconta between aux.referencialInicialExtensao and aux.referencialFinalExtensao "
					+ "and cnta.dcst_idatual in (0,1,2) "
					+ "and NOT EXISTS (select pgmt.cnta_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id) "
					+ "and NOT EXISTS (select ecco.cnta_id from cobranca.empresa_cobranca_conta ecco where ecco.cnta_id = cnta.cnta_id and ecco.ecco_dtretiradaconta is null) ";
			if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca() == 2) {
				consulta += " and cnta.cnta_dtvencimentoconta <= to_date("
						+ dataAtualBanco
						+ ",'YYYY-MM-DD') - aux.numDiasVenContas ";
			}

			System.out.println(consulta);

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	public Collection obterUnidadeNegocioEmpresaCobrancaConta(Integer[] ids)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select loca.uneg_id as idUnidadeNegocio "
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "where ecco.cecc_id in ( :ids ) "
					+ "group by loca.uneg_id  ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.setParameterList("ids", ids).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0891] Gerar Relatorio de Im?veis com Acordo
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioImoveisComAcordo(
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional,
			Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial,
			Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select distinct imov.imov_id as idImovel, " // 0
					+ "rota.rota_cdrota as codigoRota, "// 1
					+ "imov.imov_nnsequencialrota as sequencialRota, " // 2
					+ "last.last_dsligacaoaguasituacao as situacaoLigacaoAgua, "// 3
					+ "lest.lest_dsligacaoesgotosituacao as situacaoLigacaoEsgoto, "// 4
					+ "cbsp.cbsp_dscobrancasituacaotipo as tipoSituacaoCobranca, " // 5
					+ "cbsh.cbsh_amcobrancasituacaoinicio as anoMesInicial, "// 6
					+ "cbsh.cbsh_amcobrancasituacaofim as anoMesFinal, " // 7
					+ "cbsh.cbsh_dtfimsituacao as dataFinalSituacao, "// 8
					+ "cbsh.cbsh_dsobservacaoinforma as observacao, "// 9
					+ "usur.usur_nmusuario as nomeUsuario "// 10
					+ "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  "
					+ "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between ('"
					+ Util.getSQLDate(dataInicialAcordo).toString()
					+ "') and ('"
					+ Util.getSQLDate(dataFinalAcordo).toString()
					+ "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio
						+ " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = "
						+ idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {

				consulta = consulta + "and loca.loca_id between (' "
						+ idLocalidadeInicial + "')" + " and ('"
						+ idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null
						&& idSetorComercialFinal != null) {
					consulta = consulta
							+ "and stcm.stcm_cdsetorcomercial  between (' "
							+ idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' "
							+ rotaInicial + "')" + " and ('" + rotaFinal
							+ "') ";
				}
				if (sequencialRotaInicial != null
						&& sequencialRotaFinal != null) {
					consulta = consulta
							+ "and imov.imov_nnsequencialrota between (' "
							+ sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			consulta = consulta
					+ " "
					+ "group by imov.imov_id,rota.rota_cdrota,imov.imov_nnsequencialrota,last.last_dsligacaoaguasituacao,lest.lest_dsligacaoesgotosituacao,cbsp.cbsp_dscobrancasituacaotipo,cbsh.cbsh_amcobrancasituacaoinicio,cbsh.cbsh_amcobrancasituacaofim,cbsh.cbsh_dtfimsituacao,cbsh.cbsh_dsobservacaoinforma,usur.usur_nmusuario ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.INTEGER)
					.addScalar("sequencialRota", Hibernate.INTEGER)
					.addScalar("situacaoLigacaoAgua", Hibernate.STRING)
					.addScalar("situacaoLigacaoAgua", Hibernate.STRING)
					.addScalar("tipoSituacaoCobranca", Hibernate.STRING)
					.addScalar("anoMesInicial", Hibernate.INTEGER)
					.addScalar("anoMesFinal", Hibernate.INTEGER)
					.addScalar("dataFinalSituacao", Hibernate.DATE)
					.addScalar("observacao", Hibernate.STRING)
					.addScalar("nomeUsuario", Hibernate.STRING).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarDadosGerarRelatorioImoveisComAcordoCount(
			Integer idUnidadeNegocio, Integer idLocalidadeInicial,
			Integer idLocalidadeFinal, Integer idGerenciaRegional,
			Date dataInicialAcordo, Date dataFinalAcordo, Integer rotaInicial,
			Integer rotaFinal, Integer sequencialRotaInicial,
			Integer sequencialRotaFinal, Integer idSetorComercialInicial,
			Integer idSetorComercialFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(distinct imov.imov_id) as qtde "
					+ "from cobranca.cobranca_situacao_hist cbsh "
					+ "left join cadastro.imovel imov on imov.imov_id = cbsh.imov_id "
					+ "left join cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ "left join cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id  "
					+ "left join cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id  "
					+ "left join atendimentopublico.ligacao_agua_situacao last on last.last_id = imov.last_id "
					+ "left join atendimentopublico.ligacao_esgoto_situacao lest on lest.lest_id = imov.lest_id "
					+ "left join micromedicao.rota rota on rota.rota_id = qdra.rota_id  "
					+ "left join cobranca.cobranca_situacao_tipo cbsp on cbsp.cbsp_id = cbsh.cbsp_id "
					+ "left join seguranca.usuario usur on usur.usur_id = cbsh.usur_id  "
					+ "where cbsh.cbsh_amcobrancaretirada is null "
					+ "and cbsh.cbsh_dtfimsituacao between (' "
					+ Util.getSQLDate(dataInicialAcordo).toString()
					+ "') and ('" + Util.getSQLDate(dataFinalAcordo).toString()
					+ "') ";

			if (idUnidadeNegocio != null) {
				consulta = consulta + "and loca.uneg_id = " + idUnidadeNegocio
						+ " ";
			}

			if (idGerenciaRegional != null) {
				consulta = consulta + "and greg.greg_id = "
						+ idGerenciaRegional + " ";
			}

			if (idLocalidadeInicial != null && idLocalidadeFinal != null) {
				consulta = consulta + "and loca.loca_id between (' "
						+ idLocalidadeInicial + "')" + " and ('"
						+ idLocalidadeFinal + "') ";

				if (idSetorComercialInicial != null
						&& idSetorComercialFinal != null) {
					consulta = consulta
							+ "and stcm.stcm_cdsetorcomercial between (' "
							+ idSetorComercialInicial + "')" + " and ('"
							+ idSetorComercialFinal + "') ";
				}
				if (rotaInicial != null && rotaFinal != null) {
					consulta = consulta + "and rota.rota_id between (' "
							+ rotaInicial + "')" + " and ('" + rotaFinal
							+ "') ";
				}
				if (sequencialRotaInicial != null
						&& sequencialRotaFinal != null) {
					consulta = consulta
							+ "and imov.imov_nnsequencialrota between (' "
							+ sequencialRotaInicial + "')" + " and ('"
							+ sequencialRotaFinal + "') ";
				}

			}

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("qtde", Hibernate.INTEGER).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public CicloMetaGrupo pesquisarCicloMetaGrupoPorGrupoLocalidade(
			int idCicloMeta, int idGrupo, int idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CicloMetaGrupo retorno = null;
		String consulta = null;

		try {

			consulta = "select cmg " + "from gcom.cobranca.CicloMetaGrupo cmg "
					+ "where cmg.cobrancaGrupo.id = :idCobGrupo "
					+ "and cmg.cicloMeta.id = :idCicloMeta "
					+ "and cmg.localidade.id = :idLocalidade ";

			retorno = (CicloMetaGrupo) session.createQuery(consulta)
					.setInteger("idCobGrupo", idGrupo)
					.setInteger("idCicloMeta", idCicloMeta)
					.setInteger("idLocalidade", idLocalidade).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public CicloMeta pesquisarMetaCiclo(int anoMes, int idCobrancaAcao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		CicloMeta retorno = null;
		String consulta = null;

		try {

			consulta = "select cm " + "from gcom.cobranca.CicloMeta cm "
					+ "where cm.cobrancaAcao.id = :idCobAcao "
					+ "and cm.anoMesReferencia = :anoMes ";

			retorno = (CicloMeta) session.createQuery(consulta)
					.setInteger("idCobAcao", idCobrancaAcao)
					.setInteger("anoMes", anoMes).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGeradosAcimaValorLimite(
			Integer idCAAC, Integer idCACM, Integer idLocalidade,
			BigDecimal valorLimite) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) "
					+ "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = "
						+ idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			consulta += " and cd.valorDocumento >= :valorLimite ";

			retorno = (Integer) session.createQuery(consulta)
					.setBigDecimal("valorLimite", valorLimite).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarQuantidadeDocumentosGerados(Integer idCAAC,
			Integer idCACM, Integer idLocalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = "select count(cd.id) "
					+ "from gcom.cobranca.CobrancaDocumento cd where ";
			if (idCAAC != null) {
				consulta += " cd.cobrancaAcaoAtividadeCronograma.id = "
						+ idCAAC;
			} else if (idCACM != null) {
				consulta += " cd.cobrancaAcaoAtividadeComando.id = " + idCACM;
			}
			if (idLocalidade != null) {
				consulta += " and cd.localidade.id = " + idLocalidade;
			}

			retorno = (Integer) session.createQuery(consulta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection pesquisarDocumentosCobrancaExcedentes(Integer idCAAC,
			Integer idCACM, int quantidadeParaRemover, Integer idLocalidade)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		Collection documentos = null;

		try {

			queryConsulta = "select cbdo_id as id, cbdo_vldocumento as valor from cobranca.Cobranca_Documento cd where ";
			if (idCAAC != null) {
				queryConsulta += " cd.caac_id = " + idCAAC;
			} else if (idCACM != null) {
				queryConsulta += " cd.cacm_id = " + idCACM;
			}
			if (idLocalidade != null) {
				queryConsulta += " and cd.loca_id = " + idLocalidade;
			}
			queryConsulta += " and ROWNUM <= " + quantidadeParaRemover
					+ " order by cd.cbdo_vldocumento";

			documentos = session.createSQLQuery(queryConsulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return documentos;
	}

	public void adicionarMetaCicloLocalidade(int idMetaCiclo, int idGrupo,
			int idLocalidade, int quantidadeASerAdicionada)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String query = null;

		try {

			query = "update gcom.cobranca.CicloMetaGrupo set clmg_qtmetaajustada = (clmg_qtmetaajustada + "
					+ quantidadeASerAdicionada
					+ "), clmg_ultimaalteracao = :data where "
					+ " clmt_id = "
					+ idMetaCiclo
					+ " and loca_id = "
					+ idLocalidade
					+ " and cbgr_id = "
					+ "(SELECT min(cm.cobrancaGrupo.id) FROM gcom.cobranca.CicloMetaGrupo cm where "
					+ " cm.cicloMeta.id = "
					+ idMetaCiclo
					+ " and cm.localidade.id = "
					+ idLocalidade
					+ " and cm.cobrancaGrupo.id > "
					+ idGrupo
					+ " and cm.quantidadeDocumentosRestantes is null)";

			session.createQuery(query).setTimestamp("data", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	public Collection<CicloMetaGrupo> pesquisarCicloMetaGrupoPorCicloMeta(
			Integer idCicloMeta, Integer idGrupo)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String queryConsulta = null;
		List<CicloMetaGrupo> idsMetas = null;

		try {

			queryConsulta = "select cmg from gcom.cobranca.CicloMetaGrupo cmg where "
					+ " cmg.cicloMeta.id = "
					+ idCicloMeta
					+ " and cmg.cobrancaGrupo.id = "
					+ idGrupo
					+ " order by cmg.localidade.id ";

			idsMetas = (List) session.createQuery(queryConsulta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return idsMetas;
	}

	/**
	 * 
	 * [UC0000] - Gerar Metas do Cilo Pesquisar a quantidade de imoveis em cada
	 * grupo/localidade
	 * 
	 * @author Francisco do Nascimento
	 * @date 23/04/2009
	 * 
	 * @param idsLast
	 *            Colecao de ids de situacao de liga??o de ?gua
	 * @return Colecao no formato [idGrupo, idLocalidade, qtdImoveis]
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarQuantidadeImoveisPorGrupoLocalidade(
			Collection idsLast) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Collection colecao = null;

		try {
			query = "SELECT r.cbgr_id as idGrupo, l.loca_id as idLocalidade, "
					+ "count(imov_id) as QtdImoveis FROM micromedicao.rota r "
					+ "join cadastro.quadra q on r.rota_id = q.rota_id "
					+ "join cadastro.setor_comercial sc on sc.stcm_id = q.stcm_id "
					+ "join cadastro.localidade l on sc.loca_id = l.loca_id "
					+ "join cadastro.imovel i on i.qdra_id = q.qdra_id "
					+ "where i.last_id in (:idsLast) "
					+ "group by r.cbgr_id, l.loca_id "
					+ "order by r.cbgr_id, l.loca_id ";

			colecao = (List) session.createSQLQuery(query)
					.addScalar("idGrupo", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setParameterList("idsLast", idsLast).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return colecao;

	}

	/**
	 * [UC0216] Calcular Acrescimo por Impontualidade
	 * 
	 * Caso o im?vel tenha d?bito autom?tico e o recebimento, mesmo em atraso,
	 * tenha sido atrav?s de d?bito autom?tico, o sistema n?o calcula os
	 * acr?scimos de impontualidade
	 * 
	 * (ARMV_DSIDENTIFICACAOSERVICO da tabela ARRECADADOR_MOVIMENTO com valor
	 * igual a "DEBITO AUTOMATICO" com ARMV_ID = ARMV_ID da tabela
	 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_ID = AMIT_ID da tabela PAGAMENTO com
	 * CNTA_ID = CNTA_ID recebido)
	 * 
	 * @author Raphael Rossiter
	 * @date 12/05/2009
	 * 
	 * @param idConta
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoDeContaPorDebitoAutomatico(Integer idConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT COUNT(*) FROM Pagamento pgmt "
					+ "INNER JOIN pgmt.contaGeral cntaGeral "
					+ "INNER JOIN cntaGeral.conta cnta "
					+ "INNER JOIN pgmt.arrecadadorMovimentoItem amit "
					+ "INNER JOIN amit.arrecadadorMovimento armv "
					+ "WHERE cnta.id = :idConta AND armv.descricaoIdentificacaoServico = :debitoAutomatico ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setString("debitoAutomatico",
							ConstantesSistema.DEBITO_AUTOMATICO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0868] Gerar Relatorio de Pagamentos das Contas em Cobranca por Empresa
	 * 
	 * @author: R?mulo Aur?lio
	 * @date: 08/01/2009
	 */
	public Collection pesquisarDadosGerarRelatorioPagamentosContasCobrancaEmpresaOpcaoTotalizacao(
			RelatorioPagamentosContasCobrancaEmpresaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select im.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnta.cnta_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 5
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 6
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "lc.loca_id as idLocalidade," // 8
					+ "lc.loca_nmlocalidade as nomeLocalidade, " // 9
					+ "gr.greg_id as idGerenciaRegional, " // 10
					+ "gr.greg_nmregional as nomeGerenciaRegional, " // 11
					+ "un.uneg_id as idUnidadeNegocio, " // 12
					+ "un.uneg_nmunidadenegocio as nomeUnidadeNegocio, " // 13
					+ "rt.rota_cdrota as idRota, " // 14
					+ "eccp_ictipopagamento as indicadorTipoPagamento," // 15
					+ "eccp_nnparcelaatual as numeroParcelaAtual, " // 16
					+ "eccp_nntotalparcelas as numeroTotalParcelas "// 17
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta  cnta "
					+ "on cnta.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id ";

			if (helper.getReferenciaPagamentoInicial() != helper
					.getReferenciaPagamentoFinal()) {
				consulta = consulta + "where eccp_ampagamento between "
						+ helper.getReferenciaPagamentoInicial() + " and "
						+ helper.getReferenciaPagamentoFinal() + " ";
			} else {
				consulta = consulta + "where eccp_ampagamento = "
						+ helper.getReferenciaPagamentoInicial() + " ";
			}

			consulta = consulta
					+ "group by im.imov_id, clie_nmcliente, cnta.cnta_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, cc.ecco_pcempresaconta, lc.loca_id, lc.loca_nmlocalidade, gr.greg_id, gr.greg_nmregional, un.uneg_id, un.uneg_nmunidadenegocio, rt.rota_cdrota, eccp_ictipopagamento, eccp_nnparcelaatual,eccp_nntotalparcelas ";

			consulta = consulta
					+ "UNION "
					+ "select im.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnhi.cnhi_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 5
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 6
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 7
					+ "lc.loca_id as idLocalidade," // 8
					+ "lc.loca_nmlocalidade as nomeLocalidade, " // 9
					+ "gr.greg_id as idGerenciaRegional, " // 10
					+ "gr.greg_nmregional as nomeGerenciaRegional, " // 11
					+ "un.uneg_id as idUnidadeNegocio, " // 12
					+ "un.uneg_nmunidadenegocio as nomeUnidadeNegocio, " // 13
					+ "rt.rota_cdrota as idRota, " // 14
					+ "eccp_ictipopagamento as indicadorTipoPagamento," // 15
					+ "eccp_nnparcelaatual as numeroParcelaAtual, " // 16
					+ "eccp_nntotalparcelas as numeroTotalParcelas "// 17
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta_historico cnhi "
					+ "on cnhi.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id ";

			if (helper.getReferenciaPagamentoInicial() != helper
					.getReferenciaPagamentoFinal()) {
				consulta = consulta + "where eccp_ampagamento between "
						+ helper.getReferenciaPagamentoInicial() + " and "
						+ helper.getReferenciaPagamentoFinal() + " ";
			} else {
				consulta = consulta + "where eccp_ampagamento = "
						+ helper.getReferenciaPagamentoInicial() + " ";
			}

			if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegional")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegionalLocalidade")) {

				consulta = consulta + " and gr.greg_id = "
						+ helper.getCodigoGerencia();

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"localidade")) {

				consulta = consulta + " and lc.loca_id = "
						+ helper.getCodigoLocalidade();
			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"unidadeNegocio")) {

				consulta = consulta + "and uneg.uneg_id = "
						+ helper.getUnidadeNegocio();

			}

			consulta = consulta
					+ "group by im.imov_id, clie_nmcliente, cnhi.cnhi_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, cc.ecco_pcempresaconta, lc.loca_id, lc.loca_nmlocalidade, gr.greg_id, gr.greg_nmregional, un.uneg_id, un.uneg_nmunidadenegocio, rt.rota_cdrota, eccp_ictipopagamento, eccp_nnparcelaatual,eccp_nntotalparcelas ";

			if (helper.getOpcaoTotalizacao().equalsIgnoreCase("estadoGerencia")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";
			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"estadoLocalidade")) {

				consulta = consulta
						+ " order by idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegional")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"gerenciaRegionalLocalidade")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"localidade")) {

				consulta = consulta
						+ " order by idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"estadoUnidadeNegocio")) {

				consulta = consulta
						+ " order by idGerenciaRegional, idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			} else if (helper.getOpcaoTotalizacao().equalsIgnoreCase(
					"unidadeNegocio")) {

				consulta = consulta
						+ " order by idUnidadeNegocio, idLocalidade, idImovel, anoMesConta ";

			}

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nomeGerenciaRegional", Hibernate.STRING)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idRota", Hibernate.INTEGER)
					.addScalar("indicadorTipoPagamento", Hibernate.SHORT)
					.addScalar("numeroParcelaAtual", Hibernate.INTEGER)
					.addScalar("numeroTotalParcelas", Hibernate.INTEGER)
					.setInteger("idEmpresa", helper.getEmpresa().getId())
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idParcelamento
	 * 
	 * @return Cole??o de Debitos A Cobrar
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitosACobrarParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select dac  "
					+ "from DebitoACobrar dac "
					+ "inner join dac.debitoCreditoSituacaoAtual debitoCreditoSituacaoAtual "
					+ "inner join dac.parcelamento parcelamento "
					+ "inner join dac.debitoTipo debitoTipo "
					+ "where parcelamento.id = :idParcelamento "
					+ "and dac.numeroPrestacaoCobradas < (dac.numeroPrestacaoDebito - coalesce(dac.numeroParcelaBonus,0)) "
					+ "and dac.debitoCreditoSituacaoAtual = :normal "
					+ "and dac.id not in (select dbac.id from Pagamento pgmt inner join pgmt.debitoACobrarGeral dbac where dbac.id = dac.id) "
					+ "and debitoTipo.id in (:jurosSobreParc, :parcContas, :parcAcrescimos) ";

			retorno = session
					.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("jurosSobreParc",
							DebitoTipo.JUROS_SOBRE_PARCELAMENTO)
					.setInteger("parcContas", DebitoTipo.PARCELAMENTO_CONTAS)
					.setInteger("parcAcrescimos",
							DebitoTipo.PARCELAMENTO_ACRESCIMOS_IMPONTUALIDADE)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos Author: Vivianne Sousa Data:
	 * 13/05/2009
	 * 
	 * @param idImovel
	 * @param referencia
	 * 
	 * @return idParcelamento
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarIdParcelamentoNormal(Integer idImovel,
			Integer referencia) throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select max(p.parc_id) as idParcelamento "
					+ " from cobranca.parcelamento p "
					+ " where imov_id = :idImovel "
					+ " and p.pcst_id = :normal "
					+ " and p.parc_id in(select pi.parc_id "
					+ " from cobranca.parcelamento_item pi "
					+ " inner join faturamento.conta_historico cnta on pi.cnta_id = cnta.cnta_id "
					+ " where "
					+ " cnta.cnhi_amreferenciaconta <= :referencia and "
					+ " p.parc_id = pi.parc_id )";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("normal", ParcelamentoSituacao.NORMAL)
					.setInteger("referencia", referencia).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos Author: Vivianne Sousa Data:
	 * 18/05/2009
	 */
	public BigDecimal pesquisarValorDebitoCobradoParcelamentoConta(
			Integer idConta) throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "SELECT sum(dbcb.valorPrestacao) "
					+ "FROM DebitoCobrado dbcb "
					+ "INNER JOIN dbcb.financiamentoTipo fntp "
					+ "WHERE dbcb.conta.id = :idConta "
					+ "and (fntp.id = :parcAgua or "
					+ "fntp.id = :parcEsgoto or fntp.id = :parcServico or "
					+ "fntp.id = :jurosParc)";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("idConta", idConta)
					.setInteger("parcAgua",
							FinanciamentoTipo.PARCELAMENTO_AGUA.intValue())
					.setInteger("parcEsgoto",
							FinanciamentoTipo.PARCELAMENTO_ESGOTO.intValue())
					.setInteger("parcServico",
							FinanciamentoTipo.PARCELAMENTO_SERVICO.intValue())
					.setInteger("jurosParc",
							FinanciamentoTipo.JUROS_PARCELAMENTO.intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0878] Gerar Rela??o de Parcelamento - Vis?o Analitica
	 * 
	 * @author Bruno Barros
	 * 
	 * @date 05/06/2009
	 */
	public Integer pesquisarQuantidadeContasNaoPagasParcelamento(
			Integer idParcelamento, Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();
		String consulta = null;
		try {
			consulta = "select \n"
					+ "  count( distinct cnta.cnta_id ) as quantidade \n"
					+ "from \n"
					+ "  cobranca.parcelamento parc \n"
					+ "  inner join faturamento.conta cnta on ( cnta.imov_id = parc.imov_id and cnta.cnta_amreferenciaconta > parc.parc_amreferenciafaturamento ) \n"
					+ "  inner join faturamento.debito_cobrado deCo on ( deCo.cnta_id = cnta.cnta_id ) \n"
					+ "where \n"
					+ "  deCo.dbtp_id in ( 40, 41, 42, 43, 45, 47,50 ) and \n"
					+ "  deCo.dbac_id = :idDebitoACobrar and \n"
					+

					"  not exists ( select 'a' from arrecadacao.pagamento pgto where pgto.cnta_id = cnta.cnta_id ) and \n"
					+ "  parc.parc_id = :idParcelamento \n";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idParcelamento", idParcelamento)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

			if (retorno == null) {
				retorno = 0;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * retorna id da ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 08/11/2006
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarResolucaoDiretoriaComPercentualDoacao()
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd.id "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.percentualDoacao is not null or rd.percentualDoacao > :zero ";

			retorno = (Integer) session.createQuery(consulta)
					.setBigDecimal("zero", new BigDecimal("0.00"))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// //////////////////////////////////////////////////////////
	/**
	 * retorna cole??o de ids de Rota de um Grupo de faturamento
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Crian?a para
	 * Negocia??o a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 11/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarRotasPorGrupoFaturamento(
			Integer idGrupoFaturamento) throws ErroRepositorioException {

		Collection<Integer> rotas = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct(rota.id) " + "from Rota rota "
					+ "inner join rota.faturamentoGrupo ftgr "
					+ "where ftgr.id = :idFaturamentoGrupo ";
			// + "and rota.id = 3367";//apagar

			rotas = session.createQuery(consulta)
					.setInteger("idFaturamentoGrupo", idGrupoFaturamento)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return rotas;
	}

	/**
	 * retorna cole??o de idImovel de uma Rota
	 * 
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Crian?a para
	 * Negocia??o a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 12/06/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosImoveisPorRota(Integer idRota)
			throws ErroRepositorioException {

		Collection dados = new ArrayList();
		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select "
					+ " imov.imov_id as idImovel, "
					+ " imov.loca_id as idLocalidade, "
					+ " imov.last_id as idLigacaoAguaSituacao,"
					+ " imov.lest_id as idLigacaoEsgotoSituacao,"
					+ " imov.iper_id as idImovelPerfil,"
					+ " setor.stcm_id as idSetor,"
					+ " setor.stcm_cdsetorcomercial as codigoSetor,"
					+ " qdra.qdra_id as idQuadra,"
					+ " qdra_nnquadra as numeroQuadra, "
					+ " imov.imov_nnreparcmtconsec as numeroReparcelCons "
					+ " from cadastro.imovel imov"
					+ " left join cadastro.setor_comercial setor on imov.stcm_id= setor.stcm_id"
					+ " left join cadastro.quadra qdra on imov.qdra_id= qdra.qdra_id"
					+ " left join micromedicao.rota rota on qdra.rota_id= rota.rota_id"
					+ " where rota.rota_id =  :idRota "
					+ " and imov_icexclusao = 2"
					+ " and ((imov.last_id in (:emFiscalizacao, :cortado, :suprimido, :suprimidoParc, :suprimidoParcPedido))"
					+ " or (imov.lest_id= :ligado and imov.last_id in (:potencial , :factivel))) ";

			dados = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("idLigacaoAguaSituacao", Hibernate.INTEGER)
					.addScalar("idLigacaoEsgotoSituacao", Hibernate.INTEGER)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("idSetor", Hibernate.INTEGER)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("idQuadra", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("numeroReparcelCons", Hibernate.SHORT)
					.setInteger("idRota", idRota)
					.setInteger("emFiscalizacao",
							LigacaoAguaSituacao.EM_FISCALIZACAO)
					.setInteger("cortado", LigacaoAguaSituacao.CORTADO)
					.setInteger("suprimido", LigacaoAguaSituacao.SUPRIMIDO)
					.setInteger("suprimidoParc", LigacaoAguaSituacao.SUPR_PARC)
					.setInteger("suprimidoParcPedido",
							LigacaoAguaSituacao.SUPR_PARC_PEDIDO)
					.setInteger("potencial", LigacaoAguaSituacao.POTENCIAL)
					.setInteger("factivel", LigacaoAguaSituacao.FACTIVEL)
					.setInteger("ligado", LigacaoEsgotoSituacao.LIGADO).list();

			if (dados != null && !dados.isEmpty()) {
				retorno = new ArrayList();

				Iterator iter = dados.iterator();

				while (iter.hasNext()) {
					Object[] dadosImovel = (Object[]) iter.next();
					Imovel imovel = new Imovel();
					Localidade loca = new Localidade();
					LigacaoAguaSituacao last = new LigacaoAguaSituacao();
					LigacaoEsgotoSituacao lest = new LigacaoEsgotoSituacao();
					ImovelPerfil iper = new ImovelPerfil();
					SetorComercial setor = new SetorComercial();
					Quadra quadra = new Quadra();

					imovel.setId((Integer) dadosImovel[0]);

					loca.setId((Integer) dadosImovel[1]);
					imovel.setLocalidade(loca);

					last.setId((Integer) dadosImovel[2]);
					imovel.setLigacaoAguaSituacao(last);

					lest.setId((Integer) dadosImovel[3]);
					imovel.setLigacaoEsgotoSituacao(lest);

					iper.setId((Integer) dadosImovel[4]);
					imovel.setImovelPerfil(iper);

					setor.setId((Integer) dadosImovel[5]);
					setor.setCodigo((Integer) dadosImovel[6]);
					imovel.setSetorComercial(setor);

					quadra.setId((Integer) dadosImovel[7]);
					quadra.setNumeroQuadra((Integer) dadosImovel[8]);
					imovel.setQuadra(quadra);

					if (dadosImovel[9] != null) {
						imovel.setNumeroReparcelamentoConsecutivos((Short) dadosImovel[9]);
					}

					retorno.add(imovel);
				}

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Crian?a para
	 * Negocia??o a Vista
	 * 
	 * @author Vivianne Sousa
	 * @date 17/06/2009
	 */
	public void deletarCobrancaDocumentoECobrancaDocumentoItem(Integer idRota,
			Integer documentoTipo) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			Collection idsCobrancaDocumento = null;
			String consulta = " select distinct(cd.id) "
					+ " from CobrancaDocumento cd "
					+ " inner join cd.documentoTipo dt "
					+ " inner join cd.quadra qu "
					+ " inner join qu.rota rota "
					+ " where rota.id = :idRota "
					+ " and  dt.id = :documentoTipo "
					+ " and not exists (select id from Pagamento p where p.cobrancaDocumento.id = cd.id ) ";

			idsCobrancaDocumento = session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("documentoTipo", documentoTipo).list();

			if (idsCobrancaDocumento != null && !idsCobrancaDocumento.isEmpty()) {

				// deleta os itens dos documentos de cobran?a
				String delete = "delete CobrancaDocumentoItem cdi "
						+ "where cdi.cobrancaDocumento.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete)
						.setParameterList("idsCobrancaDocumento",
								idsCobrancaDocumento).executeUpdate();

				// deleta os documentos de cobran?a
				String delete2 = "delete CobrancaDocumento cd "
						+ "where cd.id in (:idsCobrancaDocumento) ";

				session.createQuery(delete2)
						.setParameterList("idsCobrancaDocumento",
								idsCobrancaDocumento).executeUpdate();

			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da crian?a para
	 * Negocia??o a Vista
	 * 
	 * O sistema ordena a lista de documentos de cobran?a por empresa (EMPR_ID
	 * da tabela DOCUMENTO_COBRANCA), localidade (LOCA_ID), setor
	 * (CBDO_CDSETORCOMERCIAL), quadra (CBDO_NNQUADRA), lote e sublote
	 * (IMOV_NNLOTE e IMOV_SUBLOTE da tabela IMOVEL com IMOV_ID da tabela
	 * DOCUMENTO_COBRANCA)
	 * 
	 * @author Vivianne Sousa
	 * @data 17/06/2009
	 * 
	 * @param idRota
	 *            , idDocumentoTipo
	 * @return Collection<CobrancaDocumento>
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoParaEmitir(
			Integer idRota, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			// consulta = "SELECT cbdo "
			// + "FROM CobrancaDocumento as cbdo "
			// + "LEFT JOIN fetch cbdo.empresa as empr "
			// + "LEFT JOIN fetch cbdo.localidade as loca "
			// + "LEFT JOIN fetch cbdo.imovel as imov "
			// + "LEFT JOIN fetch cbdo.quadra qdr "
			// + "LEFT JOIN fetch qdr.rota rot "
			// + "LEFT JOIN cbdo.documentoTipo as docTipo "
			// + "WHERE "
			// + "rot.id = :idRota and docTipo = :idDocumentoTipo "
			// +
			// "ORDER BY empr.id, loca.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
			// + "imov.lote, imov.subLote, cbdo.id";

			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.empresa empr "
					+ "LEFT JOIN cbdo.localidade loca "
					+ "LEFT JOIN fetch cbdo.imovel imov "
					+ "LEFT JOIN fetch cbdo.quadra qdr "
					+ "LEFT JOIN fetch qdr.rota rot "
					+ "LEFT JOIN cbdo.documentoTipo docTipo "
					+ "WHERE rot.id = :idRota AND "
					+ "cbdo.documentoTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("idRota", idRota)
					.setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Seleciona os itens do documento de cobran?a correspondentes a debito a
	 * cobrar
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da crian?a para
	 * Negocia??o a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 17/06/2009
	 */
	public BigDecimal selecionarValorTotalCobrancaDocumentoItemReferenteDebito(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		BigDecimal retorno = BigDecimal.ZERO;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT sum(cdit.valorItemCobrado) "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN cdit.debitoACobrarGeral debitoGeral "
					+ "LEFT JOIN debitoGeral.debitoACobrar  debito "
					+ "LEFT JOIN debito.debitoCreditoSituacaoAtual "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "debito.id IS NOT NULL ";

			retorno = (BigDecimal) session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).uniqueResult();

			if (retorno == null) {
				retorno = BigDecimal.ZERO;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna a Data de Vencimento da Rota (FACR_DTCONTAVENCIMENTO da tabela
	 * FATURAMENTO_ATIV_CRON_ROTA com ROTA_ID = ROTA_ID j? pesquisado antes e
	 * FTAC_ID = FTAC_ID da tabela FATURAMENTO_ATIVIDADE_CRONOGRAMA e FTAT_ID =
	 * 5 e FTCM_ID = FTCM_ID da tabela FATURAMENTO_GRUPO_CRONOGRAMA_MENSAL com
	 * FTGR_ID = ao grupo informado e FTCM_AMREFERENCIA = anoMesFaturamento da
	 * tabela SISTEMA_PARAMETROS )
	 * 
	 * [UC0910] Emitir Cartas da Campanha de Solidariedade da crian?a para
	 * Negocia??o a Vista
	 * 
	 * @author Vivianne Sousa
	 * @data 22/06/2009
	 */
	public Date pesquisarDataVencimentoRota(Integer idRota,
			Integer anoMesFaturamento, Integer grupoFaturamento)
			throws ErroRepositorioException {

		Date retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = " select facr.facr_dtcontavencimento as vencimento "
					+ " from faturamento.fatur_ativ_cron_rota facr "
					+ " inner join faturamento.fatur_ativ_cronograma fac on facr.ftac_id = fac.ftac_id "
					+ " inner join faturamento.fatur_grupo_crg_mensal ftcm on fac.ftcm_id = ftcm.ftcm_id "
					+ " where facr.rota_id = :idRota "
					+ " and fac.ftat_id = 5 "
					+ " and ftcm.ftcm_amreferencia = :anoMesFaturamento "
					+ " and ftcm.ftgr_id = :grupoFaturamento ";

			retorno = (Date) session.createSQLQuery(consulta)
					.addScalar("vencimento", Hibernate.DATE)
					.setInteger("idRota", idRota)
					.setInteger("anoMesFaturamento", anoMesFaturamento)
					.setInteger("grupoFaturamento", grupoFaturamento)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Esse metodo pesquisa as faturas de um cliente respons?vel federal, de
	 * acordo com o Mes/Ano, e de acordo com o id do Cliente de acordo com o
	 * RELATORIO SINTETICO DO UC0919
	 * 
	 * Se os dois parametros tiverem sido passados, procura usando os dois
	 * parametros, sen?o usa apenas o parametro anoMes que ? obrigatorio
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 08/07/2009
	 * 
	 * @param Integer
	 *            anoMes
	 * @param Integer
	 *            clienteID
	 * @return Collection - uma colecao de objetos Fatura
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaFaturaClienteResponsavelFederal(Integer anoMes,
			Integer clienteID) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT fatura " + "FROM Fatura fatura "
					+ "INNER JOIN fetch fatura.cliente cliente "
					+ "INNER JOIN fetch cliente.clienteTipo clienteTipo "
					+ "INNER JOIN fetch clienteTipo.esferaPoder esferaPoder "
					+ "WHERE  fatura.anoMesReferencia = :anoMes "
					+ "AND  esferaPoder.id = :idEsferaPoder ";

			if (clienteID != null) {
				consulta += " and cliente.id = :clienteID ";
				consulta += " ORDER BY fatura.id";

				retorno = (Collection) session.createQuery(consulta)
						.setInteger("clienteID", clienteID)
						.setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL)
						.list();
			} else {
				consulta += " ORDER BY fatura.id";
				retorno = (Collection) session.createQuery(consulta)
						.setInteger("anoMes", anoMes)
						.setInteger("idEsferaPoder", EsferaPoder.FEDERAL)
						.list();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura ? obrigat?ria.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Jose Guilherme Macedo Vieira, Fernando Fontelles Filho
	 * @date 08/07/2009, 28/09/2010
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederal(
			/* Integer idFatura */Integer anoMesFerencia, Integer idCliente/*
																			 * Integer
																			 * idImovel
																			 */)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = " SELECT imtp.imtp_id                                                  AS "
						+ "        impostoTipo, "
						+ "        imtp.imtp_dsimposto                                           AS "
						+ "        descricaoImposto, "
						+ "        cnid.cnid_pcaliquota                                          AS "
						+ "        percAliquota, "
						+ "        Sum(cnid.cnid_vlimposto)                                      AS "
						+ "        valorImposto, "
						+ "        clie.clie_id                                                  AS cliente, "
						+ "        clie_nmcliente                                                AS "
						+ "        nomeCliente, "
						+ "        Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "                + cnta.cnta_vldebitos ) - "
						+ "              ( cnta.cnta_vlcreditos + cnta.cnta_vlimpostos ) ))      AS "
						+ "        valorFatura, "
						+ "        clie.clie_nncnpj                                              AS cnpj, "
						+ "        Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "                + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS "
						+ "        baseCalculo "
						+ " FROM   faturamento.conta_impostos_deduzidos cnid "
						+ "        INNER JOIN faturamento.conta cnta "
						+ "                ON ( cnid.cnta_id = cnta.cnta_id ) "
						+ "        INNER JOIN cadastro.cliente_conta clct "
						+ "                ON ( cnta.cnta_id = clct.cnta_id "
						+ "                     AND clct.crtp_id = :cliRelacaoTipo ) "
						+ "        INNER JOIN cadastro.cliente clie "
						+ "                ON ( clct.clie_id = clie.clie_id ) "
						+ "        INNER JOIN cadastro.cliente_tipo cltp "
						+ "                ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "        INNER JOIN faturamento.imposto_tipo imtp "
						+ "                ON ( cnid.imtp_id = imtp.imtp_id ) "
						+ " WHERE  clct.clie_id = :idCliente "
						+ "        AND cnta.cnta_id IN (SELECT idconta "
						+ "                             FROM   (SELECT imovel, "
						+ "                                            referencia, "
						+ "                                            Min(cnta_id) AS idconta "
						+ "                                     FROM   (SELECT conta.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ "                                                    conta.cnta_amreferenciaconta "
						+ "                                                    AS "
						+ "                                                    referencia, "
						+ "                                                    conta.cnta_id "
						+ "                                             FROM   faturamento.conta conta "
						+ "                                             WHERE  conta.cnta_amreferenciaconta "
						+ "                                                    = "
						+ "                                                    :anoMesReferencia "
						+ "                                             UNION ALL "
						+ "                                             SELECT contaHist.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ " contaHist.cnhi_amreferenciaconta AS "
						+ " referencia, "
						+ " contaHist.cnta_id "
						+ " FROM   faturamento.conta_historico "
						+ " contaHist "
						+ " WHERE  contaHist.cnhi_amreferenciaconta = "
						+ " :anoMesReferencia) a "
						+ " GROUP  BY imovel, "
						+ " referencia) b) "
						+ " GROUP BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cnid.cnid_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ " UNION ALL "
						+ " SELECT imtp.imtp_id                                                  AS "
						+ "        impostoTipo, "
						+ "        imtp.imtp_dsimposto                                           AS "
						+ "        descricaoImposto, "
						+ "        cidh.cidh_pcaliquota                                          AS "
						+ "        percAliquota, "
						+ "        Sum(cidh.cidh_vlimposto)                                      AS "
						+ "        valorImposto, "
						+ "        clie.clie_id                                                  AS cliente, "
						+ "        clie_nmcliente                                                AS "
						+ "        nomeCliente, "
						+ "        Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "                + cnhi.cnhi_vldebitos ) - "
						+ "              ( cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos ) ))      AS "
						+ "        valorFatura, "
						+ "        clie.clie_nncnpj                                              AS cnpj, "
						+ "        Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "                + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) )) AS "
						+ "        baseCalculo "
						+ " FROM   faturamento.conta_impostos_dedz_hist cidh "
						+ "        INNER JOIN faturamento.conta_historico cnhi "
						+ "                ON ( cidh.cnta_id = cnhi.cnta_id ) "
						+ "        INNER JOIN cadastro.cliente_conta_historico clch "
						+ "                ON ( cnhi.cnta_id = clch.cnta_id "
						+ "                     AND clch.crtp_id = :cliRelacaoTipo ) "
						+ "        INNER JOIN cadastro.cliente clie "
						+ "                ON ( clch.clie_id = clie.clie_id ) "
						+ "        INNER JOIN cadastro.cliente_tipo cltp "
						+ "                ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "        INNER JOIN faturamento.imposto_tipo imtp "
						+ "                ON ( cidh.imtp_id = imtp.imtp_id ) "
						+ " WHERE  clch.clie_id = :idCliente "
						+ "        AND cnhi.cnta_id IN (SELECT idconta "
						+ "                             FROM   (SELECT imovel, "
						+ "                                            referencia, "
						+ "                                            Min(cnta_id) AS idconta "
						+ "                                     FROM   (SELECT conta.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ "                                                    conta.cnta_amreferenciaconta "
						+ "                                                    AS "
						+ "                                                    referencia, "
						+ "                                                    conta.cnta_id "
						+ "                                             FROM   faturamento.conta conta "
						+ "                                             WHERE  conta.cnta_amreferenciaconta "
						+ "                                                    = "
						+ "                                                    :anoMesReferencia "
						+ "                                             UNION ALL "
						+ "                                             SELECT contaHist.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ " contaHist.cnhi_amreferenciaconta AS "
						+ " referencia, "
						+ " contaHist.cnta_id "
						+ " FROM   faturamento.conta_historico "
						+ " contaHist "
						+ " WHERE  contaHist.cnhi_amreferenciaconta = "
						+ " :anoMesReferencia) a "
						+ " GROUP  BY imovel, "
						+ " referencia) b) "
						+ " GROUP BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cidh.cidh_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ " ORDER  BY cliente, " + "           impostotipo   ";

				query = session
						.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING)
						.setShort("cliRelacaoTipo",
								ClienteRelacaoTipo.RESPONSAVEL)
						.setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				consulta = " SELECT imtp.imtp_id                                                  AS "
						+ "        impostoTipo, "
						+ "        imtp.imtp_dsimposto                                           AS "
						+ "        descricaoImposto, "
						+ "        cnid.cnid_pcaliquota                                          AS "
						+ "        percAliquota, "
						+ "        Sum(cnid.cnid_vlimposto)                                      AS "
						+ "        valorImposto, "
						+ "        clie.clie_id                                                  AS cliente, "
						+ "        clie_nmcliente                                                AS "
						+ "        nomeCliente, "
						+ "        Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "                + cnta.cnta_vldebitos ) - "
						+ "              ( cnta.cnta_vlcreditos + cnta.cnta_vlimpostos ) ))      AS "
						+ "        valorFatura, "
						+ "        clie.clie_nncnpj                                              AS cnpj, "
						+ "        Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "                + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS "
						+ "        baseCalculo "
						+ " FROM   faturamento.conta_impostos_deduzidos cnid "
						+ "        INNER JOIN faturamento.conta cnta "
						+ "                ON ( cnid.cnta_id = cnta.cnta_id ) "
						+ "        INNER JOIN cadastro.cliente_conta clct "
						+ "                ON ( cnta.cnta_id = clct.cnta_id "
						+ "                     AND clct.crtp_id = :cliRelacaoTipo ) "
						+ "        INNER JOIN cadastro.cliente clie "
						+ "                ON ( clct.clie_id = clie.clie_id ) "
						+ "        INNER JOIN cadastro.cliente_tipo cltp "
						+ "                ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "        INNER JOIN faturamento.imposto_tipo imtp "
						+ "                ON ( cnid.imtp_id = imtp.imtp_id ) "
						+ " WHERE  cnta.cnta_id IN (SELECT idconta "
						+ "                             FROM   (SELECT imovel, "
						+ "                                            referencia, "
						+ "                                            Min(cnta_id) AS idconta "
						+ "                                     FROM   (SELECT conta.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ "                                                    conta.cnta_amreferenciaconta "
						+ "                                                    AS "
						+ "                                                    referencia, "
						+ "                                                    conta.cnta_id "
						+ "                                             FROM   faturamento.conta conta "
						+ "                                             WHERE  conta.cnta_amreferenciaconta "
						+ "                                                    = "
						+ "                                                    :anoMesReferencia "
						+ "                                             UNION ALL "
						+ "                                             SELECT contaHist.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ " contaHist.cnhi_amreferenciaconta AS "
						+ " referencia, "
						+ " contaHist.cnta_id "
						+ " FROM   faturamento.conta_historico "
						+ " contaHist "
						+ " WHERE  contaHist.cnhi_amreferenciaconta = "
						+ " :anoMesReferencia) a "
						+ " GROUP  BY imovel, "
						+ " referencia) b) "
						+ " GROUP BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cnid.cnid_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ " UNION ALL "
						+ " SELECT imtp.imtp_id                                                  AS "
						+ "        impostoTipo, "
						+ "        imtp.imtp_dsimposto                                           AS "
						+ "        descricaoImposto, "
						+ "        cidh.cidh_pcaliquota                                          AS "
						+ "        percAliquota, "
						+ "        Sum(cidh.cidh_vlimposto)                                      AS "
						+ "        valorImposto, "
						+ "        clie.clie_id                                                  AS cliente, "
						+ "        clie_nmcliente                                                AS "
						+ "        nomeCliente, "
						+ "        Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "                + cnhi.cnhi_vldebitos ) - "
						+ "              ( cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos ) ))      AS "
						+ "        valorFatura, "
						+ "        clie.clie_nncnpj                                              AS cnpj, "
						+ "        Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "                + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) )) AS "
						+ "        baseCalculo "
						+ " FROM   faturamento.conta_impostos_dedz_hist cidh "
						+ "        INNER JOIN faturamento.conta_historico cnhi "
						+ "                ON ( cidh.cnta_id = cnhi.cnta_id ) "
						+ "        INNER JOIN cadastro.cliente_conta_historico clch "
						+ "                ON ( cnhi.cnta_id = clch.cnta_id "
						+ "                     AND clch.crtp_id = :cliRelacaoTipo ) "
						+ "        INNER JOIN cadastro.cliente clie "
						+ "                ON ( clch.clie_id = clie.clie_id ) "
						+ "        INNER JOIN cadastro.cliente_tipo cltp "
						+ "                ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "        INNER JOIN faturamento.imposto_tipo imtp "
						+ "                ON ( cidh.imtp_id = imtp.imtp_id ) "
						+ " WHERE  cnhi.cnta_id IN (SELECT idconta "
						+ "                             FROM   (SELECT imovel, "
						+ "                                            referencia, "
						+ "                                            Min(cnta_id) AS idconta "
						+ "                                     FROM   (SELECT conta.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ "                                                    conta.cnta_amreferenciaconta "
						+ "                                                    AS "
						+ "                                                    referencia, "
						+ "                                                    conta.cnta_id "
						+ "                                             FROM   faturamento.conta conta "
						+ "                                             WHERE  conta.cnta_amreferenciaconta "
						+ "                                                    = "
						+ "                                                    :anoMesReferencia "
						+ "                                             UNION ALL "
						+ "                                             SELECT contaHist.imov_id "
						+ "                                                    AS "
						+ "                                                    imovel, "
						+ " contaHist.cnhi_amreferenciaconta AS "
						+ " referencia, "
						+ " contaHist.cnta_id "
						+ " FROM   faturamento.conta_historico "
						+ " contaHist "
						+ " WHERE  contaHist.cnhi_amreferenciaconta = "
						+ " :anoMesReferencia) a "
						+ " GROUP  BY imovel, "
						+ " referencia) b) "
						+ " GROUP BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cidh.cidh_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ " ORDER  BY cliente, " + "           impostotipo   ";

				query = session
						.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING)
						.setShort("cliRelacaoTipo",
								ClienteRelacaoTipo.RESPONSAVEL)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um m?s de
	 * refer?ncia de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 23/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederal(
			Integer anoMesFerencia, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		StringBuffer sbConsulta = new StringBuffer();

		try {

			Query query = null;

			if (idCliente != null) {
				sbConsulta.append(" ");

				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cnid.cnid_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cnid.cnid_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta
						.append("from	faturamento.conta_impostos_deduzidos cnid ");
				sbConsulta
						.append("inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) ");
				sbConsulta
						.append("inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta
						.append("inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) ");
				sbConsulta
						.append("where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta.append("and clct.clie_id = :idCliente ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("union all ");
				sbConsulta.append("select imtp.imtp_id impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cidh.cidh_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cidh.cidh_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta
						.append("from	faturamento.conta_impostos_dedz_hist cidh ");
				sbConsulta
						.append("inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta
						.append("inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) ");
				sbConsulta
						.append("where pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta.append("and clch.clie_id = :idCliente ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("ORDER BY cliente, impostoTipo ");

				query = session.createSQLQuery(sbConsulta.toString())
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cnid.cnid_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cnid.cnid_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta
						.append("from	faturamento.conta_impostos_deduzidos cnid ");
				sbConsulta
						.append("inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) ");
				sbConsulta
						.append("inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta
						.append("inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) ");
				sbConsulta
						.append("where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("union all ");
				sbConsulta.append("select imtp.imtp_id as impostoTipo, ");
				sbConsulta.append("imtp.imtp_dsimposto as descricaoImposto, ");
				sbConsulta.append("cidh.cidh_pcaliquota as percAliquota, ");
				sbConsulta.append("sum(cidh.cidh_vlimposto) as valorImposto, ");
				sbConsulta.append("clie.clie_id as cliente, ");
				sbConsulta.append("clie_nmcliente as nomeCliente, ");
				sbConsulta
						.append("sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, ");
				sbConsulta.append("clie.clie_nncnpj as cnpj ");
				sbConsulta
						.append("from	faturamento.conta_impostos_dedz_hist cidh ");
				sbConsulta
						.append("inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) ");
				sbConsulta
						.append("inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) ");
				sbConsulta
						.append("inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) ");
				sbConsulta
						.append("inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) ");
				sbConsulta
						.append("inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) ");
				sbConsulta
						.append("where pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia ");
				sbConsulta
						.append("GROUP BY clie.clie_id, clie_nmcliente, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj ");
				sbConsulta.append("ORDER BY cliente, impostoTipo ");

				query = session.createSQLQuery(sbConsulta.toString())
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}
			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos arrecadados a partir de um m?s de
	 * refer?ncia de um determinado cliente federal ou de TODOS os clientes
	 * federais.
	 * 
	 * @author Diogo Peixoto
	 * @date 24/03/2011
	 * 
	 * @param Integer
	 *            anoMesFerencia
	 * @param Integer
	 *            idCliente
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarImpostosArrecadacaoClienteResponsavelFederalAnalitico(
			Integer anoMesFerencia, Integer idCliente)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_deduzidos cnid "
						+ "inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ "inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) "
						+ "inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ "inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia "
						+ " and		clct.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_dedz_hist cidh "
						+ "inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ "inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ "inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) "
						+ "inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia "
						+ " and		clch.clie_id = :idCliente "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER)
						.addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				consulta = "select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cnid.cnid_pcaliquota as percAliquota, "
						+ " sum(cnid.cnid_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos + cnta.cnta_vlimpostos))) as valorFatura, "
						+ " cnta.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_deduzidos cnid "
						+ "inner join faturamento.conta cnta on (cnid.cnta_id = cnta.cnta_id) "
						+ "inner join arrecadacao.pagamento pgmt on (cnta.cnta_id = pgmt.cnta_id and pgmt.pgmt_dtpagamento is not null) "
						+ "inner join cadastro.cliente_conta clct on (pgmt.cnta_id = clct.cnta_id and clct.crtp_id = 3) "
						+ "inner join cadastro.cliente clie on (clct.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cnid.imtp_id = imtp.imtp_id) "
						+ "where pgmt.pgmt_amreferenciaarrecadacao = :anoMesReferencia "
						+ " GROUP BY clie.clie_id, clie_nmcliente, cnta.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cnid.cnid_pcaliquota, clie.clie_nncnpj "
						+ " union all "
						+ " select	imtp.imtp_id as impostoTipo ,"
						+ " imtp.imtp_dsimposto as descricaoImposto , "
						+ " cidh.cidh_pcaliquota as percAliquota, "
						+ " sum(cidh.cidh_vlimposto) as valorImposto, "
						+ " clie.clie_id as cliente, "
						+ " clie_nmcliente as nomeCliente, "
						+ " sum(((cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto + cnhi.cnhi_vldebitos) - (cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos))) as valorFatura, "
						+ " cnhi.imov_id as imovel, "
						+ " clie.clie_nncnpj as cnpj "
						+ "from	faturamento.conta_impostos_dedz_hist cidh "
						+ "inner join faturamento.conta_historico cnhi on (cidh.cnta_id = cnhi.cnta_id) "
						+ "inner join cadastro.cliente_conta_historico clch on (cnhi.cnta_id = clch.cnta_id and clch.crtp_id = 3) "
						+ "inner join arrecadacao.pagamento_historico pgmth on (clch.cnta_id = pgmth.cnta_id) "
						+ "inner join cadastro.cliente clie on (clch.clie_id = clie.clie_id) "
						+ "inner join cadastro.cliente_tipo cltp on (clie.cltp_id = cltp.cltp_id and cltp.epod_id = 3) "
						+ "inner join faturamento.imposto_tipo imtp on (cidh.imtp_id = imtp.imtp_id) "
						+ " where	pgmth.pghi_amreferenciaarrecadacao = :anoMesReferencia "

						+ " GROUP BY clie.clie_id, clie_nmcliente, cnhi.imov_id, imtp.imtp_id, imtp.imtp_dsimposto, cidh.cidh_pcaliquota, clie.clie_nncnpj "
						+ " ORDER BY cliente, imovel, impostoTipo ";

				query = session.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER)
						.addScalar("cnpj", Hibernate.STRING)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}
			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse m?todo est? de acordo com o UC0919 - Gerar Relat?rio de Impostos Por
	 * Cliente Respons?vel, no caso do Relat?rio Anal?tico o qual necessita
	 * recuperar os Im?veis que est?o associados a uma Fatura (cujo id ? passado
	 * como par?metro Integer), a partir da tabela fatura_item.
	 * 
	 * @author Jose Guilherme Macedo Vieira
	 * @date 13/07/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection<Imovel> - a colecao de imoveis associadas a uma fatura
	 * @throws ErroRepositorioException
	 */
	public Collection<Imovel> pesquisarImoveisFaturaClienteResponsavel(
			Integer idFatura) throws ErroRepositorioException {

		Collection<Imovel> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT imo " + "FROM FaturaItem fatIt "
					+ "INNER JOIN fatIt.imovel imo  "
					+ "INNER JOIN imo.clienteImoveis cliImo with "
					+ "(cliImo.clienteRelacaoTipo.id = 2 and "
					+ "cliImo.dataFimRelacao = null)"
					+ "INNER JOIN fetch fatIt.fatura.cliente cli "
					+ "WHERE  fatIt.fatura.id = :idFatura ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("idFatura", idFatura).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 28/07/2009
	 * 
	 * @author Francisco do Nascimento
	 * 
	 * @param idCAAC
	 *            Identificador de CobrancaAcaoAtividadeCronograma
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisCronogramaAcaoCobranca(Integer idCAAC)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where "
					+ "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session
					.createQuery(consulta)
					.setInteger("idCAAC", idCAAC)
					.setDate("dataGeracaoItem",
							Util.subtrairNumeroDiasDeUmaData(dataAtual, 2))
					.uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta)
					.setInteger("idCAAC", idCAAC).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeCronograma.id = :idCAAC ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta)
					.setInteger("idCAAC", idCAAC).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Pesquisa todas as localidades do cicloMeta agrupando por localidade,
	 * unidade e gerencia.
	 * 
	 * 
	 * @author Genival Barbosa
	 * @date 03/08/2009
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public List consultarColecaoCicloMetaGrupoRelatorio(Integer idCicloMeta)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select  ger.id, "
					+ "ger.nome, "
					+ "uni.id, "
					+ "uni.nome, "
					+ "loc.id, "
					+ "loc.descricao, "
					+ "sum(cmg.metaCalculada) as metaCalculada, "
					+ "sum(cmg.metaAjustada) as metaAjustada, "
					+ "sum(cmg.quantidadeImoveisSituacaoAgua) as quantidadeImoveis, "
					+ "sum(cmg.quantidadeRealizada) as quantidadeRealizada, "
					+ "sum(cmg.valorRealizado) as valorRealizado, "
					+ "sum(cmg.quantidadeDocumentosRestantes) as quantidadeDocumentosRestantes, "
					+ "sum(cmg.valorTotalDocumentosRestantes) as valorTotalDocumentosRestantes "
					+ "from CicloMetaGrupo cmg "
					+ "inner join cmg.cicloMeta cme "
					+ "inner join cmg.localidade loc "
					+ "inner join loc.gerenciaRegional ger "
					+ "inner join loc.unidadeNegocio uni "
					+ "where cmg.cicloMeta = :idCicloMeta "
					+ "group by loc.id ,uni.id,ger.id ,ger.nome, uni.nome, loc.descricao "
					+ "order by ger.nome, uni.nome, loc.descricao ";

			retorno = session.createQuery(consulta)
					.setInteger("idCicloMeta", idCicloMeta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa
	 * 
	 * - Pesquisa dados da cobran?a
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobranca(Integer idComando,
			Date dateInicial, Date dateFinal) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando "
					+ " and ecc.ecco_cdincluido is null "
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id)"
					+ " and (conta.dcst_idatual in " + "("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			if (dateInicial != null && !dateInicial.equals("")
					&& dateFinal != null && !dateFinal.equals("")) {

				consulta += " and (cecc.cecc_dtexecucao between :dateInicial and :dateFinal)";

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando)
						.setDate("dateInicial", dateInicial)
						.setDate("dateFinal", dateFinal).list();

			} else {

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa
	 * 
	 * - Pesquisa dados da cobran?a criterio
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaCriterio(Integer idComando,
			Date dateInicial, Date dateFinal) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando"
					+ " and ecc.ecco_cdincluido is null "
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id) "
					+ " and ecc.ecco_icpagamentovalido = 1"
					+ " and (conta.dcst_idatual in " + " ("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			if (dateInicial != null && !dateInicial.equals("")
					&& dateFinal != null && !dateFinal.equals("")) {

				consulta += " and (cecc.cecc_dtexecucao between :dateInicial and :dateFinal)";

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando)
						.setDate("dateInicial", dateInicial)
						.setDate("dateFinal", dateFinal).list();

			} else {

				retorno = session.createSQLQuery(consulta)
						.addScalar("valor", Hibernate.BIG_DECIMAL)
						.setInteger("idComando", idComando).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SB0014] - Processar Pagamento Legado CAEMA - AVISO DE D?BITOS
	 * 
	 * @author Raphael Rossiter
	 * @date 16/06/2008
	 * 
	 * @param idImovel
	 * @param dataEmissao
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCobrancaDocumentoItem(Integer idImovel,
			BigDecimal valorPagamento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "SELECT conta.id, "
					+ // 0
					"guiaPagamento.id, "
					+ // 1
					"debitoACobrar.id, "
					+ // 2
					"cdi.valorItemCobrado, "
					+ // 3
					"conta.referencia,"
					+ // 4
					"contaHistorico.anoMesReferenciaConta, "
					+ // 5
					"guiaPagamento.debitoTipo.id, "
					+ // 6
					"guiaPagamentoHistorico.debitoTipo.id, "
					+ // 7
					"debitoACobrar.debitoTipo.id,"
					+ // 8
					"debitoACobrarHistorico.debitoTipo.id, "
					+ // 9
					"contaHistorico.id, "
					+ // 10
					"guiaPagamentoHistorico.id, "
					+ // 11
					"debitoACobrarHistorico.id, "
					+ // 12
					"cage.id, "
					+ // 13
					"loca.id, "
					+ // 14
					"imov.id " // 15
					+ "FROM CobrancaDocumentoItem cdi "
					+ "LEFT JOIN cdi.cobrancaDocumento cd "
					+ "LEFT JOIN cd.imovel imovel "
					+ "LEFT JOIN cd.documentoTipo documentoTipo "
					+ "LEFT JOIN cdi.contaGeral.conta conta "
					+ "LEFT JOIN cdi.contaGeral.contaHistorico contaHistorico "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ "LEFT JOIN cdi.guiaPagamentoGeral.guiaPagamentoHistorico guiaPagamentoHistorico "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "LEFT JOIN cdi.debitoACobrarGeral.debitoACobrarHistorico debitoACobrarHistorico "
					+ "LEFT JOIN cdi.creditoARealizarGeral cage "
					+ "LEFT JOIN cd.localidade loca "
					+ "LEFT JOIN cd.imovel imov "
					+ "WHERE cd.valorDocumento = :valorDocumento AND "
					+ "imovel.id = :idImovel";

			retorno = session.createQuery(consulta)
					.setBigDecimal("valorDocumento", valorPagamento)
					.setInteger("idImovel", idImovel.intValue()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa -
	 * Pesquisa dados do popup da cobran?a
	 * 
	 * @author Hugo Amorim
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosPopup(Integer idComando)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "empre.empr_nmempresa as empresa, "// 0
					+ "cecc.cecc_dtexecucao as dataExecucao, "// 1
					+ "cecc.cecc_amreferenciacontainicial as dataContaInicial, "// 2
					+ "cecc.cecc_amreferenciacontafinal as dataContaFinal, "// 3
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoIncial, "// 4
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoFinal, "// 5
					+ "cecc_vlminimoconta as vlMinino, "// 6
					+ "cecc_vlmaximoconta as vlMaximo, "// 7
					+ "imov_id as imovel, "// 8
					+ "cli.clie_nmcliente as cliente, "// 9
					+ "uneg.uneg_id as idUneg, "// 10
					+ "uneg.uneg_nmunidadenegocio as nomeUneg, "// 11
					+ "loca_idinicial as locaIncial, "// 12
					+ "loca_idfinal as locaFinal, "// 13
					+ "cecc_cdsetorcomercialinicial as setorInicial, "// 14
					+ "cecc_cdsetorcomercialfinal as setorFinal, "// 15
					+ "iper.iper_id as idImovelPerfil, "// 16
					+ "iper.iper_dsimovelperfil as dsImovelPerfil, "// 17
					+ "greg.greg_id as idGerenciaRegional, "// 18
					+ "greg.greg_nmregional as dsGerenciaRegional, "// 19
					+ "cecc_nnquadrainicial as idQuadraInicial, "// 20
					+ "cecc_nnquadrafinal as idQuadraFinal "// 21
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "inner join cadastro.empresa empre on cecc.empr_id = empre.empr_id "
					+ "left join cadastro.cliente cli on cli.clie_id = cecc.clie_id "
					+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = cecc.uneg_id "
					+ "left join cadastro.imovel_perfil iper on iper.iper_id = cecc.iper_id "
					+ "left join cadastro.gerencia_regional greg on cecc.greg_id = greg.greg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("empresa", Hibernate.STRING)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataContaInicial", Hibernate.INTEGER)
					.addScalar("dataContaFinal", Hibernate.INTEGER)
					.addScalar("vencimentoIncial", Hibernate.DATE)
					.addScalar("vencimentoFinal", Hibernate.DATE)
					.addScalar("vlMinino", Hibernate.BIG_DECIMAL)
					.addScalar("vlMaximo", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("cliente", Hibernate.STRING)
					.addScalar("idUneg", Hibernate.INTEGER)
					.addScalar("nomeUneg", Hibernate.STRING)
					.addScalar("locaIncial", Hibernate.INTEGER)
					.addScalar("locaFinal", Hibernate.INTEGER)
					.addScalar("setorInicial", Hibernate.INTEGER)
					.addScalar("setorFinal", Hibernate.INTEGER)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("dsGerenciaRegional", Hibernate.STRING)
					.addScalar("idQuadraInicial", Hibernate.INTEGER)
					.addScalar("idQuadraFinal", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * UC0905 - Gerar Relatorio Acompanhamento Acao Cobran?a
	 * 
	 * @author Genival Barbosa
	 * @date 26/08/2009
	 * 
	 * @param RelatorioAcompanhamentoAcoesCobrancaHelper
	 *            helper
	 * 
	 * @return Lista de acoes de cobranca
	 */
	public List consultarColecaoAcaoCobranca(
			RelatorioAcompanhamentoAcoesCobrancaHelper helper)
			throws ErroRepositorioException {

		List retorno = null;

		Session session = HibernateUtil.getSession();

		String idCobrancaAcao = helper.getIdCobrancaAcao();
		String dataInicial = helper.getDataInicial() + " 00:00:00";
		String dataFinal = helper.getDataFinal() + " 23:59:59";
		String idGerenciaRegional = helper.getIdGerenciaRegional();
		String idUnidadeNegocio = helper.getIdUnidadeNegocio();
		String idLocalidade = helper.getIdLocalidade();
		String idEmpresa = helper.getIdEmpresa();

		String consulta;

		try {
			consulta = "select ger.id, "

			+ "ger.nome, " + "uni.id, " + "uni.nome, " + "loc.id, "
					+ "loc.descricao, " + "cas.id, " + "cas.descricao, "
					+ "count(cod.id) as quantidadeSituacao, "
					+ "sum(cod.valorDocumento) as valorSituacao, ";

			// ainda falta resolver o problema da empresa
			if (!idEmpresa.trim().equals("-1")) {

				consulta = consulta + "empr.id, empr.descricao, ";
			}

			consulta = consulta + "coa.id, " + "coa.descricaoCobrancaAcao "
					+ "from CobrancaDocumento cod "
					+ "inner join cod.cobrancaAcaoSituacao cas "
					+ "inner join cod.localidade loc "
					+ "inner join loc.gerenciaRegional ger "
					+ "inner join loc.unidadeNegocio uni "
					+ "inner join cod.empresa empr "
					+ "inner join cod.cobrancaAcao coa " + "where coa.id = "
					+ idCobrancaAcao + " and "
					+ "cod.emissao >= :dataInicial and "
					+ "cod.emissao <= :dataFinal ";

			if (!idGerenciaRegional.trim().equals("-1")) {
				consulta = consulta + "and ger.id = " + idGerenciaRegional
						+ " ";
			}
			if (!idUnidadeNegocio.trim().equals("-1")) {
				consulta = consulta + "and uni.id = " + idUnidadeNegocio + " ";
			}
			if (!idLocalidade.trim().equals("-1")) {
				consulta = consulta + "and loc.id = " + idLocalidade + " ";
			}

			// ainda falta resolver o problema da empresa
			if (!idEmpresa.trim().equals("-1")) {
				consulta = consulta + "and cod.empresa = " + idEmpresa + " ";
				consulta = consulta
						+ "group by cas.id, loc.id, uni.id, ger.id , empr.descricao, coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, empr.id , coa.descricaoCobrancaAcao ";
			} else {
				consulta = consulta
						+ "group by cas.id, loc.id, uni.id, ger.id , coa.id, ger.nome, uni.nome, loc.descricao, cas.descricao, coa.descricaoCobrancaAcao ";
			}
			consulta = consulta
					+ "order by ger.nome, uni.nome, loc.descricao, cas.id ";

			Query query = null;
			query = session
					.createQuery(consulta)
					.setDate("dataInicial",
							Util.converteStringParaDateHora(dataInicial))
					.setDate("dataFinal",
							Util.converteStringParaDateHora(dataFinal));
			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Esse m?todo est? de acordo com o UC0258 - Filtrar Documentos de Cobran?a,
	 * retorna conjunto de CAAC_ID(a??es do ciclo) selecionados
	 * 
	 * @author Anderson Italo
	 * @date 03/08/2009
	 * 
	 * @param Collection
	 *            <Integer> idsAcao
	 * @param Integer
	 *            anoMesReferencia
	 * @return Collection<CobrancaAcaoAtividadeCronograma> - a colecao de
	 *         cobrancaAcaoAtividadeCronograma associados as acoes e
	 *         anoMesReferencia Informados
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaAcaoAtividadeCronograma> pesquisarAcoesCiclo(
			Collection idsAcao, Integer anoMesReferencia)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select caac.id "
					+ "from gcom.cobranca.CobrancaAcaoAtividadeCronograma caac "
					+ "inner join fetch caac.cobrancaAcaoCronograma cacr "
					+ "inner join cacr.cobrancaGrupoCronogramaMes cgcm "
					+ "where cgcm.anoMesReferencia = :anoMesReferencia "
					+ "and cacr.cobrancaAcao.id in (:ids) "
					+ "and caac.cobrancaAtividade.id = 2";

			retorno = session.createQuery(consulta)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setParameterList("ids", idsAcao).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este m?todo est? de acordo com o UC[0258]Filtrar Documento de Cobranca, ?
	 * utilizado pelo relat?rio filtrar documentos de cobran?a
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarCobrancaDocumento(FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emiss?o cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a uni?o dos 2 selects o primeiro trata apenas a??es de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select "
						+ "doc.cbdo_id as idDocumento, "
						+ "a.imov_id as idImovel, "
						+ "b.loca_id as idLocalidade, "
						+ "c.stcm_cdsetorcomercial as codSetorComercial, "
						+ "d.qdra_nnquadra as numeroQuadra, "
						+ "a.imov_nnlote as lote, "
						+ "a.imov_nnsublote as subLote, "
						+ "f.clie_nmcliente as nomeCliente, "
						+ "g.last_dsligacaoaguasituacao as descricaoLigAguaSituacao, "
						+ "h.lest_dsligacaoesgotosituacao as descricaoLigEsgotoSituacao, "
						+ "i.iper_dsimovelperfil as descricaoImovelPerfil, "
						+ "j.catg_dscategoria as descricaoCategoria, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "doc.cbdo_vldocumento as valorDocumento, "
						+ "k.cast_dssituacaoacao as descricaoSituacaoAcao, "
						+ "l.cdst_dssituacaodebito as descricaoSituacaoDebito "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join cadastro.imovel a "
						+ "on doc.imov_id = a.imov_id "
						+ "inner join cadastro.localidade b "
						+ "on a.loca_id = b.loca_id "
						+ "inner join cadastro.setor_comercial c "
						+ "on a.stcm_id = c.stcm_id "
						+ "inner join cadastro.quadra d "
						+ "on a.qdra_id = d.qdra_id "
						+ "inner join cadastro.cliente_imovel e "
						+ "on a.imov_id = e.imov_id and e.crtp_id = 2 and e.clim_dtrelacaofim is null "
						+ "inner join cadastro.cliente f "
						+ "on e.clie_id = f.clie_id "
						+ "inner join atendimentopublico.ligacao_agua_situacao g "
						+ "on a.last_id = g.last_id "
						+ "inner join atendimentopublico.ligacao_esgoto_situacao h "
						+ "on a.lest_id = h.lest_id "
						+ "inner join cadastro.imovel_perfil i "
						+ "on doc.iper_id = i.iper_id "
						+ "left outer join cadastro.categoria j "
						+ "on doc.catg_id = j.catg_id "
						+ "left outer join cobranca.cobranca_acao_situacao k "
						+ "on doc.cast_id = k.cast_id "
						+ "left outer join cobranca.cobranca_debito_situacao l "
						+ "on doc.cdst_id = l.cdst_id " + " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "a.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "b.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "b.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "b.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "a.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "a.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by idLocalidade, codSetorComercial, numeroQuadra, lote, subLote, data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta)
					.addScalar("idDocumento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("codSetorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.INTEGER)
					.addScalar("subLote", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("descricaoLigAguaSituacao", Hibernate.STRING)
					.addScalar("descricaoLigEsgotoSituacao", Hibernate.STRING)
					.addScalar("descricaoImovelPerfil", Hibernate.STRING)
					.addScalar("descricaoCategoria", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("descricaoSituacaoAcao", Hibernate.STRING)
					.addScalar("descricaoSituacaoDebito", Hibernate.STRING);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este m?todo est? de acordo com o UC[0258]Filtrar Documento de Cobranca, ?
	 * utilizado pelo relat?rio filtrar documentos de cobran?a para totalizar os
	 * registros filtrados
	 * 
	 * @author Anderson Italo
	 * @date 19/08/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarCobrancaDocumentoCount(
			FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emiss?o cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select (select "
						+ " count(doc.cbdo_id) "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a uni?o dos 2 selects o primeiro trata apenas a??es de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += ") + ";

				consulta += " (select "
						+ "count(doc.cbdo_id) "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += ") as totalDocumentos";

			} else {
				consulta += " select "
						+ "count(doc.cbdo_id) as totalDocumentos "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}
			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta).addScalar(
					"totalDocumentos", Hibernate.INTEGER);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este m?todo est? de acordo com o [UC0906] Gerar Relat?rio de
	 * Acompanhamento das Supress?es, Religa??es e Reestabelecimentos. ?
	 * utilizado pelo relat?rio filtrar os registros do relatorio
	 * 
	 * @author Anderson Italo
	 * @date 28/08/2009
	 * 
	 * @param FiltroSupressoesReligacoesReestabelecimentoHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List filtrarSupressoesReligacoesReestabelecimentos(
			FiltroSupressoesReligacoesReestabelecimentoHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataInicial = Util.converteStringParaDateHora(filtro
				.getDataEmissaoInicio() + " 00:00:00");
		Date dataFinal = Util.converteStringParaDateHora(filtro
				.getDataEmissaoFim() + " 23:59:59");
		Integer limiteReligacaoCorteDias = new Integer(
				filtro.getLimititeReligacaoPosCorte());

		try {

			consulta = "select d.nomeAbreviado, d.nome, e.nome, b.descricao, "
					+ "sum(case when ((la.dataReligacao - la.dataCorte) < :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal)then 1 else 0 end) as religacaoMenosDeLimiteDias, "

					+ "sum(case when ((la.dataReligacao - la.dataCorte) >= :limiteReligacaoCorteDias) "
					+ "and  (la.dataReligacao >= :dataInicial "
					+ "and la.dataReligacao <= :dataFinal) then 1 else 0 end) as religacaoMaiorDeLimiteDias, "

					+ "sum(case when ((la.dataSupressao is not null) "
					+ "and (la.dataSupressao >= :dataInicial "
					+ "and la.dataSupressao <= :dataFinal)) then 1 else 0 end) as supressao, "

					+ "sum(case when ((la.dataRestabelecimentoAgua is not null) "
					+ "and (la.dataRestabelecimentoAgua >= :dataInicial "
					+ "and la.dataRestabelecimentoAgua <= :dataFinal)) then 1 else 0 end) as reestabelecimento, "

					+ "sum(case when ((la.dataCorte is not null) "
					+ "and (la.dataCorte >= :dataInicial "
					+ "and la.dataCorte <= :dataFinal)) then 1 else 0 end) as cortes "

					+ "from gcom.atendimentopublico.ligacaoagua.LigacaoAgua la, "
					+ "gcom.cadastro.imovel.Imovel im, "
					+ "gcom.cadastro.localidade.Localidade b, "
					+ "gcom.cadastro.empresa.Empresa c, "
					+ "gcom.cadastro.localidade.GerenciaRegional d, "
					+ "gcom.cadastro.localidade.UnidadeNegocio e, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServico f, "
					+ "gcom.atendimentopublico.ordemservico.OrdemServicoUnidade g, "
					+ "gcom.seguranca.acesso.usuario.Usuario h "
					+ "where la.id = im.id "
					+ "and im.localidade.id = b.id "
					+ "and b.gerenciaRegional.id = d.id "
					+ "and b.unidadeNegocio.id = e.id "
					+ "and im.id = f.imovel.id "
					+ "and f.atendimentoMotivoEncerramento.id = 2 "
					+ "and f.id = g.ordemServico.id "
					+ "and g.atendimentoRelacaoTipo.id = 3 "
					+ "and g.usuario.id = h.id "
					+ "and h.empresa.id = c.id "
					+ "and  ((la.dataReligacao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataReligacao >= :dataInicial "
					+ "and   la.dataReligacao <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao = 50)"
					+ ") "
					+ "or    (la.dataSupressao = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataSupressao >= :dataInicial "
					+ "and   la.dataSupressao <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao = 685)"
					+ ") "
					+ "or    (la.dataRestabelecimentoAgua = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataRestabelecimentoAgua >= :dataInicial "
					+ "and   la.dataRestabelecimentoAgua <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (51,879))"
					+ ")"
					+ "or    (la.dataCorte = to_date(to_char(f.dataEncerramento,'YYYY/MM/DD'),'YYYY/MM/DD') "
					+ "and   la.dataCorte >= :dataInicial "
					+ "and   la.dataCorte <= :dataFinal "
					+ "and   f.servicoTipo.id in "
					+ "(SELECT stop.comp_id.idServicoTipo "
					+ "FROM ServicoTipoOperacao stop "
					+ "WHERE stop.comp_id.idOperacao in (48))" + ")" + ") "
					+ "and ";

			// idGerenciaRegional
			if (filtro.getIdGerenciaRegional() != null
					&& !filtro.getIdGerenciaRegional().equals("")) {
				consulta += "d.id = " + filtro.getIdGerenciaRegional()
						+ " and ";
			}

			// unidadeNegocio
			if (filtro.getIdUnidadeNegocio() != null
					&& !filtro.getIdUnidadeNegocio().equals("")) {
				consulta += "e.id = " + filtro.getIdUnidadeNegocio() + " and ";
			}

			// Localidade
			if (filtro.getIdLocalidade() != null
					&& !filtro.getIdLocalidade().equals("")) {
				consulta += "b.id = " + filtro.getIdLocalidade() + " and ";
			}

			// Empresa
			if (filtro.getIdEmpresa() != null
					&& !filtro.getIdEmpresa().equals("")) {
				consulta += "c.id = " + filtro.getIdEmpresa() + " and ";
			}

			// retira o and do final se houver
			if (consulta.substring(consulta.length() - 4, consulta.length())
					.equals("and ")) {
				consulta = consulta.substring(0, consulta.length() - 4);
			}

			consulta += " group by " + "d.nomeAbreviado, d.nome, "
					+ "e.nome, b.descricao " + "order by "
					+ "d.nomeAbreviado, d.nome, " + "e.nome, b.descricao";

			retorno = session
					.createQuery(consulta)
					.setParameter("limiteReligacaoCorteDias",
							limiteReligacaoCorteDias)
					.setParameter("dataInicial", dataInicial)
					.setParameter("dataFinal", dataFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este m?todo est? de acordo com o UC[0258]Filtrar Documento de Cobranca
	 * 
	 * @author Anderson Italo
	 * @date 16/09/2009
	 * 
	 * @param FiltrarDocumentoCobrancaHelper
	 *            filtro
	 * @return List
	 * @throws ErroRepositorioException
	 */
	public List consultarDocumentosCobranca(
			FiltrarDocumentoCobrancaHelper filtro)
			throws ErroRepositorioException {
		List retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";
		Map parameters = new HashMap();
		Query query = null;

		try {

			// apenas para forma de emiss?o cronograma com eventual e/ou
			// individual
			boolean validouCombinacao = false;
			if (filtro.getIdsDocumentoEmissaoForma() != null) {
				if (filtro.getIdsDocumentoEmissaoForma().length > 0
						&& filtro.getIdsDocumentoEmissaoForma()[0].intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
					if (filtro.getIdsDocumentoEmissaoForma().length == 2
							|| filtro.getIdsDocumentoEmissaoForma().length == 3) {
						validouCombinacao = true;
					}
				}
			}

			if (validouCombinacao) {

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o CRONOGRAMA
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {

					consulta += "doc.demf_id="
							+ filtro.getIdsDocumentoEmissaoForma()[0]
									.toString() + " and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emissao
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial1) and (:dataEmissaoFinal1) ";

					parameters.put("dataEmissaoInicial1", dataInicial);
					parameters.put("dataEmissaoFinal1", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				// faz a uni?o dos 2 selects o primeiro trata apenas a??es de
				// cronograma
				// e o segundo as de eventuais e individuais
				consulta += " union ";

				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o EVENTUAL e/ou INDIVIDUAL
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();

					for (int i = 1; i < idsEmissaoForma.length; i++) {
						if (!idsEmissaoForma[i]
								.equals(DocumentoEmissaoForma.CRONOGRAMA)) {
							consulta += idsEmissaoForma[i].toString() + ", ";
						}
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between '"
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ "' and '"
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + "' and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			} else {
				consulta += " select "
						+ "doc.cbdo_id as idDocumento, e.imov_id as idImovel, "
						+ "a.cbac_id as idCobrancaAcao, a.cbac_dscobrancaacao as descricaoCobrancaAcao, "
						+ "doc.cbdo_tmemissao as data_emissao, "
						+ "b.demf_id as idEmissaoForma, b.demf_dsdocumentoemissaoforma as descricaoEmissaoForma, "
						+ "c.dotp_id as idDocumentoTipo, c.dotp_dsdocumentotipo as descricaoDocumentoTipo, "
						+ "d.empr_id as idEmpresa, d.empr_nmabreviadoempresa as nomeEmpresa, "
						+ "doc.cbdo_vldocumento as valorDocumento "
						+ "from cobranca.cobranca_documento doc "
						+ "left outer join  cobranca.cobranca_acao a "
						+ "on doc.cbac_id = a.cbac_id "
						+ "left outer join cobranca.documento_emissao_forma b "
						+ "on doc.demf_id = b.demf_id "
						+ "left outer join cobranca.documento_tipo c "
						+ "on doc.dotp_id = c.dotp_id "
						+ "left outer join cadastro.empresa d "
						+ "on doc.empr_id = d.empr_id "
						+ "left outer join cadastro.imovel e "
						+ "on doc.imov_id = e.imov_id "
						+ "left outer join cadastro.localidade f "
						+ "on doc.loca_id=f.loca_id "
						+ "inner join cadastro.cliente_imovel g "
						+ "on e.imov_id = g.imov_id and g.crtp_id= 2 and g.clim_dtrelacaofim is null "
						+ " where ";

				// idImovel
				if (filtro.getIdImovel() != null && filtro.getIdImovel() > 0) {
					consulta += "e.imov_id=" + filtro.getIdImovel().toString()
							+ " and ";
				}

				// idGerenciaRegional
				if (filtro.getIdGerenciaRegional() != null
						&& filtro.getIdGerenciaRegional() > 0) {
					consulta += "f.greg_id="
							+ filtro.getIdGerenciaRegional().toString()
							+ " and ";
				}

				// unidadeNegocio
				if (filtro.getIdUnidadeNegocio() != null
						&& filtro.getIdUnidadeNegocio() > 0) {
					consulta += "f.uneg_id="
							+ filtro.getIdUnidadeNegocio().toString() + " and ";
				}
				// dados da inscri??o
				// Localidade
				if (filtro.getIdLocalidadeInicial() != null
						&& filtro.getIdLocalidadeFinal() != null
						&& filtro.getIdLocalidadeInicial().intValue() > 0
						&& filtro.getIdLocalidadeFinal().intValue() > 0) {
					consulta += "f.loca_id in("
							+ filtro.getIdLocalidadeInicial().toString() + ","
							+ filtro.getIdLocalidadeFinal().toString()
							+ ") and ";
				}

				// Setor
				if (filtro.getIdSetorComercialInicial() != null
						&& filtro.getIdSetorComercialFinal() != null
						&& filtro.getIdSetorComercialInicial().intValue() > 0
						&& filtro.getIdSetorComercialFinal().intValue() > 0) {
					consulta += "e.stcm_id in("
							+ filtro.getIdSetorComercialInicial().toString()
							+ ","
							+ filtro.getIdSetorComercialFinal().toString()
							+ ") and ";
				}

				// Quadra
				if (filtro.getIdQuadraInicial() != null
						&& filtro.getIdQuadraFinal() != null
						&& filtro.getIdQuadraInicial().intValue() > 0
						&& filtro.getIdQuadraFinal().intValue() > 0) {
					consulta += "e.qdra_id in("
							+ filtro.getIdQuadraInicial().toString() + ","
							+ filtro.getIdQuadraFinal().toString() + ") and ";
				}

				// forma de emiss?o
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					consulta += "doc.demf_id in(";
					Integer[] idsEmissaoForma = filtro
							.getIdsDocumentoEmissaoForma();
					for (int i = 0; i < idsEmissaoForma.length; i++) {
						consulta += idsEmissaoForma[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// a??o de cobran?a
				if (filtro.getIdsCobrancaAcao() != null
						&& filtro.getIdsCobrancaAcao().length > 0) {
					consulta += "doc.cbac_id in(";
					Integer[] idsCobrancaAcao = filtro.getIdsCobrancaAcao();
					for (int i = 0; i < idsCobrancaAcao.length; i++) {
						consulta += idsCobrancaAcao[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o da a??o
				if (filtro.getIdsAcaoSituacao() != null
						&& filtro.getIdsAcaoSituacao().length > 0) {
					consulta += "doc.cast_id in(";
					Integer[] idsCobrancaAcaoSituacao = filtro
							.getIdsAcaoSituacao();
					for (int i = 0; i < idsCobrancaAcaoSituacao.length; i++) {
						consulta += idsCobrancaAcaoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// situa??o do d?bito
				if (filtro.getIdsDebitoSituacao() != null
						&& filtro.getIdsDebitoSituacao().length > 0) {
					consulta += "doc.cdst_id in(";
					Integer[] idsCobrancaDebitoSituacao = filtro
							.getIdsDebitoSituacao();
					for (int i = 0; i < idsCobrancaDebitoSituacao.length; i++) {
						consulta += idsCobrancaDebitoSituacao[i].toString()
								+ ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// intervalo Valor do Documento
				if (filtro.getValorDocumentoInicial() != null
						&& !filtro.getValorDocumentoInicial().equals("")
						&& filtro.getValorDocumentoFinal() != null
						&& !filtro.getValorDocumentoFinal().equals("")) {
					consulta += "doc.cbdo_vldocumento between "
							+ filtro.getValorDocumentoInicial()
									.toEngineeringString()
							+ " and "
							+ filtro.getValorDocumentoFinal()
									.toEngineeringString() + " and ";
				}

				// motivo n?o entrega documento
				if (filtro.getIdsMotivoNaoEntrega() != null
						&& filtro.getIdsMotivoNaoEntrega().length > 0) {
					consulta += "doc.mned_id in(";
					Integer[] idsMotivoNaoEntrega = filtro
							.getIdsMotivoNaoEntrega();
					for (int i = 0; i < idsMotivoNaoEntrega.length; i++) {
						consulta += idsMotivoNaoEntrega[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// imovelPerfil
				if (filtro.getIdsImovelPerfil() != null
						&& filtro.getIdsImovelPerfil().length > 0) {
					consulta += "doc.iper_id in(";
					Integer[] idsImovelPerfil = filtro.getIdsImovelPerfil();
					for (int i = 0; i < idsImovelPerfil.length; i++) {
						consulta += idsImovelPerfil[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// categoria
				if (filtro.getIdsImovelCategoria() != null
						&& filtro.getIdsImovelCategoria().length > 0) {
					consulta += "doc.catg_id in(";
					Integer[] idsCategoria = filtro.getIdsImovelCategoria();
					for (int i = 0; i < idsCategoria.length; i++) {
						consulta += idsCategoria[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// empresa
				if (filtro.getIdsEmpresa() != null
						&& filtro.getIdsEmpresa().length > 0) {
					consulta += "doc.empr_id in(";
					Integer[] idsEmpresa = filtro.getIdsEmpresa();
					for (int i = 0; i < idsEmpresa.length; i++) {
						consulta += idsEmpresa[i].toString() + ", ";
					}
					// remove a virgula do final e coloca o par?ntese
					consulta = consulta.substring(0, consulta.length() - 2);
					consulta += ") and ";
				}

				// conjunto de cobrancaAcaoAtividadeCronograma
				// documentos do ciclo
				if (filtro.getIdsDocumentoEmissaoForma() != null
						&& filtro.getIdsDocumentoEmissaoForma().length > 0) {
					// se apenas a forma de emissao cronograma foi selecionada
					if (filtro.getIdsDocumentoEmissaoForma().length > 0
							&& filtro.getIdsDocumentoEmissaoForma()[0]
									.intValue() == DocumentoEmissaoForma.CRONOGRAMA) {
						if (filtro.getIdsCobrancaAcaoAtividadeCronograma() != null
								&& filtro
										.getIdsCobrancaAcaoAtividadeCronograma().length > 0) {

							consulta += "doc.caac_id in(";
							Integer[] idsCobrancaAcaoAtividadeCronograma = filtro
									.getIdsCobrancaAcaoAtividadeCronograma();
							for (int i = 0; i < idsCobrancaAcaoAtividadeCronograma.length; i++) {
								consulta += idsCobrancaAcaoAtividadeCronograma[i]
										.toString() + ", ";
							}

							// remove a virgula do final e coloca o par?ntese
							consulta = consulta.substring(0,
									consulta.length() - 2) + ")";
							consulta += " and ";
						}
					}
				}

				// per?odo emiss?o
				if (filtro.getDataEmissaoInicial() != null
						&& !filtro.getDataEmissaoInicial().equals("")
						&& filtro.getDataEmissaoFinal() != null
						&& !filtro.getDataEmissaoFinal().equals("")) {

					Date dataInicial = Util.converteStringParaDateHora(filtro
							.getDataEmissaoInicial() + " 00:00:00");
					Date dataFinal = Util.converteStringParaDateHora(filtro
							.getDataEmissaoFinal() + " 23:59:59");

					consulta += "doc.cbdo_tmemissao between (:dataEmissaoInicial2) and (:dataEmissaoFinal2) ";

					parameters.put("dataEmissaoInicial2", dataInicial);
					parameters.put("dataEmissaoFinal2", dataFinal);
				}

				// retira o and do final se houver
				if (consulta
						.substring(consulta.length() - 4, consulta.length())
						.equals("and ")) {
					consulta = consulta.substring(0, consulta.length() - 4);
				}

				consulta += " order by data_emissao desc ";

			}

			query = session.createQuery(consulta);
			query = session.createSQLQuery(consulta)
					.addScalar("idDocumento", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idCobrancaAcao", Hibernate.INTEGER)
					.addScalar("descricaoCobrancaAcao", Hibernate.STRING)
					.addScalar("data_emissao", Hibernate.TIMESTAMP)
					.addScalar("idEmissaoForma", Hibernate.INTEGER)
					.addScalar("descricaoEmissaoForma", Hibernate.STRING)
					.addScalar("idDocumentoTipo", Hibernate.INTEGER)
					.addScalar("descricaoDocumentoTipo", Hibernate.STRING)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("valorDocumento", Hibernate.BIG_DECIMAL);

			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();

			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0959] Gerar Arquivo Texto de Pagamentos das Contas em Cobran?a por
	 * Empresa
	 * 
	 * @author: Hugo Amorim
	 * @date: 05/10/2009
	 */
	public Collection pesquisarDadosArquivoTextoPagamentosContasCobrancaEmpresa(
			Integer idEmpresa, Integer referenciaInicial,
			Integer referenciaFinal, Integer quantidadeRegistros,
			Integer numeroIndice, Integer idUnidadeNegocio)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		try {

			consulta = "select cc.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnhi.cnhi_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ " eccp_ictipopagamento as tipoPagamento," // 5
					+ " eccp_nnparcelaatual as numParcelas," // 6
					+ " eccp_nntotalparcelas as numParcelasTotal," // 7
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 8
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 9
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 10
					+ " lc.uneg_id as idUnidadeNegocio, "// 11
					+ " un.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 12
					+ " im.loca_id as idLocalidade, "// 13
					+ " lc.loca_nmlocalidade as nomeLocalidade, "// 14
					+ " qd.qdra_nnquadra as quadra, "// 15
					+ " im.imov_nnlote as lote, "// 16
					+ " im.imov_nnsublote as sublote, "// 17
					+ " rt.rota_cdrota as codigoRota, "// 18
					+ " im.imov_nnsequencialrota as sequenciaRota, "// 19
					+ " cnhi.cnhi_cdsetorcomercial as codSetor, "// 20
					+ " ccp.eccp_dtpagamento as dataPagamento " // 21
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta_historico  cnhi "
					+ "on cnhi.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id "
					+ "where un.uneg_id = :idUnidadeNegocio ";

			if (referenciaInicial != null && referenciaFinal != null
					&& referenciaInicial != referenciaFinal) {
				consulta = consulta + "and (eccp_ampagamento between "
						+ referenciaInicial + " and " + referenciaFinal + ") ";
			} else {
				consulta = consulta + "and eccp_ampagamento = "
						+ referenciaFinal + " ";
			}

			consulta = consulta
					+ "group by cc.imov_id, clie_nmcliente, cnhi.cnhi_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, eccp_ictipopagamento,eccp_nnparcelaatual, eccp_nntotalparcelas,cc.ecco_pcempresaconta,lc.uneg_id,un.uneg_nmunidadenegocio,im.loca_id,lc.loca_nmlocalidade,qd.qdra_nnquadra,im.imov_nnlote,im.imov_nnsublote,rt.rota_cdrota,im.imov_nnsequencialrota,cnhi.cnhi_cdsetorcomercial,ccp.eccp_dtpagamento ";
			// consulta = consulta + "order by 12, 14, 1,3 ";

			consulta = consulta
					+ " UNION "
					+ "select cc.imov_id as idImovel, " // 0
					+ "clie_nmcliente as nomeCliente, " // 1
					+ "cnta.cnta_amreferenciaconta as anoMesConta, " // 2
					+ "ecco_vloriginalconta as valorConta, " // 3
					+ "eccp_ampagamento as anoMesReferenciaPagamento, "// 4
					+ " eccp_ictipopagamento as tipoPagamento," // 5
					+ " eccp_nnparcelaatual as numParcelas," // 6
					+ " eccp_nntotalparcelas as numParcelasTotal," // 7
					+ "sum(case when  (ccp.dbtp_id not in ( 43, 80, 91, 94, 100 ) or ccp.dbtp_id is null) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorPrincipal, " // 8
					+ "sum(case when   ccp.dbtp_id     in ( 43,  80, 91, 94, 100 ) "
					+ "then ( coalesce(eccp_vlpagamentomes,0))  end) as valorEncargos, " // 9
					+ "cc.ecco_pcempresaconta as percentualEmpresa, " // 10
					+ " lc.uneg_id as idUnidadeNegocio, "// 11
					+ " un.uneg_nmunidadenegocio as nomeUnidadeNegocio, "// 12
					+ " im.loca_id as idLocalidade, "// 13
					+ " lc.loca_nmlocalidade as nomeLocalidade, "// 14
					+ " qd.qdra_nnquadra as quadra, "// 15
					+ " im.imov_nnlote as lote, "// 16
					+ " im.imov_nnsublote as sublote, "// 17
					+ " rt.rota_cdrota as codigoRota, "// 18
					+ " im.imov_nnsequencialrota as sequenciaRota, "// 19
					+ " cnta.cnta_cdsetorcomercial as codSetor, "// 20
					+ " ccp.eccp_dtpagamento as dataPagamento " // 21
					+ "from   cobranca.empr_cobr_conta_pagto ccp "
					+ "inner join cobranca.empresa_cobranca_conta        cc  on cc.ecco_id  = ccp.ecco_id and cc.empr_id = :idEmpresa "
					+ "inner join  faturamento.conta  cnta "
					+ "on cnta.cnta_id  = cc.cnta_id "
					+ "inner join cadastro.cliente_imovel                ci  on ( ci.imov_id = ccp.imov_id and ci.crtp_id = 2 "
					+ "	and ci.clim_dtrelacaofim is null) "
					+ "inner join cadastro.cliente                       cl  on ( cl.clie_id = ci.clie_id ) "
					+ "inner join cadastro.imovel                        im  on im.imov_id = ccp.imov_id "
					+ "inner join cadastro.localidade                    lc  on lc.loca_id = im.loca_id "
					+ "inner join cadastro.unidade_negocio               un  on un.uneg_id = lc.uneg_id "
					+ "inner join cadastro.gerencia_regional             gr  on gr.greg_id = lc.greg_id "
					+ "inner join cadastro.quadra                        qd  on qd.qdra_id = im.qdra_id "
					+ "inner join micromedicao.rota                      rt  on rt.rota_id = qd.rota_id "
					+ "where un.uneg_id = :idUnidadeNegocio ";

			if (referenciaInicial != null && referenciaFinal != null
					&& referenciaInicial != referenciaFinal) {
				consulta = consulta + "and (eccp_ampagamento between "
						+ referenciaInicial + " and " + referenciaFinal + ") ";
			} else {
				consulta = consulta + "and eccp_ampagamento = "
						+ referenciaFinal + " ";
			}

			consulta = consulta
					+ "group by cc.imov_id, clie_nmcliente, cnta.cnta_amreferenciaconta, ecco_vloriginalconta, eccp_ampagamento, eccp_ictipopagamento,eccp_nnparcelaatual, eccp_nntotalparcelas,cc.ecco_pcempresaconta,lc.uneg_id,un.uneg_nmunidadenegocio,im.loca_id,lc.loca_nmlocalidade,qd.qdra_nnquadra,im.imov_nnlote,im.imov_nnsublote,rt.rota_cdrota,im.imov_nnsequencialrota,cnta.cnta_cdsetorcomercial,ccp.eccp_dtpagamento ";
			consulta = consulta + "order by 12, 14, 1,3 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("anoMesReferenciaPagamento", Hibernate.INTEGER)
					.addScalar("tipoPagamento", Hibernate.INTEGER)
					.addScalar("numParcelas", Hibernate.INTEGER)
					.addScalar("numParcelasTotal", Hibernate.INTEGER)
					.addScalar("valorPrincipal", Hibernate.BIG_DECIMAL)
					.addScalar("valorEncargos", Hibernate.BIG_DECIMAL)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("nomeUnidadeNegocio", Hibernate.STRING)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("nomeLocalidade", Hibernate.STRING)
					.addScalar("quadra", Hibernate.INTEGER)
					.addScalar("lote", Hibernate.INTEGER)
					.addScalar("sublote", Hibernate.INTEGER)
					.addScalar("codigoRota", Hibernate.INTEGER)
					.addScalar("sequenciaRota", Hibernate.INTEGER)
					.addScalar("codSetor", Hibernate.INTEGER)
					.addScalar("dataPagamento", Hibernate.DATE)
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("idUnidadeNegocio", idUnidadeNegocio)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		System.out.println(retorno.size());
		return retorno;

	}

	public Collection obterUnidadeNegocioPagamentosEmpresaCobrancaConta()
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct loca.uneg_id as idUnidadeNegocio "
					+ "from cobranca.empresa_cobranca_conta ecco "
					+ "inner join cadastro.imovel imov on imov.imov_id = ecco.imov_id "
					+ "inner join cadastro.localidade loca on loca.loca_id = imov.loca_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0745] Gerar Arquivo Texto para Faturamento
	 * 
	 * @author S?vio Luiz
	 */
	public CobrancaDocumento pesquisarCobrancaDocumentoImpressaoSimultanea(
			Date dataEmissao, Integer idImovel) throws ErroRepositorioException {

		CobrancaDocumento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo "
					+ "FROM CobrancaDocumento cbdo "
					+ "LEFT JOIN fetch cbdo.localidade loca "
					+ "WHERE cbdo.imovel.id = :idImovel AND "
					+ "cbdo.documentoTipo.id = :idDocumentoTipo AND "
					+ "cbdo.cobrancaDebitoSituacao.id = :idCobrancaDebitoSituacao AND "
					+ "cbdo.emissao >= :dataEmissao "
					+ "order by cbdo.emissao desc ";

			retorno = (CobrancaDocumento) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", DocumentoTipo.AVISO_CORTE)
					.setInteger("idCobrancaDebitoSituacao",
							CobrancaDebitoSituacao.PENDENTE)
					.setTimestamp("dataEmissao", dataEmissao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Alterado para verificar
	 * tipo da a??o a partir da tabela documento_tipo
	 * 
	 * @author R?mulo Aur?lio, Anderson Italo
	 * 
	 * @data 20/10/2009, 04/05/2010
	 */
	public DocumentoTipo pesquisarTipoAcaoCobrancaParaRelatorio(
			Integer cobrancaAcaoAtividadeComando,
			Integer cobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		DocumentoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento.documentoTipo "
					+ "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  "
						+ cobrancaAcaoAtividadeCronograma + " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = "
						+ cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (DocumentoTipo) session.createQuery(consulta)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Collection<CobrancaDocumento> pesquisarDocumentoCobrancaParaRelatorio(
			Integer idCobrancaAcaoCronograma, Integer idCobrancaAcaoComando)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento cbdo "
					+ "INNER JOIN FETCH cbdo.imovel imov "
					+ "INNER JOIN FETCH imov.quadra qdra "
					+ "INNER JOIN FETCH qdra.rota "
					+ "INNER JOIN FETCH cbdo.ligacaoAguaSituacao "
					+ "INNER JOIN FETCH cbdo.ligacaoEsgotoSituacao " + "WHERE ";

			if (idCobrancaAcaoCronograma != null
					&& !idCobrancaAcaoCronograma.equals("")) {
				consulta = consulta
						+ "cbdo.cobrancaAcaoAtividadeCronograma.id = "
						+ idCobrancaAcaoCronograma;
			} else if (idCobrancaAcaoComando != null
					&& !idCobrancaAcaoComando.equals("")) {
				consulta = consulta + "cbdo.cobrancaAcaoAtividadeComando.id = "
						+ idCobrancaAcaoComando;
			}

			consulta = consulta
					+ " ORDER BY cbdo.localidade.id, cbdo.codigoSetorComercial, cbdo.numeroQuadra, "
					+ "imov.lote, imov.subLote, cbdo.id";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer obterOrdemServicoAssociadaDocumentoCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse_id as idOrdemServico "
					// + "from cobranca.cobranca_documento cbdo "
					+ "from atendimentopublico.ordem_servico "
					+ "where cbdo_id  = " + idCobrancaDocumento + " ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * @author R?mulo Aur?lio
	 * @date 20/10/2009
	 * 
	 * @param idCobrancaDocumento
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public CobrancaDocumento pesquisarCobrancaDocumento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		CobrancaDocumento retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento  "
					+ "FROM cobrancaDocumento cd "
					+ "inner join fetch cd.cobrancaAcao "
					+ "WHERE cd.id = :idCobrancaDocumento ";

			retorno = (CobrancaDocumento) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Este m?todo est? de acordo com o [UC0901] Gerar Metas do Ciclo
	 * 
	 * @author Anderson Italo
	 * @date 21/09/2009
	 * 
	 * @param Integer
	 *            idCicloMeta
	 * @throws ErroRepositorioException
	 */
	public void removerCicloMetaGrupo(Integer idCicloMeta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			consulta = "delete CicloMetaGrupo c "
					+ "where c.cicloMeta.id = :idCicloMeta ";

			session.createQuery(consulta)
					.setInteger("idCicloMeta",
							new Integer(idCicloMeta).intValue())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * retorna cole??o de idEmpresaCobranca de uma Rota
	 * 
	 * @author Arthur Carvalho
	 * @date 06/11/2009
	 * 
	 * @param id
	 *            da localidade
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> pesquisarEmpresaCobrancaDaRota(
			Integer idLocalidade) throws ErroRepositorioException {

		Collection<Integer> idEmpresaCobranca = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(rota.empr_idcobranca) as idCobranca "
					+ " FROM micromedicao.rota rota "
					+ " INNER JOIN cadastro.setor_comercial setor "
					+ " ON setor.stcm_id = rota.stcm_id "
					+ " WHERE setor.loca_id = " + idLocalidade + " ";

			idEmpresaCobranca = session.createSQLQuery(consulta)
					.addScalar("idCobranca", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return idEmpresaCobranca;
	}

	/**
	 * [UC0630] - Solicitar Emiss?o do Extrato de D?bitos Author: R?mulo Aur?lio
	 * Data: 05/11/2009
	 * 
	 * Obtem os d?bitos a cobrar que estejam com PARC_ID = NULL, com SITUACAO
	 * NORMAL E FINANCIAMENTO_TIPO = 2
	 * 
	 * @param idImovel
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDebitoACobrarParceladoComIDNulo(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct(dbac) "
					+ "FROM DebitoACobrar dbac "
					+ "inner join fetch dbac.debitoTipo debitoTipo "
					+ "where dbac.imovel.id = :idImovel  "
					+ "AND dbac.financiamentoTipo = 2 "
					+ "AND dbac.parcelamento is null "
					+ "AND dbac.numeroPrestacaoCobradas < (dbac.numeroPrestacaoDebito - coalesce(dbac.numeroParcelaBonus,0)) "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session.createQuery(consulta)
					.setInteger("normal", DebitoCreditoSituacao.NORMAL)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * atualiza o valor do documento e o valor de desconto do documento de
	 * cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorDocumentoEValorDescontoCobrancaDocumento(
			Integer idCobrancaDocumento, BigDecimal valorDocumento,
			BigDecimal valorDesconto) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento "
					+ "set cbdo_vldocumento = :valorDocumento , "
					+ "cbdo_vldesconto = :valorDesconto , "
					+ "cbdo_tmultimaalteracao = :dataAtual "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setBigDecimal("valorDocumento", valorDocumento)
					.setBigDecimal("valorDesconto", valorDesconto)
					.setDate("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos
	 * 
	 * pesquisa o documento de cobranca do imovel e do documento tipo passado
	 * como parametro
	 * 
	 * @author Vivianne Sousa
	 * @date 19/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<CobrancaDocumento> pesquisarCobrancaDocumentoDoImovel(
			Integer idImovel, Integer idDocumentoTipo)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cbdo " + "FROM CobrancaDocumento as cbdo "
					+ "LEFT JOIN cbdo.imovel as imov "
					+ "LEFT JOIN cbdo.documentoTipo as docTipo " + "WHERE "
					+ "imov.id = :idImovel and docTipo = :idDocumentoTipo ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0911] - Gerar Cartas da Campanha de Solidariedade da Crian?a para
	 * Negocia??o a Vista
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos das cartas
	 * de fim de ano
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirCartaFinalAno(Integer idCobrancaGrupo,
			Integer idEmpresa, Integer idLocalidade, Integer codigoSetor,
			Integer numeroQuadra, Integer lote, Integer subLote,
			Integer sequencial, String txt_parte1, String txt_parte2,
			Integer idRota) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into public.carta_final_ano values ("
					+ idCobrancaGrupo + "," + idEmpresa + "," + idLocalidade
					+ "," + codigoSetor + "," + numeroQuadra + "," + lote + ","
					+ subLote + "," + sequencial + "," + "'" + txt_parte1
					+ "'," + "'" + txt_parte2 + "'," + idRota + ")";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [0968] - Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarCartaFinalAnoGrupo(Integer idCobrancaGrupo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		Collection retorno = new ArrayList();

		try {
			stmt = con.createStatement();

			consulta = " select txt_parte1  as parte1 , txt_parte2 as parte2 "
					+ " from carta_final_ano "
					+ " where cbgr_id = "
					+ idCobrancaGrupo
					+ " order by  empr_id,loca_id,stcm_cdsetorcomercial, qdra_nnqdra,imon_nnlote ,imov_nnsublote, sequencial";

			ResultSet set = stmt.executeQuery(consulta);

			while (set.next()) {
				Object[] objs = new Object[2];
				objs[0] = set.getString("parte1");
				objs[1] = set.getString("parte2");
				retorno.add(objs);
			}

			return retorno;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {

			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 20/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarCartaFinalAno(Integer idRota)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from carta_final_ano where  rota_id = " + idRota;

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Anderson Italo
	 * @date 26/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorGrupoCobranca(
			Integer idCobrancaGrupo, Integer gerencia, Integer unidade,
			Integer localidade, Integer setorComercial, Integer quadra)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " where r.cbgr_id = :idCobrancaGrupo "
					+ " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * @author Anderson Italo
	 * @date 30/11/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeImoveisPorComandoEventual(
			Integer idCobrancaAcaoAtividadeComando, Integer gerencia,
			Integer unidade, Integer localidade, Integer setorComercial,
			Integer quadra) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;

		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " join cobranca.cobranca_ativ_cmd_rota c on c.rota_id = r.rota_id"
					+ " where c.cacm_id = :idCobrancaAcaoAtividadeComando "
					+ " and i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session
					.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoAtividadeComando",
							idCobrancaAcaoAtividadeComando)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;

	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [FS0008] ? Verificar validade da data
	 * 
	 * @author Raphael Rossiter
	 * @date 07/01/2010
	 * 
	 * @param idCliente
	 * @param idArrecadacaoForma
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short pesquisarNumeroDiasFloatCartao(Integer idCliente,
			Integer idArrecadacaoForma) throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf.numeroDiaFloat "
					+ "FROM ArrecadadorContratoTarifa actf "
					+ "INNER JOIN actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc "
					+ "INNER JOIN arrc.cliente clie "
					+ "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE clie.id = :idCliente AND arfm.id = :idFormaArrecadacao";

			retorno = (Short) session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * @author Raphael Rossiter
	 * @date 11/01/2010
	 * 
	 * @param idCliente
	 * @param dataVencimento
	 * @return GuiaPagamento
	 * @throws ErroRepositorioException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoCartaoCredito(Integer idCliente,
			Date dataVencimento) throws ErroRepositorioException {

		GuiaPagamento retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT gpag "
					+ "FROM GuiaPagamento gpag "
					+ "INNER JOIN FETCH gpag.cliente clie "
					+ "INNER JOIN FETCH gpag.debitoTipo dbtp "
					+ "INNER JOIN FETCH gpag.localidade loca "
					+ "WHERE clie.id = :idCliente AND gpag.dataVencimento = :dataVencimento";

			retorno = (GuiaPagamento) session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setDate("dataVencimento", dataVencimento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @param guiaPagamento
	 * @throws ErroRepositorioException
	 */
	public void atualizarGuiaPagamentoCartaoCredito(GuiaPagamento guiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaValorGuiaPagamento;

		try {

			// GUIA DE PAGAMENTO
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamento "
					+ "set gpag_vldebito = :valorDebito, gpag_tmultimaalteracao = :ultimaAlteracao, "
					+ "usur_id = :usuarioLogado where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("usuarioLogado",
							guiaPagamento.getUsuario().getId().intValue())
					.executeUpdate();

			// GUIA DE PAGAMENTO ITEM
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoItem "
					+ "set gpai_vldebito = :valorDebito, gpai_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

			// GUIA DE PAGAMENTO CATEGORIA
			atualizaValorGuiaPagamento = "update gcom.arrecadacao.pagamento.GuiaPagamentoCategoria "
					+ "set gpcg_vlcategoria = :valorDebito, gpcg_tmultimaalteracao = :ultimaAlteracao "
					+ "where gpag_id = :idGuiaPagamento";

			session.createQuery(atualizaValorGuiaPagamento)
					.setInteger("idGuiaPagamento",
							guiaPagamento.getId().intValue())
					.setBigDecimal("valorDebito",
							guiaPagamento.getValorDebito())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return Localidade
	 * @throws ErroRepositorioException
	 */
	public Localidade pesquisarLocalidadeSede() throws ErroRepositorioException {

		Localidade retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT loca "
					+ "FROM Localidade loca WHERE loca.indicadorLocalidadeSede = :indicadorAtivo";

			retorno = (Localidade) session
					.createQuery(consulta)
					.setShort("indicadorAtivo",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * @author Raphael Rossiter
	 * @date 12/01/2010
	 * 
	 * @return DebitoTipo
	 * @throws ErroRepositorioException
	 */
	public DebitoTipo pesquisarDebitoTipoCartaoCredito()
			throws ErroRepositorioException {

		DebitoTipo retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT dbtp "
					+ "FROM DebitoTipo dbtp WHERE dbtp.indicadorDebitoCartaoCredito = :indicadorAtivo";

			retorno = (DebitoTipo) session
					.createQuery(consulta)
					.setShort("indicadorAtivo",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [SB0004] ? Incluir Dados da Confirma??o dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 18/01/2010
	 * 
	 * @param idArrecadador
	 * @param dataLancamento
	 * @return AvisoBancario
	 * @throws ErroRepositorioException
	 */
	public AvisoBancario pesquisarAvisoBancario(Integer idArrecadador,
			Date dataLancamento) throws ErroRepositorioException {

		AvisoBancario retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avbc " + "FROM AvisoBancario avbc "
					+ "INNER JOIN avbc.arrecadador arrc "
					+ "WHERE arrc.id = :idArrecadador "
					+ "AND avbc.dataLancamento = :dataLancamento";

			retorno = (AvisoBancario) session.createQuery(consulta)
					.setInteger("idArrecadador", idArrecadador)
					.setDate("dataLancamento", dataLancamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [SB0005 ? Calcular Valor da Dedu??o]
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idArrecadador
	 * @param idArrecadacaoForma
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ArrecadadorContratoTarifa pesquisarArrecadadorContratoTarifa(
			Integer idArrecadador, Integer idArrecadacaoForma)
			throws ErroRepositorioException {

		ArrecadadorContratoTarifa retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT actf "
					+ "FROM ArrecadadorContratoTarifa actf "
					+ "INNER JOIN FETCH actf.arrecadadorContrato arct "
					+ "INNER JOIN arct.arrecadador arrc "
					+ "INNER JOIN actf.arrecadacaoForma arfm "
					+ "WHERE arrc.id = :idArrecadador AND arfm.id = :idFormaArrecadacao";

			retorno = (ArrecadadorContratoTarifa) session.createQuery(consulta)
					.setInteger("idArrecadador", idArrecadador)
					.setInteger("idFormaArrecadacao", idArrecadacaoForma)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [SB0004] ? Incluir Dados da Confirma??o dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 28/04/2010
	 * 
	 * @param avisoBancario
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoBancario(AvisoBancario avisoBancario)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoBancario;

		try {

			atualizarValorAvisoBancario = "update gcom.arrecadacao.aviso.AvisoBancario "
					+ "set avbc_vlrealizado = :valorRealizado, "
					+ "avbc_vlarrecadacaoinformado = :valorArrecadacaoInformado, "
					+ "avbc_vldevolucaocalculado = :valorDevolucaoCalculado, "
					+ "avbc_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoBancario)
					.setInteger("idAvisoBancario", avisoBancario.getId())
					.setBigDecimal("valorRealizado",
							avisoBancario.getValorRealizado())
					.setBigDecimal("valorArrecadacaoInformado",
							avisoBancario.getValorArrecadacaoInformado())
					.setBigDecimal("valorDevolucaoCalculado",
							avisoBancario.getValorDevolucaoCalculado())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [SB0004] ? Incluir Dados da Confirma??o dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @return
	 * @throws ErroRepositorioException
	 */
	public AvisoDeducoes pesquisarAvisoDeducoes(Integer idAvisoBancario)
			throws ErroRepositorioException {

		AvisoDeducoes retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT avdd " + "FROM AvisoDeducoes avdd "
					+ "INNER JOIN avdd.avisoBancario avbc "
					+ "WHERE avbc.id = :idAvisoBancario ";

			retorno = (AvisoDeducoes) session.createQuery(consulta)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {

			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0927] ? Confirmar Cart?o de Cr?dito/D?bito
	 * 
	 * [SB0004] ? Incluir Dados da Confirma??o dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/01/2010
	 * 
	 * @param idAvisoBancario
	 * @param valorTotalAvisoDeducoes
	 * @throws ErroRepositorioException
	 */
	public void atualizarValorAvisoDeducoes(Integer idAvisoBancario,
			BigDecimal valorTotalAvisoDeducoes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarValorAvisoDeducoes;

		try {

			atualizarValorAvisoDeducoes = "update gcom.arrecadacao.aviso.AvisoDeducoes "
					+ "set avdd_vldeducao = :valorTotalAvisoDeducoes, "
					+ "avdd_tmultimaalteracao = :ultimaAlteracao "
					+ "where avbc_id = :idAvisoBancario";

			session.createQuery(atualizarValorAvisoDeducoes)
					.setInteger("idAvisoBancario", idAvisoBancario)
					.setBigDecimal("valorTotalAvisoDeducoes",
							valorTotalAvisoDeducoes)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {

			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	// /////////////////////////////////////////////////////////////
	/**
	 * [UC0349] Emitir Documento de Cobran?a ? Aviso de Corte
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressao(Integer idCobrancaDocumento,
			String linhaTxt, Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values ("
					+ idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + ","
					+ idCobrancaAcaoAtividadeCronograma + ","
					+ sequencialImpressao + "," + Util.obterSQLDataAtual()
					+ ", null )";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a ? Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt "
					+ "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm "
						+ " WHERE  cacm.id = " + idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac "
						+ " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a ? Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "delete from cobranca.cobranca_documento_impr where ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " cacm_id = "
						+ idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta + " caac_id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			int teste = stmt.executeUpdate(consulta);

			System.out.println("teste " + teste);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a ? Aviso de Corte
	 * 
	 * @author Vivianne Sousa
	 * @date 11/12/2009
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void deletarDocumentoCobrancaImpressao(
			Collection<Integer> idsDocumentosCobranca)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {
			String consulta = "DELETE FROM CobrancaDocumentoImpressao "
					+ "WHERE id IN ( :idsDocumentosCobranca ) ";

			Query q = session.createQuery(consulta);
			q.setParameterList("idsDocumentosCobranca", idsDocumentosCobranca);

			q.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa inicial j? cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorInicialFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public String verificarExistenciaFaixaInicial(Integer valorInicialFaixa)
			throws ErroRepositorioException {

		String retorno = "";

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select drfx_dsfaixa as cont "
				+ " from cobranca.docs_a_rec_fx_dias_vcdos "
				+ " where (drfx_vlfaixainicio <= " + valorInicialFaixa
				+ " and drfx_vlfaixafim >= " + valorInicialFaixa + " )";
		try {
			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("cont", Hibernate.STRING).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0987] Inserir Faixa de Dias Vencidos para Documentos a Receber
	 * 
	 * Verificar se existe Faixa final j? cadastrada.
	 * 
	 * @author Hugo Leonardo
	 * @param valorFinalFaixa
	 * @throws ControladorException
	 * @data 22/02/2010
	 * 
	 * @return Boolean
	 * @throws ErroRepositorioException
	 */
	public Integer verificarExistenciaFaixaFinal(Integer valorFinalFaixa)
			throws ErroRepositorioException {

		int retorno = 0;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		consulta += " select count(drfx_id) as cont "
				+ " from cobranca.docs_a_rec_fx_dias_vcdos "
				+ " where (drfx_vlfaixainicio <= " + valorFinalFaixa
				+ " and drfx_vlfaixafim >= " + valorFinalFaixa + " )";
		try {
			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("cont", Hibernate.INTEGER).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Gerar Relat?rio de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Collection pesquisarRelatorioDocumentosAReceber(
			FiltroRelatorioDocumentosAReceberHelper helper,
			String tipoTotalizacao, int quantidadeInicio, int quantidadeMaxima)
			throws ErroRepositorioException {
		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		Query query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT " + " dar.catg_id as idCat, "
					+ " cat.catg_dscategoria as dsCat, ";

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, "
						+ " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn, "
						+ " dar.loca_id as idLoca, "
						+ " loc.loca_nmlocalidade as dsLoca,  ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, "
						+ " dar.uneg_id as idUn , "
						+ " un.uneg_nmunidadenegocio as dsUn, ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				consulta += " dar.greg_id as idGer, "
						+ " gr.greg_nmregional as dsGer, ";
			}

			consulta += " dar.dotp_id as idDt, "
					+ " dt.dotp_dsdocumentotipo as dsDt, "
					+ " drrs_icsituacaodocumentos as icSit, "
					+ "  case drrs_icsituacaodocumentos "
					+ "    when 1 then 'A VENCER' "
					+ "    when 2 then 'VENCIDOS' "
					+ "  end as dsSit,  "
					+ " drrs_qtdiasvencidos as faixa, "
					+ " sum(drrs_qtdocumentos) as qtDoc,  "
					+ " sum(drrs_vldocumentos) as vlDoc "
					+ " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					// +" LEFT JOIN cobranca.documentos_a_receber_faixa_dias_vencidos faixa on faixa.drfx_icuso = 1 "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null
					&& !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null
					&& helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null
					&& helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null
					&& !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null
					&& !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator
					.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between "
						+ faixaHelper.getValorInicial() + " and "
						+ faixaHelper.getValorFinal() + " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUS?O DAS FAIXAS

			// AGRUPAMENTO POR TIPO DE TOTALIZA??O
			String orderBy = " order by";
			String groupBy = " group by";

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,dar.loca_id,loc.loca_nmlocalidade,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,dar.loca_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id   ";
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,dar.uneg_id,un.uneg_nmunidadenegocio,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,dar.uneg_id,drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				groupBy += " dar.greg_id,gr.greg_nmregional,drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " dar.greg_id,drrs_icsituacaodocumentos ,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			} else if (tipoTotalizacao.equals("ESTADO")) {
				groupBy += " drrs_icsituacaodocumentos,dar.dotp_id, drrs_qtdiasvencidos,dt.dotp_dsdocumentotipo,dar.catg_id,cat.catg_dscategoria ";
				orderBy += " drrs_icsituacaodocumentos,dar.dotp_id,drrs_qtdiasvencidos,dar.catg_id ";
			}
			// FIM DO AGRUPAMENTO

			consulta = consulta + groupBy + orderBy;

			if (tipoTotalizacao.equals("LOCALIDADE")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idUn", Hibernate.INTEGER)
						.addScalar("dsUn", Hibernate.STRING)
						.addScalar("idLoca", Hibernate.INTEGER)
						.addScalar("dsLoca", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("UNIDADE")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idUn", Hibernate.INTEGER)
						.addScalar("dsUn", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("GERENCIA")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idGer", Hibernate.INTEGER)
						.addScalar("dsGer", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			} else if (tipoTotalizacao.equals("ESTADO")) {
				query = session.createSQLQuery(consulta)
						.addScalar("idCat", Hibernate.INTEGER)
						.addScalar("dsCat", Hibernate.STRING)
						.addScalar("idDt", Hibernate.INTEGER)
						.addScalar("dsDt", Hibernate.STRING)
						.addScalar("icSit", Hibernate.INTEGER)
						.addScalar("dsSit", Hibernate.STRING)
						.addScalar("faixa", Hibernate.STRING)
						.addScalar("qtDoc", Hibernate.INTEGER)
						.addScalar("vlDoc", Hibernate.BIG_DECIMAL);
			}

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = query.setFirstResult(quantidadeInicio)
					.setMaxResults(quantidadeMaxima).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC990] Count Relat?rio de Documentos a Receber
	 * 
	 * @author Hugo Amorim
	 * @date 22/02/2010
	 * 
	 */
	public Integer countRelatorioDocumentosAReceber(
			FiltroRelatorioDocumentosAReceberHelper helper)
			throws ErroRepositorioException {
		Integer retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		Query query = null;

		Map parameters = new HashMap();

		try {

			consulta += " SELECT "
					+ " count(*) as contador "
					+ " FROM financeiro.docs_a_rec_resumo dar "
					+ " INNER JOIN cobranca.documento_tipo dt on dt.dotp_id = dar.dotp_id "
					+ " INNER JOIN cadastro.categoria cat on cat.catg_id = dar.catg_id "
					+ " LEFT JOIN cadastro.categoria_tipo catTipo on catTipo.cgtp_id = cat.cgtp_id "
					+ " INNER JOIN cadastro.gerencia_regional gr on gr.greg_id = dar.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio un on un.uneg_id = dar.uneg_id "
					+ " INNER JOIN cadastro.localidade loc on loc.loca_id = dar.loca_id "
					+ " WHERE drrs_amreferenciarecebimentos = :anoMes and ";

			parameters.put("anoMes", helper.getMesAno());

			if (helper.getIdCategoriaTipo() != null
					&& !helper.getIdCategoriaTipo().equals("-1")) {
				consulta += " catTipo.cgtp_id in(:idCategoriaTipo) and ";
				parameters.put("idCategoriaTipo", helper.getIdCategoriaTipo());

			}

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {

				Collection idsCategorias = new ArrayList();
				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					String idCategoria = helper.getIdsCategoria()[i];
					if (!idCategoria.equals("-1")) {
						idsCategorias.add(new Integer(idCategoria));
					}
				}
				if (idsCategorias.size() > 0) {
					consulta += " dar.catg_id in(:idsCategorias) and ";
					parameters.put("idsCategorias", idsCategorias);
				}
			}

			if (helper.getIdsPerfilImovel() != null
					&& helper.getIdsPerfilImovel().length != 0) {

				Collection idsPerfis = new ArrayList();
				for (int i = 0; i < helper.getIdsPerfilImovel().length; i++) {
					String idPerfil = helper.getIdsPerfilImovel()[i];
					if (!idPerfil.equals("-1")) {
						idsPerfis.add(new Integer(idPerfil));
					}
				}
				if (idsPerfis.size() > 0) {
					consulta += " dar.iper_id in(:idsPerfis) and ";
					parameters.put("idsPerfis", idsPerfis);
				}
			}

			if (helper.getIdsEsferaPoder() != null
					&& helper.getIdsEsferaPoder().length != 0) {

				Collection idsEsferas = new ArrayList();
				for (int i = 0; i < helper.getIdsEsferaPoder().length; i++) {
					String idsEsfera = helper.getIdsEsferaPoder()[i];
					if (!idsEsfera.equals("-1")) {
						idsEsferas.add(new Integer(idsEsfera));
					}
				}
				if (idsEsferas.size() > 0) {
					consulta += " dar.epod_id in(:idsEsferas) and ";
					parameters.put("idsEsferas", idsEsferas);
				}
			}

			if (helper.getIdGerencia() != null
					&& !helper.getIdGerencia().equals("-1")) {
				consulta += " dar.greg_id = :idGerencia and ";
				parameters.put("idGerencia", helper.getIdGerencia());
			}
			if (helper.getIdUnidade() != null
					&& !helper.getIdUnidade().equals("-1")) {
				consulta += " dar.uneg_id = :idUnidade and ";
				parameters.put("idUnidade", helper.getIdUnidade());
			}
			if (helper.getIdLocalidade() != null
					&& !helper.getIdLocalidade().equals("")) {
				consulta += " dar.loca_id = :idLocalidade and ";
				parameters.put("idLocalidade", helper.getIdLocalidade());
			}

			consulta = Util.removerUltimosCaracteres(consulta, 4);

			// INCLUI FAIXAS
			consulta += " and (drrs_qtdiasvencidos = 0 or ";
			for (Iterator iterator = helper.getColecaoFaixas().iterator(); iterator
					.hasNext();) {
				FaixaHelper faixaHelper = (FaixaHelper) iterator.next();

				consulta += " drrs_qtdiasvencidos between "
						+ faixaHelper.getValorInicial() + " and "
						+ faixaHelper.getValorFinal() + " or ";

			}
			consulta = Util.removerUltimosCaracteres(consulta, 3);
			consulta += ")";
			// FIM INCLUS?O DAS FAIXAS

			query = session.createSQLQuery(consulta).addScalar("contador",
					Hibernate.INTEGER);

			// ITERA OS PARAMETROS E COLOCA
			// OS MESMOS NA QUERY
			Set set = parameters.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();
				if (parameters.get(key) instanceof Set) {
					Set setList = (HashSet) parameters.get(key);
					query.setParameterList(key, setList);
				} else if (parameters.get(key) instanceof Collection) {
					Collection collection = (ArrayList) parameters.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parameters.get(key));
				}
			}

			// REALIZA A PESQUISA
			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	// ////////////////////////////////////////////////////////////////////
	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarQuantidadeCobrancaDocumento(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(3, Util.getSQLTimesTemp(new Date()));
			st.setInt(4, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();
			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ? + (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumento);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setInt(3, quantidadeCobrancaDocumentoItem);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(5, valorTotalCobrancaDocumento);
			st.setInt(6, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public Integer pesquisarQuantidadeCobrancaDocumento(
			Integer idCobrancaDocumentoControleGeracao)
			throws ErroRepositorioException {

		Integer retorno = 0;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg.quantidadeCobrancaDocumento "
					+ " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (Integer) session
					.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao",
							idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSomar(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumentoitem = ? + (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_vltotaldoccob = ? + (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?),"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, quantidadeCobrancaDocumentoItem);
			st.setInt(2, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(3, valorTotalCobrancaDocumento);
			st.setInt(4, idCobrancaDocumentoControleGeracao);
			st.setTimestamp(5, Util.getSQLTimesTemp(new Date()));
			st.setInt(6, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 07/04/2010
	 */
	public CobrancaDocumentoControleGeracao pesquisarCobrancaDocumentoControleGeracao(
			Integer idCobrancaDocumentoControleGeracao)
			throws ErroRepositorioException {

		CobrancaDocumentoControleGeracao retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String hql = " select cdcg "
					+ " from gcom.batch.auxiliarbatch.CobrancaDocumentoControleGeracao cdcg "
					+ " where cdcg.id = :idCobrancaDocumentoControleGeracao ";

			retorno = (CobrancaDocumentoControleGeracao) session
					.createQuery(hql)
					.setInteger("idCobrancaDocumentoControleGeracao",
							idCobrancaDocumentoControleGeracao).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracaoSubtrair(
			Integer idCobrancaDocumentoControleGeracao,
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = (select cdcg_qtcobrancadocumento from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_qtcobrancadocumentoitem = (select cdcg_qtcobrancadocumentoitem from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_vltotaldoccob = (select cdcg_vltotaldoccob from auxiliarbatch.cobranca_doc_contr_ger where cdcg_id = ?) - ?,"
					+ " cdcg_tmultimaalteracao =  ? " + " where cdcg_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setInt(1, idCobrancaDocumentoControleGeracao);
			st.setInt(2, quantidadeCobrancaDocumento);
			st.setInt(3, idCobrancaDocumentoControleGeracao);
			st.setInt(4, quantidadeCobrancaDocumentoItem);
			st.setInt(5, idCobrancaDocumentoControleGeracao);
			st.setBigDecimal(6, valorTotalCobrancaDocumento);
			st.setTimestamp(7, Util.getSQLTimesTemp(new Date()));
			st.setInt(8, idCobrancaDocumentoControleGeracao);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * @author Vivianne Sousa
	 * @date 19/04/2010
	 */
	public void atualizarCobrancaDocumentoControleGeracao(
			Integer quantidadeCobrancaDocumento,
			Integer quantidadeCobrancaDocumentoItem,
			BigDecimal valorTotalCobrancaDocumento,
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update auxiliarbatch.cobranca_doc_contr_ger set "
					+ " cdcg_qtcobrancadocumento = ?,"
					+ " cdcg_qtcobrancadocumentoitem = ?,"
					+ " cdcg_vltotaldoccob = ?,"
					+ " cdcg_tmultimaalteracao =  ?" + " where ";

			if (idCobrancaAcaoAtividadeComando != null) {
				consulta = consulta + " cacm_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeComando);

			} else if (idCobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta + " caac_id = ? ";

				st = jdbcCon.prepareStatement(consulta);
				st.setInt(1, quantidadeCobrancaDocumento);
				st.setInt(2, quantidadeCobrancaDocumentoItem);
				st.setBigDecimal(3, valorTotalCobrancaDocumento);
				st.setTimestamp(4, Util.getSQLTimesTemp(new Date()));
				st.setInt(5, idCobrancaAcaoAtividadeCronograma);
			}

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * @author Vivianne Sousa
	 * @date 29/04/2010
	 */
	public Collection pesquisarImovelCobrancaSituacaoPorImovel(Integer idImovel)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select ics"
					+ " from gcom.cadastro.imovel.ImovelCobrancaSituacao ics"
					+ " inner join fetch ics.cobrancaSituacao as cbst "
					+ " where ics.imovel.id = :idImovel "
					+ " and ics.dataRetiradaCobranca is null "
					+ " order by ics.dataImplantacaoCobranca desc ";

			retorno = (List) session.createQuery(hql)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * @author Vivianne Sousa
	 * @date 03/05/2010
	 */
	public Collection pesquisarDadosImovelCobrancaSituacaoPorImovel(
			Integer idImovel) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String hql = " select cbst.descricao, ics.anoMesReferenciaInicio, "
					+ " ics.anoMesReferenciaFinal, ics.dataImplantacaoCobranca, "
					+ " ics.dataRetiradaCobranca , ics.cliente.id  "
					+ " ,escritorio.nome, advogado.nome, ics.id "
					+ " from gcom.cadastro.imovel.ImovelCobrancaSituacao ics"
					+ " inner join ics.cobrancaSituacao as cbst "
					+ " left join ics.escritorio as escritorio "
					+ " left join ics.advogado as advogado "
					+ " where ics.imovel.id = :idImovel "
					+ " order by ics.dataImplantacaoCobranca desc ";

			retorno = session.createQuery(hql).setInteger("idImovel", idImovel)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Atualiza valores do Documento de Cobran?a de cartas.
	 * 
	 * @author Hugo Amorim
	 * @data 29/04/2010
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarValoresDocumentoCobrancaCartas(Integer id,
			BigDecimal descontoTotalPagamentoAVista,
			BigDecimal valorTotalImpostosConta) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {
			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			consulta = "update cobranca.cobranca_documento set "
					+ " cbdo_vldocumento = ? ," + " cbdo_vldesconto = ? ,"
					+ " cbdo_tmultimaalteracao =  " + new Date()
					+ " where cbdo_id = ? ";

			st = jdbcCon.prepareStatement(consulta);

			st.setBigDecimal(1, descontoTotalPagamentoAVista);
			st.setBigDecimal(2, valorTotalImpostosConta);
			st.setInt(3, id);

			// executa o update
			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC????] Relatorio Comando Documento Cobranca Retorna a a??o de cobran?a
	 * para exibi??o de parametros do relat?rio
	 * 
	 * @author Anderson Italo
	 * @data 04/05/2010
	 */
	public CobrancaAcao pesquisarAcaoCobrancaParaRelatorio(
			Integer cobrancaAcaoAtividadeComando,
			Integer cobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		CobrancaAcao retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cobrancaDocumento.cobrancaAcao "
					+ "FROM CobrancaDocumento cobrancaDocumento ";

			if (cobrancaAcaoAtividadeCronograma != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeCronograma.id =  "
						+ cobrancaAcaoAtividadeCronograma + " ";
			} else if (cobrancaAcaoAtividadeComando != null) {
				consulta = consulta
						+ "WHERE cobrancaDocumento.cobrancaAcaoAtividadeComando.id = "
						+ cobrancaAcaoAtividadeComando + " ";
			}

			retorno = (CobrancaAcao) session.createQuery(consulta)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0314] - Parcelamentos por Entrada N?o Paga Author: Arthur Carvalho
	 * Paiva Data: 17/05/2010
	 * 
	 * Obtem os parcelamentos de d?bitos efetuados que estejam com situa??o
	 * normal
	 * 
	 * @param situacaoNormal
	 *            , anoMesFaturamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarTodosParcelamentosSituacaoNormal(
			String parcelamentoSituacao) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT distinct parc.id, parc.parcelamento, imov.id  "
					+ "FROM DebitoACobrar dbac "
					+ "INNER JOIN dbac.parcelamento parc "
					+ "INNER JOIN parc.imovel imov "
					+ "WHERE parc.parcelamentoSituacao = :parcelamentoSituacao "
					+ "AND (parc.valorEntrada IS NOT NULL AND parc.valorEntrada > 0) "
					+ "AND dbac.debitoCreditoSituacaoAtual = :normal ";

			retorno = session
					.createQuery(consulta)
					.setInteger("parcelamentoSituacao",
							new Integer(parcelamentoSituacao))
					.setInteger("normal", DebitoCreditoSituacao.NORMAL).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0998] Gerar Rela??o de Parcelamento - Vis?o Cart?o de Cr?dito
	 * 
	 * Bean que preencher? o relatorio
	 * 
	 * @author Hugo Amorim
	 * @date 11/06/2010
	 * 
	 */
	public Collection<Object[]> filtrarRelacaoParcelamentoCartaoCredito(
			FiltrarRelacaoParcelamentoHelper filtrarRelacaoParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		SQLQuery query = null;
		String consulta = null;
		String joinMunicipio = "";
		String selectMunicipio = "";
		String orderBy = " ORDER BY ";
		if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
				&& !filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados()
						.isEmpty()) {
			joinMunicipio = "    inner join cadastro.municipio muni on ( loca.muni_idprincipal = muni.muni_id ) \n";
			selectMunicipio = ", muni.muni_id, \n  muni.muni_nmmunicipio ";
			orderBy += " muni.muni_nmmunicipio, ";
		}

		try {

			consulta = "select "
					+ " distinct \n"
					+ " parc.parc_id, \n"
					+ " loca.loca_id, \n"
					+ " loca.loca_nmlocalidade, \n"
					+ " geRe.greg_id, \n"
					+ " geRe.greg_nmregional, \n"
					+ " clie.clie_nmcliente, \n"
					+ " parc.imov_id, \n"
					+ " parc.parc_nnprestacoes * parc.parc_vlprestacao as debitoParcelado, \n"
					+ " parc.parc_vlprestacao as valorParcela, \n"
					+ " parc.parc_tmultimaalteracao as dataParcelamento, \n"
					+ " parc.parc_nnprestacoes as qtdParcelas, \n"
					+ " ar.clie_id as clienteArrecadador, \n"
					+ " u.usur_nmusuario as nomeUsuarioConfirmacao, \n"
					+ " pcc.pacc_dtconfirmacao as dtConfirmacao, \n"
					+ " pacc_dtconfirmadooperadora as dtConfirmadooperadora, \n"
					+ " pacc_vlconfirmadooperadora as valorConfirmado \n"
					+ selectMunicipio
					+ " from \n"
					+ "     cobranca.parcelamento parc \n"
					+ "     inner join cadastro.localidade loca on ( loca.loca_id = parc.loca_id ) \n"
					+ joinMunicipio
					+ "     inner join cadastro.gerencia_regional geRe on ( geRe.greg_id = loca.greg_id ) \n"
					+ "     inner join cadastro.unidade_negocio unNe on ( loca.uneg_id = unNe.uneg_id ) \n"
					+ "     inner join cadastro.cliente clie on ( clie.clie_id = parc.clie_id ) \n"
					+ "     inner join cadastro.imovel imo on ( imo.imov_id = parc.imov_id ) \n"
					+ "     inner join cadastro.quadra qua on ( qua.qdra_id = imo.qdra_id ) \n"
					+ "     inner join cobranca.parcel_pagto_cartao_cred pcc on (pcc.parc_id = parc.parc_id) \n"
					+ "     inner join arrecadacao.arrecadador ar on (ar.arrc_id  = pcc.arrc_id) \n"
					+ "     inner join seguranca.usuario u on (u.usur_id = pcc.usur_idconfirmacao) \n"
					+ "     left join cadastro.unidade_organizacional unid ON u.unid_id = unid.unid_id \n"
					+ " where \n" + "  parc.pcst_id = :parcelamentoSituacao";

			// Verificamos quais os filtros informados
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				consulta += " and geRe.greg_id = :idGerenciaRegional \n";
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				consulta += " and unNe.uneg_id = :idUnidadeNegocio \n";
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				consulta += " and loca.loca_cdelo = :idElo \n";
			}

			boolean temLocalidade = false;
			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				consulta += " and parc.loca_id = :idLocalidade ";
				temLocalidade = true;
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				consulta += " and loca.muni_idprincipal IN ( :idMunicipios )";
				if (!temLocalidade) {
					consulta += " and parc.loca_id = loca.loca_id ";
				}
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				consulta += " and parc.parc_cdsetorcomercial = :cdSetorComercial \n";
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				consulta += " and qua.qdra_nnquadra = :numeroQuadra \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				consulta += " and parc.usur_id = :idUsuario \n";
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				consulta += " and parc.parc_tmparcelamento between :dataInicial and :dataFinal \n";
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmacao between :dataConfirmacaoIncial and :dataConfirmacaoFinal \n";
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao()
							.equals("")) {
				consulta += " and pcc.usur_idconfirmacao = :idUsuarioConfirmacao \n";
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento
							.getIndicadorConfirmacaoOperadora().equals("")) {
				consulta += " and pcc.pacc_icconfirmadooperadora = :indicadorConfirmacaoOperadora \n";
			}

			if ((filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				consulta += " and pcc.pacc_dtconfirmadooperadora between :dataConfirmacaoOperadoraIncial and :dataConfirmacaoOperadoraFinal \n";
			}

			// Unidade Organizacional
			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				consulta += " and unid.unid_id = :idUnidadeOrganizacional \n";

			}

			consulta += orderBy + "  loca_id, \n" + "  greg_id, \n"
					+ "  pcc.pacc_dtconfirmacao, \n" + "  clie_nmcliente \n";

			if (!Util.isVazioOrNulo(filtrarRelacaoParcelamento
					.getColecaoMunicipiosAssociados())) {
				query = session.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING)
						.addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING)
						.addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE)
						.addScalar("valorConfirmado", Hibernate.BIG_DECIMAL)
						.addScalar("muni_id", Hibernate.INTEGER)
						.addScalar("muni_nmmunicipio", Hibernate.STRING);
			} else {
				query = session.createSQLQuery(consulta)
						.addScalar("parc_id", Hibernate.INTEGER)
						.addScalar("loca_id", Hibernate.STRING)
						.addScalar("loca_nmlocalidade", Hibernate.STRING)
						.addScalar("greg_id", Hibernate.STRING)
						.addScalar("greg_nmregional", Hibernate.STRING)
						.addScalar("clie_nmcliente", Hibernate.STRING)
						.addScalar("imov_id", Hibernate.INTEGER)
						.addScalar("debitoParcelado", Hibernate.BIG_DECIMAL)
						.addScalar("valorParcela", Hibernate.BIG_DECIMAL)
						.addScalar("dataParcelamento", Hibernate.DATE)
						.addScalar("qtdParcelas", Hibernate.STRING)
						.addScalar("clienteArrecadador", Hibernate.INTEGER)
						.addScalar("nomeUsuarioConfirmacao", Hibernate.STRING)
						.addScalar("dtConfirmacao", Hibernate.DATE)
						.addScalar("dtConfirmadooperadora", Hibernate.DATE)
						.addScalar("valorConfirmado", Hibernate.BIG_DECIMAL);
			}
			query.setInteger("parcelamentoSituacao",
					ParcelamentoSituacao.NORMAL);

			// Adicionamos os parametros necess?rios
			if (filtrarRelacaoParcelamento.getIdGerencia() != null
					&& !filtrarRelacaoParcelamento.getIdGerencia().equals("")) {
				query.setInteger("idGerenciaRegional",
						filtrarRelacaoParcelamento.getIdGerencia());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeNegocio() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeNegocio()
							.equals("")) {
				query.setInteger("idUnidadeNegocio",
						filtrarRelacaoParcelamento.getIdUnidadeNegocio());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getIdElo() != null
					&& !filtrarRelacaoParcelamento.getIdElo().equals("")) {
				query.setInteger("idElo", filtrarRelacaoParcelamento.getIdElo());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getLocalidade() != null) {
				query.setInteger("idLocalidade", filtrarRelacaoParcelamento
						.getParcelamento().getLocalidade().getId());
			}

			if (filtrarRelacaoParcelamento.getColecaoMunicipiosAssociados() != null
					&& !filtrarRelacaoParcelamento
							.getColecaoMunicipiosAssociados().isEmpty()) {
				query.setParameterList("idMunicipios",
						filtrarRelacaoParcelamento
								.getColecaoMunicipiosAssociados());
			}

			if (filtrarRelacaoParcelamento.getParcelamento()
					.getCodigoSetorComercial() != null) {
				query.setInteger("cdSetorComercial", filtrarRelacaoParcelamento
						.getParcelamento().getCodigoSetorComercial());
			}

			if (filtrarRelacaoParcelamento.getParcelamento().getNumeroQuadra() != null) {
				query.setInteger("numeroQuadra", filtrarRelacaoParcelamento
						.getParcelamento().getNumeroQuadra());
			}

			if ((filtrarRelacaoParcelamento.getDataParcelamentoInicial() != null && !filtrarRelacaoParcelamento
					.getDataParcelamentoInicial().equals(""))
					|| (filtrarRelacaoParcelamento.getDataParcelamentoFinal() != null && !filtrarRelacaoParcelamento
							.getDataParcelamentoFinal().equals(""))) {
				query.setTimestamp("dataInicial",
						filtrarRelacaoParcelamento.getDataParcelamentoInicial());
				query.setTimestamp("dataFinal",
						filtrarRelacaoParcelamento.getDataParcelamentoFinal());
			}

			if ((filtrarRelacaoParcelamento.getDataConfirmacaoInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoInicial().equals(""))
					&& (filtrarRelacaoParcelamento.getDataConfirmacaoFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoIncial",
						filtrarRelacaoParcelamento.getDataConfirmacaoInicial());
				query.setTimestamp("dataConfirmacaoFinal",
						filtrarRelacaoParcelamento.getDataConfirmacaoFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioResponsavel() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioResponsavel()
							.equals("")) {
				query.setInteger("idUsuario",
						filtrarRelacaoParcelamento.getIdUsuarioResponsavel());
			}

			if (filtrarRelacaoParcelamento.getIdUsuarioConfirmacao() != null
					&& !filtrarRelacaoParcelamento.getIdUsuarioConfirmacao()
							.equals("")) {
				query.setInteger("idUsuarioConfirmacao",
						filtrarRelacaoParcelamento.getIdUsuarioConfirmacao());
			}

			if (filtrarRelacaoParcelamento.getIndicadorConfirmacaoOperadora() != null
					&& !filtrarRelacaoParcelamento
							.getIndicadorConfirmacaoOperadora().equals("")) {
				query.setShort("indicadorConfirmacaoOperadora",
						filtrarRelacaoParcelamento
								.getIndicadorConfirmacaoOperadora());
			}

			if ((filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial() != null && !filtrarRelacaoParcelamento
					.getDataConfirmacaoOperadoraInicial().equals(""))
					&& (filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal() != null && !filtrarRelacaoParcelamento
							.getDataConfirmacaoOperadoraFinal().equals(""))) {
				query.setTimestamp("dataConfirmacaoOperadoraIncial",
						filtrarRelacaoParcelamento
								.getDataConfirmacaoOperadoraInicial());
				query.setTimestamp("dataConfirmacaoOperadoraFinal",
						filtrarRelacaoParcelamento
								.getDataConfirmacaoOperadoraFinal());
			}

			if (filtrarRelacaoParcelamento.getIdUnidadeOrganizacional() != null
					&& !filtrarRelacaoParcelamento.getIdUnidadeOrganizacional()
							.equals("")) {

				query.setInteger("idUnidadeOrganizacional",
						filtrarRelacaoParcelamento.getIdUnidadeOrganizacional());
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1038] Prescrever D?bitos de Im?veis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public void prescreverDebitosDeImoveis(Integer anoMesFaturamento,
			Integer anoMesPrescricao, Integer usuario,
			String idsCobrancaSituacao) throws ErroRepositorioException {

		String update;
		Session session = HibernateUtil.getSession();

		PreparedStatement st = null;

		try {

			// declara o tipo de conexao
			Connection jdbcCon = session.connection();

			// Atualiza Contas
			update = " update faturamento.conta c "
					+ " set 	dcst_idatual = 8, " + "       usur_id = "
					+ usuario.intValue()
					+ ", "
					+ " 		dcst_idanterior = NULL, "
					+ " 		cnta_dtcancelamento =  "
					+ Util.obterSQLDataAtual()
					+ " , "
					+ " 		cmcn_id = 99, "
					+ "       cnta_amreferenciacontabil = "
					+ anoMesFaturamento.intValue()
					+ ", "
					+ "       cnta_tmultimaalteracao = "
					+ Util.obterSQLDataAtual()
					+ " where c.cnta_amreferenciaconta < "
					+ anoMesPrescricao.intValue()
					+ " and   c.cnta_amreferenciacontabil < "
					+ anoMesFaturamento.intValue()
					+ " and   c.dcst_idatual in (0,1,2) "
					+ " and not exists (select cnta_id "
					+ " 				  from faturamento.conta_categoria g "
					+ " 				  where c.cnta_id=g.cnta_id "
					+ " 				  and catg_id = 4) "
					+ " and not exists (select ics.imov_id "
					+ " 				  from cadastro.imovel_cobranca_situacao ics "
					+ " 				  where c.imov_id = ics.imov_id "
					+ " 				  and iscb_dtretiradacobranca is null "
					+ " 				  and cbst_id in (" + idsCobrancaSituacao + ")) ";

			st = jdbcCon.prepareStatement(update);

			// executa o update
			st.executeUpdate();

			// erro no hibernate
		} catch (SQLException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC1038] Prescrever D?bitos de Im?veis
	 * 
	 * @author Hugo Leonardo
	 * @date 07/07/2010
	 * 
	 * @param idFuncionalidadeIniciada
	 * @param anoMesFaturamento
	 * @throws ErroRepositorioException
	 */
	public Collection obterCobrancaSituacaoParaPrescreverDebitos()
			throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " select cosi.id "
					+ " from gcom.cobranca.CobrancaSituacao cosi "
					+ " where cosi.indicadorPrescricaoImoveisParticulares = 2 ";

			retorno = (Collection) session.createQuery(consulta).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		// retorna a cole??o de atividades pesquisada(s)
		return retorno;
	}

	/**
	 * [UC1038] Prescrever D?bitos de Im?veis Pesquisa imoveis para execu??o do
	 * batch
	 * 
	 * @author Hugo Leonardo
	 * @date 19/07/2010
	 */
	public Collection obterContasPrescreverDebitosDeImoveis(
			Integer idLocalidade, Integer anoMesFaturamento,
			String idsCobrancaSituacao, int numeroIndice,
			int quantidadeRegistros) throws ErroRepositorioException {

		Collection retorno = null;
		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " SELECT  c.cnta_id idConta"
					+ " FROM faturamento.conta c " + " WHERE loca_id = "
					+ idLocalidade + " AND (" + anoMesFaturamento
					+ " - c.cnta_amreferenciaconta) > 1000"
					+ " AND c.cnta_amreferenciacontabil < " + anoMesFaturamento
					+ " AND dcst_idatual in ( 0,1,2 )" + " AND NOT EXISTS ( "
					+ " 	SELECT cnta_id "
					+ "  	FROM faturamento.conta_categoria g "
					+ "  	WHERE c.cnta_id = g.cnta_id " + " 	AND catg_id = 4 )"
					+ " AND NOT EXISTS ( " + "  	SELECT ics.imov_id "
					+ " 	FROM cadastro.imovel_cobranca_situacao ics "
					+ " 	WHERE c.imov_id = ics.imov_id "
					+ " 	AND iscb_dtretiradacobranca is null "
					+ " 	AND cbst_id in ( " + idsCobrancaSituacao + ") )";

			retorno = (Collection) session.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0244] Manter Comando A??o de Cobran?a
	 * 
	 * @author Hugo Amorim
	 * @created 14/07/2010
	 * 
	 * @exception ErroRepositorioException
	 * 
	 */
	public void removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao;

		try {
			removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao = "delete CobrancaAcaoAtividadeComandoFiscalizacaoSituacao "
					+ "where cobrancaAcaoAtividadeComando = :idComando ";

			session.createQuery(
					removerCobrancaAcaoAtividadeComandoFiscalizacaoSituacao)
					.setInteger("idComando", idComando).executeUpdate();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * Obtem os percentuais de desconto por tempo de inatividade a vista
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 20/07/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcDesctoInativVista obterPercentualDescontoInatividadeAVista(
			Integer idPerfilParc, int qtdeMeses)
			throws ErroRepositorioException {

		ParcDesctoInativVista retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT pdin " + "FROM ParcDesctoInativVista pdin "
					+ "WHERE pdin.parcelamentoPerfil.id = :idPerfilParc "
					+ "AND pdin.quantidadeMaximaMesesInatividade IN ("
					+ "SELECT max(p.quantidadeMaximaMesesInatividade)"
					+ "FROM ParcelamentoDescontoInatividade p "
					+ "WHERE p.quantidadeMaximaMesesInatividade <= :qtdeMeses)";

			retorno = (ParcDesctoInativVista) session.createQuery(consulta)
					.setInteger("idPerfilParc", idPerfilParc.intValue())
					.setInteger("qtdeMeses", qtdeMeses).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * Atualizar total de documentos, itens e valores realizados nos comandos de
	 * acao de cobranca
	 * 
	 * Data: 19/07/2010
	 * 
	 * @author Arthur Carvalho
	 * 
	 * @param idCACM
	 *            Identificador de CobrancaAcaoAtividadeComando
	 * @return Array de objetos com valores de 0 - quantidade de itens cobrados
	 *         1 - valor total dos documentos 2 - quantidade de documentos
	 */
	public Object[] calcularTotaisComandoAcaoCobranca(Integer idCACM)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = new Object[3];

		try {

			Date dataAtual = new Date();

			// usou-se a condicao ultimaAlteracao > xxxxxx para melhorar o tempo
			// da query
			String consulta = "SELECT count(cdi.id) FROM CobrancaDocumentoItem cdi where "
					+ "cdi.ultimaAlteracao > :dataGeracaoItem "
					+ " and cdi.cobrancaDocumento.id in "
					+ "(select cd.id from CobrancaDocumento cd where cd.cobrancaAcaoAtividadeComando.id = :idCACM) ";

			// quantidade de itens cobrados
			retorno[0] = (Integer) session
					.createQuery(consulta)
					.setInteger("idCACM", idCACM)
					.setDate("dataGeracaoItem",
							Util.subtrairNumeroDiasDeUmaData(dataAtual, 2))
					.uniqueResult();

			consulta = "SELECT sum(cd.valorDocumento) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// valor total dos documentos
			retorno[1] = (BigDecimal) session.createQuery(consulta)
					.setInteger("idCACM", idCACM).uniqueResult();

			consulta = "SELECT count(cd.id) FROM CobrancaDocumento cd "
					+ "where cd.cobrancaAcaoAtividadeComando.id = :idCACM ";

			// quantidade de documentos
			retorno[2] = (Integer) session.createQuery(consulta)
					.setInteger("idCACM", idCACM).uniqueResult();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * atualiza a forma da emiss?o do documento de cobran?a
	 * 
	 * @author S?vio Luiz
	 * @date 12/08/2010
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void atualizarFormaEmissaoCobrancaDocumento(
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String consulta = "update gcom.cobranca.CobrancaDocumento "
					+ "set demf_id = :formaEmissao , "
					+ "cbdo_tmultimaalteracao = :dataAtual "
					+ "where cbdo_id = :idCobrancaDocumento ";

			session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setInteger("formaEmissao",
							DocumentoEmissaoForma.IMPRESSAO_SIMULTANEA)
					.setDate("dataAtual", new Date()).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

		}
	}

	/**
	 * Pesquisa Documentos de cobran?as validos para imovel para determinado
	 * tipo de documento
	 * 
	 * @author Hugo Amorim
	 * @date 09/09/2010
	 */
	public Collection<CobrancaDocumento> pesquisarDadosCobrancaDocumentoValidoImovel(
			Integer idImovel, Integer idDocumentoTipo, Integer idAcaoCobranca)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT cd "
					+ " FROM CobrancaDocumento cd "
					+ " INNER JOIN FETCH cd.documentoTipo dt"
					+ " INNER JOIN FETCH cd.cobrancaAcao ca"
					+ " WHERE dt.id = :idDocumentoTipo AND"
					+ " cd.imovel.id = :idImovel AND"
					+ " ca.id = :idAcaoCobranca AND"
					+ " (TO_DATE (TO_CHAR (cd.emissao, 'YYYY-MON-DD HH24:MI:SS'), 'YYYY-MON-DD HH24:MI:SS') + ca.numeroDiasValidade) >= "
					+ Util.obterSQLDataAtual() + " ";

			retorno = session.createQuery(consulta)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setInteger("idImovel", idImovel)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					// .setDate("dataAtual", Util.obterSQLDataAtual())
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0478] Gerar Resumo das A??es de Cobran?a do Cronograma
	 * 
	 * Data: 16/09/2010
	 * 
	 * @author Vivianne Sousa
	 */
	public Integer pesquisarCobrancaDocumentoFisc(
			Integer idFiscalizacaoSituacao, Integer idOrdemServico,
			Integer idCobrancaDocumento) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select cdfz.id "
					+ "from CobrancaDocumentoFisc cdfz "
					+ "where "
					+ " cdfz.fiscalizacaoSituacao.id = :idFiscalizacaoSituacao "
					+ " and cdfz.ordemServico.id = :idOrdemServico "
					+ " and cdfz.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session
					.createQuery(consulta)
					.setInteger("idFiscalizacaoSituacao",
							idFiscalizacaoSituacao)
					.setInteger("idOrdemServico", idOrdemServico)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0852] ? Incluir D?bito a Cobrar de Entrada de Parcelamento N?o Paga
	 * 
	 * --- --- Pesquisa a guia de pagamento do parcelamento --- ---
	 * 
	 * @author Arthur Carvalho
	 * @date 22/09/2010
	 * @param parcelamento
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarGuiaPagamentoDoParcelamentoPorEntradaNaoPaga(
			String parcelamento) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT gpag.id, gpag.dataVencimento  "
					+ "FROM GuiaPagamento gpag "
					+ "WHERE gpag.parcelamento = :parcelamento "
					+ "and gpag.debitoCreditoSituacaoAtual in (0,1,2) ";

			retorno = session.createQuery(consulta)
					.setInteger("parcelamento", new Integer(parcelamento))
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Pesquisa por todos os impostos a partir de uma fatura de um cliente
	 * responsavel federal e/ou de um imovel.
	 * 
	 * A fatura ? obrigat?ria.
	 * 
	 * OBS: O id da fatura passado tem que ser de uma fatura de um cliente
	 * responsavel federal
	 * 
	 * @author Fernando Fontelles, Mariana Victor
	 * @date 24/09/2010, 24/02/2011
	 * 
	 * @param Integer
	 *            idFatura
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisaImpostoFaturaClienteResponsavelFederalAnalitico(
			/* Integer idFatura */Integer anoMesFerencia, Integer idCliente/*
																			 * Integer
																			 * idImovel
																			 */)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			Query query = null;

			if (idCliente != null) {

				consulta = "SELECT imtp.imtp_id                                                  AS "
						+ "       impostoTipo,  "
						+ "       imtp.imtp_dsimposto                                           AS "
						+ "       descricaoImposto, "
						+ "       cnid.cnid_pcaliquota                                          AS "
						+ "       percAliquota, "
						+ "       Sum(cnid.cnid_vlimposto)                                      AS "
						+ "       valorImposto, "
						+ "       clie.clie_id                                                  AS cliente, "
						+ "       clie_nmcliente                                                AS "
						+ "       nomeCliente, "
						+ "       Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto  "
						+ "               + cnta.cnta_vldebitos ) - ( "
						+ "             cnta.cnta_vlcreditos + cnta.cnta_vlimpostos "
						+ "                                         ) ))                        AS "
						+ "       valorFatura, "
						+ "       cnta.imov_id                                                   AS imovel, "
						+ "       clie.clie_nncnpj                                              AS cnpj, "
						+ "       Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "               + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS "
						+ "       baseCalculo "
						+ "FROM   faturamento.conta_impostos_deduzidos cnid "
						+ "       INNER JOIN faturamento.conta cnta "
						+ "               ON ( cnid.cnta_id = cnta.cnta_id ) "
						+ "       INNER JOIN cadastro.cliente_conta clct "
						+ "               ON ( cnta.cnta_id = clct.cnta_id "
						+ "                    AND clct.crtp_id = :cliRelacaoTipo ) "
						+ "       INNER JOIN cadastro.cliente clie "
						+ "               ON ( clct.clie_id = clie.clie_id ) "
						+ "       INNER JOIN cadastro.cliente_tipo cltp "
						+ "               ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "       INNER JOIN faturamento.imposto_tipo imtp "
						+ "               ON ( cnid.imtp_id = imtp.imtp_id ) "
						+ "WHERE  clct.clie_id = :idCliente AND  "
						+ "  cnta.cnta_id IN (SELECT idconta "
						+ "                   FROM "
						+ "  (SELECT imovel, "
						+ "          referencia, "
						+ "          Min(cnta_id) AS idconta "
						+ "   FROM   (SELECT conta.imov_id                AS imovel "
						+ "                  , "
						+ "                  conta.cnta_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  conta.cnta_id "
						+ "           FROM   faturamento.conta conta "
						+ "           WHERE  conta.cnta_amreferenciaconta = :anoMesReferencia "
						+ "           UNION ALL "
						+ "           SELECT contaHist.imov_id                AS "
						+ "                  imovel, "
						+ "                  contaHist.cnhi_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  contaHist.cnta_id "
						+ "           FROM   faturamento.conta_historico contaHist "
						+ "           WHERE  contaHist.cnhi_amreferenciaconta = "
						+ "                  :anoMesReferencia) a "
						+ "   GROUP  BY imovel, "
						+ "             referencia) b) "
						+ "GROUP  BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          cnta.imov_id, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cnid.cnid_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ "UNION ALL "
						+ "SELECT imtp.imtp_id                                                 impostoTipo, "
						+ "       imtp.imtp_dsimposto                                          AS "
						+ "       descricaoImposto, "
						+ "       cidh.cidh_pcaliquota                                         AS "
						+ "       percAliquota, "
						+ "       Sum(cidh.cidh_vlimposto)                                     AS "
						+ "       valorImposto, "
						+ "       clie.clie_id                                                 AS cliente, "
						+ "       clie_nmcliente                                               AS "
						+ "       nomeCliente, "
						+ "       Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "               + cnhi.cnhi_vldebitos ) - ( "
						+ "             cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos "
						+ "                                         ) ))                       AS "
						+ "       valorFatura, "
						+ "       cnhi.imov_id                                                 AS imovel, "
						+ "       clie.clie_nncnpj                                             AS cnpj, "
						+ "       Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "               + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) ))AS "
						+ "       baseCalculo "
						+ "FROM   faturamento.conta_impostos_dedz_hist cidh "
						+ "       INNER JOIN faturamento.conta_historico cnhi "
						+ "               ON ( cidh.cnta_id = cnhi.cnta_id ) "
						+ "       INNER JOIN cadastro.cliente_conta_historico clch "
						+ "               ON ( cnhi.cnta_id = clch.cnta_id "
						+ "                    AND clch.crtp_id = :cliRelacaoTipo ) "
						+ "       INNER JOIN cadastro.cliente clie "
						+ "               ON ( clch.clie_id = clie.clie_id ) "
						+ "       INNER JOIN cadastro.cliente_tipo cltp "
						+ "               ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "       INNER JOIN faturamento.imposto_tipo imtp "
						+ "               ON ( cidh.imtp_id = imtp.imtp_id ) "
						+ "WHERE  clch.clie_id = :idCliente AND  "
						+ "  cnhi.cnta_id IN (SELECT idconta "
						+ "                   FROM "
						+ "  (SELECT imovel, "
						+ "          referencia, "
						+ "          Min(cnta_id) AS idconta "
						+ "   FROM   (SELECT conta.imov_id                AS imovel "
						+ "                  , "
						+ "                  conta.cnta_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  conta.cnta_id "
						+ "           FROM   faturamento.conta conta "
						+ "           WHERE  conta.cnta_amreferenciaconta = :anoMesReferencia "
						+ "           UNION ALL "
						+ "           SELECT contaHist.imov_id                AS "
						+ "                  imovel, "
						+ "                  contaHist.cnhi_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  contaHist.cnta_id "
						+ "           FROM   faturamento.conta_historico contaHist "
						+ "           WHERE  contaHist.cnhi_amreferenciaconta = "
						+ "                  :anoMesReferencia) a "
						+ "   GROUP  BY imovel, "
						+ "             referencia) b) "
						+ "GROUP  BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          cnhi.imov_id, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cidh.cidh_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ "ORDER  BY cliente, "
						+ "          imovel, " + "          impostotipo   ";

				query = session
						.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER)
						.addScalar("cnpj", Hibernate.STRING)
						.setShort("cliRelacaoTipo",
								ClienteRelacaoTipo.RESPONSAVEL)
						.setInteger("anoMesReferencia", anoMesFerencia)
						.setInteger("idCliente", idCliente);

			} else {

				consulta = "SELECT imtp.imtp_id                                                  AS "
						+ "       impostoTipo,  "
						+ "       imtp.imtp_dsimposto                                           AS "
						+ "       descricaoImposto, "
						+ "       cnid.cnid_pcaliquota                                          AS "
						+ "       percAliquota, "
						+ "       Sum(cnid.cnid_vlimposto)                                      AS "
						+ "       valorImposto, "
						+ "       clie.clie_id                                                  AS cliente, "
						+ "       clie_nmcliente                                                AS "
						+ "       nomeCliente, "
						+ "       Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto  "
						+ "               + cnta.cnta_vldebitos ) - ( "
						+ "             cnta.cnta_vlcreditos + cnta.cnta_vlimpostos "
						+ "                                         ) ))                        AS "
						+ "       valorFatura, "
						+ "       cnta.imov_id                                                   AS imovel, "
						+ "       clie.clie_nncnpj                                              AS cnpj, "
						+ "       Sum(( ( cnta.cnta_vlagua + cnta.cnta_vlesgoto "
						+ "               + cnta.cnta_vldebitos ) - ( cnta.cnta_vlcreditos ) )) AS "
						+ "       baseCalculo "
						+ "FROM   faturamento.conta_impostos_deduzidos cnid "
						+ "       INNER JOIN faturamento.conta cnta "
						+ "               ON ( cnid.cnta_id = cnta.cnta_id ) "
						+ "       INNER JOIN cadastro.cliente_conta clct "
						+ "               ON ( cnta.cnta_id = clct.cnta_id "
						+ "                    AND clct.crtp_id = :cliRelacaoTipo ) "
						+ "       INNER JOIN cadastro.cliente clie "
						+ "               ON ( clct.clie_id = clie.clie_id ) "
						+ "       INNER JOIN cadastro.cliente_tipo cltp "
						+ "               ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "       INNER JOIN faturamento.imposto_tipo imtp "
						+ "               ON ( cnid.imtp_id = imtp.imtp_id ) "
						+ "WHERE  "
						+ "  cnta.cnta_id IN (SELECT idconta "
						+ "                   FROM "
						+ "  (SELECT imovel, "
						+ "          referencia, "
						+ "          Min(cnta_id) AS idconta "
						+ "   FROM   (SELECT conta.imov_id                AS imovel "
						+ "                  , "
						+ "                  conta.cnta_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  conta.cnta_id "
						+ "           FROM   faturamento.conta conta "
						+ "           WHERE  conta.cnta_amreferenciaconta = :anoMesReferencia "
						+ "           UNION ALL "
						+ "           SELECT contaHist.imov_id                AS "
						+ "                  imovel, "
						+ "                  contaHist.cnhi_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  contaHist.cnta_id "
						+ "           FROM   faturamento.conta_historico contaHist "
						+ "           WHERE  contaHist.cnhi_amreferenciaconta = "
						+ "                  :anoMesReferencia) a "
						+ "   GROUP  BY imovel, "
						+ "             referencia) b) "
						+ "GROUP  BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          cnta.imov_id, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cnid.cnid_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ "UNION ALL "
						+ "SELECT imtp.imtp_id                                                 impostoTipo, "
						+ "       imtp.imtp_dsimposto                                          AS "
						+ "       descricaoImposto, "
						+ "       cidh.cidh_pcaliquota                                         AS "
						+ "       percAliquota, "
						+ "       Sum(cidh.cidh_vlimposto)                                     AS "
						+ "       valorImposto, "
						+ "       clie.clie_id                                                 AS cliente, "
						+ "       clie_nmcliente                                               AS "
						+ "       nomeCliente, "
						+ "       Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "               + cnhi.cnhi_vldebitos ) - ( "
						+ "             cnhi.cnhi_vlcreditos + cnhi.cnhi_vlimpostos "
						+ "                                         ) ))                       AS "
						+ "       valorFatura, "
						+ "       cnhi.imov_id                                                 AS imovel, "
						+ "       clie.clie_nncnpj                                             AS cnpj, "
						+ "       Sum(( ( cnhi.cnhi_vlagua + cnhi.cnhi_vlesgoto "
						+ "               + cnhi.cnhi_vldebitos ) - ( cnhi.cnhi_vlcreditos ) ))AS "
						+ "       baseCalculo "
						+ "FROM   faturamento.conta_impostos_dedz_hist cidh "
						+ "       INNER JOIN faturamento.conta_historico cnhi "
						+ "               ON ( cidh.cnta_id = cnhi.cnta_id ) "
						+ "       INNER JOIN cadastro.cliente_conta_historico clch "
						+ "               ON ( cnhi.cnta_id = clch.cnta_id "
						+ "                    AND clch.crtp_id = :cliRelacaoTipo ) "
						+ "       INNER JOIN cadastro.cliente clie "
						+ "               ON ( clch.clie_id = clie.clie_id ) "
						+ "       INNER JOIN cadastro.cliente_tipo cltp "
						+ "               ON ( clie.cltp_id = cltp.cltp_id ) "
						+ "       INNER JOIN faturamento.imposto_tipo imtp "
						+ "               ON ( cidh.imtp_id = imtp.imtp_id ) "
						+ "WHERE "
						+ "  cnhi.cnta_id IN (SELECT idconta "
						+ "                   FROM "
						+ "  (SELECT imovel, "
						+ "          referencia, "
						+ "          Min(cnta_id) AS idconta "
						+ "   FROM   (SELECT conta.imov_id                AS imovel "
						+ "                  , "
						+ "                  conta.cnta_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  conta.cnta_id "
						+ "           FROM   faturamento.conta conta "
						+ "           WHERE  conta.cnta_amreferenciaconta = :anoMesReferencia "
						+ "           UNION ALL "
						+ "           SELECT contaHist.imov_id                AS "
						+ "                  imovel, "
						+ "                  contaHist.cnhi_amreferenciaconta AS "
						+ "                  referencia, "
						+ "                  contaHist.cnta_id "
						+ "           FROM   faturamento.conta_historico contaHist "
						+ "           WHERE  contaHist.cnhi_amreferenciaconta = "
						+ "                  :anoMesReferencia) a "
						+ "   GROUP  BY imovel, "
						+ "             referencia) b) "
						+ "GROUP  BY clie.clie_id, "
						+ "          clie_nmcliente, "
						+ "          cnhi.imov_id, "
						+ "          imtp.imtp_id, "
						+ "          imtp.imtp_dsimposto, "
						+ "          cidh.cidh_pcaliquota, "
						+ "          clie.clie_nncnpj "
						+ "ORDER  BY cliente, "
						+ "          imovel, " + "          impostotipo   ";

				query = session
						.createSQLQuery(consulta)
						.addScalar("impostoTipo", Hibernate.INTEGER)
						.addScalar("descricaoImposto", Hibernate.STRING)
						.addScalar("percAliquota", Hibernate.BIG_DECIMAL)
						.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
						.addScalar("cliente", Hibernate.INTEGER)
						.addScalar("nomeCliente", Hibernate.STRING)
						.addScalar("valorFatura", Hibernate.BIG_DECIMAL)
						.addScalar("imovel", Hibernate.INTEGER)
						.addScalar("cnpj", Hibernate.STRING)
						.setShort("cliRelacaoTipo",
								ClienteRelacaoTipo.RESPONSAVEL)
						.setInteger("anoMesReferencia", anoMesFerencia);
			}

			retorno = (Collection) query.list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC676] Consultar Resumo Negativa??o
	 * 
	 * @author Ivan Sergio
	 * @date 14/01/2011
	 * 
	 * @param dadosConsultaNegativacaoHelper
	 * @param idSituacaoDebito
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection consultarNegativacaoLigacaoAguaPorSituacaoDebito(
			DadosConsultaNegativacaoHelper dadosConsultaNegativacaoHelper,
			int idSituacaoDebito) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = "";

		try {
			consulta = " select new gcom.gui.cobranca.spcserasa.NegativacaoHelper (last.id, last.descricao, "
					+ " sum(re.quantidadeInclusoes),sum(coalesce(re.valorDebito,0)), sum(coalesce(re.valorPendente,0)), "
					+ " sum(coalesce(re.valorPago,0)), sum(coalesce(re.valorParcelado,0)), sum(coalesce(re.valorCancelado,0))) "
					+ " from ResumoNegativacao re "
					+ " inner join re.negativador neg "
					+ " left outer join re.ligacaoAguaSituacao last "
					+ " where re.cobrancaDebitoSituacao.id = :idSituacaoDebito "
					+ this.criarCondicionaisResumosHQL(dadosConsultaNegativacaoHelper)
					+ " group by last.id, last.descricao "
					+ " order by last.id, last.descricao ";

			retorno = session.createQuery(consulta)
					.setInteger("idSituacaoDebito", idSituacaoDebito).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Servi?o da A??o de Cobran?a
	 * 
	 * @author Mariana Victor
	 * @created 02/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Integer> pesquisarOrdemServicoParaEncerrar(
			Integer idCobrancaAcaoCronograma) throws ErroRepositorioException {
		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<Integer> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caac.caac_id AS ativCronograma "
					+ "   FROM cobranca.cobranca_acao_ativ_crg caac "
					+ " WHERE caac.cbcr_id = :idCobrancaAcaoCronograma "
					+ " GROUP BY caac.caac_id " + " ORDER BY caac.caac_id ";

			// executa o hql
			Query query = session
					.createSQLQuery(consulta)
					.addScalar("ativCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcaoCronograma",
							idCobrancaAcaoCronograma);
			retorno = (Collection<Integer>) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Servi?o da A??o de Cobran?a
	 * 
	 * @author Mariana Victor
	 * @created 10/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtivCronogOrdemServicoParaEncerrar(
			Integer idAtividadeCronograma) throws ErroRepositorioException {
		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS ativCronograma, caatcr.caac_tmcomando AS comando, "
					+ " caatcr.caac_dtprevista AS dataPrevista, os.orse_id AS ordemServico, cbat_id as idCobrancaAtividade "
					+ " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caatcr ON caatcr.caac_id = cd.caac_id AND caatcr.caac_id = :idAtividadeCronograma"
					+ " WHERE os.orse_cdsituacao = 1 ";

			// executa o hql
			Query query = session.createSQLQuery(consulta)
					.addScalar("ativCronograma", Hibernate.INTEGER)
					.addScalar("comando", Hibernate.TIMESTAMP)
					.addScalar("dataPrevista", Hibernate.DATE)
					.addScalar("ordemServico", Hibernate.INTEGER)
					.addScalar("idCobrancaAtividade", Hibernate.INTEGER)
					.setInteger("idAtividadeCronograma", idAtividadeCronograma);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1112] Processar Encerramento Ordens de Servi?o da A??o de Cobran?a
	 * 
	 * @author Mariana Victor
	 * @created 07/12/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */
	public Collection<Object[]> pesquisarAtividadeCronograma(
			Integer idCobrancaAcao) throws ErroRepositorioException {
		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = " SELECT caatcr.caac_id AS atividadeCronograma "
					+ " FROM atendimentopublico.ordem_servico os "
					+ " INNER JOIN cobranca.cobranca_documento cd ON os.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao ca ON cd.cbac_id = ca.cbac_id AND ca.cbac_id = :idCobrancaAcao "
					+ " INNER JOIN cobranca.cobranca_acao_atividade_cronog caatcr ON caatcr.caac_id = cd.caac_id "
					+ " WHERE os.orse_cdsituacao = 1 "
					+ " GROUP BY caatcr.caac_id ";

			// executa o hql
			Query query = session.createSQLQuery(consulta)
					.addScalar("atividadeCronograma", Hibernate.INTEGER)
					.setInteger("idCobrancaAcao", idCobrancaAcao);
			retorno = (Collection) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	public Collection<Object[]> pesquisarLocalidade(int idOrdemServico)
			throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();

		String consulta = null;

		try {

			consulta = "select imv.loca_id AS idLocalidade "
					+ " from atendimentopublico.ordem_servico os "
					+ " INNER JOIN cadastro.imovel imv ON os.imov_id = imv.imov_id "
					+ " WHERE os.orse_id = :idOrdemServico ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idOrdemServico", idOrdemServico).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0003] Gerar Atividade de
	 * A??o de Cobran?a para Im?vel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Collection pesquisarIdDocumentoCobrancaParaImovel(Integer idImovel,
			Integer idDocumentoTipo) throws ErroRepositorioException {

		Collection retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adcionarOuSubtrairMesesAData(new Date(), -12, 0);

		try {

			consulta = "select cbdo.id " + " from CobrancaDocumento cbdo "
					+ " where cbdo.imovel.id = :idImovel "
					+ " and cbdo.documentoTipo = :idDocumentoTipo "
					+ " and cbdo.emissao >= :dataLimite "
					+ " order by cbdo.id desc " + " limit 12 ";

			retorno = session.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", idDocumentoTipo)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0003] Gerar Atividade de
	 * A??o de Cobran?a para Im?vel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0003] Gerar Atividade de
	 * A??o de Cobran?a para Im?vel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemConta(
			Collection idsCobrancaDocumento, Collection colecaoConta)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -20);
		try {

			consulta = "select count(cdit.id) "
					+ " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) "
					+ " and cdit.contaGeral.id in (:colecaoConta) "
					+ " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session
					.createQuery(consulta)
					.setParameterList("idsCobrancaDocumento",
							idsCobrancaDocumento)
					.setParameterList("colecaoConta", colecaoConta)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a [SB0003] Gerar Atividade de
	 * A??o de Cobran?a para Im?vel
	 * 
	 * @author Vivianne Sousa
	 * @created 22/12/2010
	 **/
	public Integer pesquisarQtdeDocumentoCobrancaItemDebitoACobrar(
			Collection idsCobrancaDocumento, Collection colecaoDebitoACobrar)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(new Date(), -30);
		try {

			consulta = "select count(cdit.id) "
					+ " from CobrancaDocumentoItem cdit "
					+ " where cdit.cobrancaDocumento.id in (:idsCobrancaDocumento) "
					+ " and cdit.debitoACobrarGeral.id in (:colecaoDebitoACobrar) "
					+ " and cdit.cobrancaDocumento.emissao <= :dataLimite";

			retorno = (Integer) session
					.createQuery(consulta)
					.setParameterList("idsCobrancaDocumento",
							idsCobrancaDocumento)
					.setParameterList("colecaoDebitoACobrar",
							colecaoDebitoACobrar)
					.setDate("dataLimite", Util.formatarDataFinal(dataLimite))
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public Integer pesquisarQuantidadeContasDebito(Integer idCobrancaDocumento)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(conta) "
					+ " FROM CobrancaDocumentoItem cdit "
					+ " INNER JOIN cdit.contaGeral contaGeral "
					+ " INNER JOIN contaGeral.conta conta "
					+ " WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento ";

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 20/01/2011
	 **/
	public List<String> pesquisarTipoDeCorte() throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cotp_dscortetipo AS descricao "
					+ "FROM atendimentopublico.corte_tipo "
					+ "WHERE cotp_icform = 1 ORDER BY cotp_id ";

			retorno = (List<String>) session.createSQLQuery(consulta)
					.addScalar("descricao", Hibernate.STRING).setMaxResults(5)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * @author Mariana Victor
	 * @created 26/01/2011
	 **/
	public List<String> pesquisarOcorrenciasFiscalizacao()
			throws ErroRepositorioException {

		List<String> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT fzst_dsfiscalizacaosituacao AS descricao "
					+ " FROM atendimentopublico.fiscalizacao_situacao"
					+ " WHERE fzst_icform = 1 ORDER BY fzst_id ";

			retorno = (List<String>) session.createSQLQuery(consulta)
					.addScalar("descricao", Hibernate.STRING).setMaxResults(15)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0xxx] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * @author R?mulo Aur?lio
	 * @created 17/02/2011
	 **/

	public void atualizarDataRealizacaoCobrancaAcaoAtivCronograma(
			Integer idCobAcaoAtivCron) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String hql = "";
		try {
			hql = "update gcom.cobranca.CobrancaAcaoAtividadeCronograma "
					+ "set realizacao = " + Util.obterSQLDataAtual()
					+ " where id = :id ";

			session.createQuery(hql).setInteger("id", idCobAcaoAtivCron)
					.executeUpdate();

		} catch (Exception e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * Seleciona os itens do documento de cobran?a correspondentes a guia
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteGuia(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.guiaPagamentoGeral guia "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "guia.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * Seleciona os itens do documento de cobran?a correspondentes a d?bito ?
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteDebitoACobrar(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.debitoACobrarGeral debitoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "debitoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0349] Emitir Documento de Cobran?a
	 * 
	 * Seleciona os itens do documento de cobran?a correspondentes a credito ?
	 * cobrar
	 * 
	 * @author Mariana Victor
	 * @data 16/03/2011
	 * 
	 * @param CobrancaDocumento
	 * @return Collection<CobrancaDocumentoItem>
	 */
	public Collection<CobrancaDocumentoItem> selecionarCobrancaDocumentoItemReferenteCreditoACobrar(
			CobrancaDocumento cobrancaDocumento)
			throws ErroRepositorioException {

		Collection<CobrancaDocumentoItem> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdit "
					+ "FROM CobrancaDocumentoItem cdit "
					+ "LEFT JOIN fetch cdit.creditoARealizarGeral creditoACobrar "
					+ "WHERE cdit.cobrancaDocumento.id = :idCobrancaDocumento AND "
					+ "creditoACobrar.id IS NOT NULL";

			retorno = new ArrayList(new CopyOnWriteArraySet(session
					.createQuery(consulta)
					.setInteger("idCobrancaDocumento",
							cobrancaDocumento.getId()).list()));

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * inserir na tabela temporaria os dados para gerar os arquivos do aviso de
	 * corte
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirDocumentoCobrancaImpressaoFichaCompensasao(
			Integer idCobrancaDocumento, String linhaTxt,
			String conteudoFichaCompensacao,
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma,
			Integer sequencialImpressao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;
		Connection con = null;
		Statement stmt = null;
		con = session.connection();
		try {
			stmt = con.createStatement();

			consulta = "insert into cobranca.cobranca_documento_impr values ("
					+ idCobrancaDocumento + "," + "'" + linhaTxt + "',"
					+ idCobrancaAcaoAtividadeComando + ","
					+ idCobrancaAcaoAtividadeCronograma + ","
					+ sequencialImpressao + "," + Util.obterSQLDataAtual()
					+ "," + "'" + conteudoFichaCompensacao + "')";

			stmt.executeUpdate(consulta);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0968] Emitir Cartas da Campanha de Final de Ano 2009
	 * 
	 * @author Mariana Victor
	 * @date 17/03/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDocumentoCobrancaImpressaoFichaCompensacao(
			Integer idCobrancaAcaoAtividadeComando,
			Integer idCobrancaAcaoAtividadeCronograma)
			throws ErroRepositorioException {

		Collection<CobrancaDocumento> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT cdim.linhaTxt, cdim.conteudoFichaCompensacao "
					+ "FROM CobrancaDocumentoImpressao cdim ";

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeComando cacm "
						+ " WHERE  cacm.id = " + idCobrancaAcaoAtividadeComando;
			} else if (idCobrancaAcaoAtividadeCronograma != null
					&& idCobrancaAcaoAtividadeCronograma.intValue() != (ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				consulta = consulta
						+ " INNER JOIN cdim.cobrancaAcaoAtividadeCronograma caac "
						+ " WHERE  caac.id = "
						+ idCobrancaAcaoAtividadeCronograma;
			}

			consulta = consulta + " order by cdim.sequencialImpressao ";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 22/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarItemServicoContrato(Integer idGrupoCobranca)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT its.itse_cdconstantecalculo as cdConstante, "// 0
					+ "itsc.itsc_id as idItemServicoContrato, "// 1
					+ "itsc.itsc_vlitemservcontr as vlItemServicoContrato, "// 2
					+ "ces.cese_id as idContratoEmpresaServico, "// 3
					+ "cogr.cbgr_dsemail as emailResponsavel "// 4
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.item_servico its on its.itse_id = itsc.itse_id "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cadastro.empresa emp on emp.empr_id = ces.empr_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca ";

			consulta = consulta + " order by its.itse_cdconstantecalculo ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("cdConstante", Hibernate.INTEGER)
					.addScalar("idItemServicoContrato", Hibernate.INTEGER)
					.addScalar("vlItemServicoContrato", Hibernate.BIG_DECIMAL)
					.addScalar("idContratoEmpresaServico", Hibernate.INTEGER)
					.addScalar("emailResponsavel", Hibernate.STRING)
					.setInteger("idGrupoCobranca", idGrupoCobranca).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletim(Integer idGrupoCobranca,
			Integer idItemServicoContrato, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and os.orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) and "
					+ "((os.rgat_id is not null and amen_icexecucao = 1) or (os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and os.orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) and "
					+ "((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimento(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) and "
					+ "((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimComIndicadorPavimentoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Short indicadorPavimento, Integer referencia)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia  and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_icpavimento = :indicadorPavimento and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) and "
					+ "((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setShort("indicadorPavimento", indicadorPavimento)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfalto(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepAsfaltoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepasfalto as numeroRepAsfalto "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepasfalto is not null and osBo.orbo_nnrepasfalto <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepAsfalto", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalalo(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepParalelo", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepParalaloRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepparalelo as numeroRepParalelo "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepparalelo is not null and osBo.orbo_nnrepparalelo <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepParalelo", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 31/10/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcada(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepCalcada", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz, Mariana Victor
	 * @throws ControladorException
	 * @data 23/03/2011, 01/11/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimRepCalcadaRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade, "// 1
					+ "osBo.orbo_nnrepcalcada as numeroRepCalcada "// 2
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_boletim osBo on osBo.orse_id = os.orse_id "
					+ "INNER JOIN atendimentopublico.ordem_servico_unidade osu on osu.orse_id = os.orse_id and attp_id =:idAtRelaTipo "
					+ "INNER JOIN cadastro.unidade_organizacional unidOrg on unidOrg.unid_id = osu.unid_id "
					+ "LEFT JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "LEFT JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "LEFT JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "LEFT JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "LEFT JOIN atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = atmen.amen_id and amea.cbac_id = cac.cbac_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and osBo.orbo_nnrepcalcada is not null and osBo.orbo_nnrepcalcada <> 0 "
					+ "and unidOrg.empr_id = ces.empr_id and im.rota_idalternativa is not null and (os.cbdo_id is null or dc.cbdo_id = os.cbdo_id) "
					+ "and ((os.rgat_id is not null and amen_icexecucao = 1) or(os.cbdo_id is not null and amea.amea_icgerapagamento = 1)) ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("numeroRepCalcada", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("idAtRelaTipo", AtendimentoRelacaoTipo.ENCERRAR)
					.setInteger("referencia", referencia).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDesconto(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is null "
					+ "AND caac.cbcr_id not in (select cbcr_id from cobranca.bol_med_ac_pen_just)";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.imovel im on im.rota_idalternativa = rota.rota_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 and os.cbdo_id = dc.cbdo_id "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id = :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazo(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is null "
					+ "AND caac.cbcr_id not in (select cbcr_id from cobranca.bol_med_ac_pen_just)";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection pesquisarOSEncerradasPorBoletimPorDescontoSemDecursoPrazoRotaAlternativa(
			Integer idGrupoCobranca, Integer idItemServicoContrato,
			Integer referencia) throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta = null;

		try {
			consulta = "SELECT os.orse_id as idOS, "// 0
					+ "im.loca_id as idLocalidade "// 1
					+ "FROM micromedicao.item_servico_contrato itsc "
					+ "INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = itsc.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo cogr on cogr.cese_id = ces.cese_id "
					+ "INNER JOIN cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cobranca.cobranca_acao_cronograma cac on cac.cbcm_id = cgcm.cbcm_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.cbcr_id = cac.cbcr_id "
					+ "INNER JOIN cobranca.cobranca_documento dc on dc.caac_id = caac.caac_id "
					+ "INNER JOIN micromedicao.rota rota on rota.cbgr_id = cogr.cbgr_id "
					+ "INNER JOIN cadastro.quadra qd on qd.rota_id = rota.rota_id "
					+ "INNER JOIN cadastro.imovel im on im.qdra_id = qd.qdra_id "
					+ "INNER JOIN atendimentopublico.ordem_servico os on os.imov_id = im.imov_id and os.svtp_id = itsc.svtp_id and orse_icboletim = 2 "
					+ "INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 2 "
					+ "INNER JOIN cobranca.cob_ac_os_nao_aceitas caosnaceitas on os.orse_id = caosnaceitas.orse_id and caon_icaceita = 2 and caon_icdescontado = 2 and os.cbdo_id = dc.cbdo_id "
					+ "WHERE cogr.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and itsc.itsc_id = :idItemServicoContrato and "
					+ "os.orse_cdsituacao = :cdSituacao and atmen.amen_id <> :atenMotivoEnce and im.rota_idalternativa is not null";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setInteger("idItemServicoContrato", idItemServicoContrato)
					.setInteger("referencia", referencia)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger(
							"atenMotivoEnce",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<Object[]> pesquisarSituacaoAtualContaPeloCronogramaCobranca(
			Integer idGrupoCobranca, Integer referencia)
			throws ErroRepositorioException {

		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<Object[]> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ "cd.imov_id as idImovel, "// 0
					+ "cd.loca_id as idLocalidade, "// 1
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.dcst_idatual "
					+ " else "
					+ "   cthist.dcst_idatual"
					+ " end as situacaoAtualConta," // 2
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento, " // 3
					+ " ces.cese_pctaxasucesso as percentualTaxaSucesso, "// 4
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_amreferenciaconta "
					+ " else "
					+ "   cthist.cnhi_amreferenciaconta"
					+ " end as referenciaConta, " // 5
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   ct.cnta_vlagua + ct.cnta_vlesgoto + ct.cnta_vldebitos - ct.cnta_vlcreditos - ct.cnta_vlimpostos "
					+ " else "
					+ "   cthist.cnhi_vlagua + cthist.cnhi_vlesgoto + cthist.cnhi_vldebitos - cthist.cnhi_vlcreditos - cthist.cnhi_vlimpostos "
					+ " end as valorConta " // 6
					+ " from cobranca.cobranca_documento_item cdi "
					+ " INNER JOIN cobranca.cobranca_documento cd on cdi.cbdo_id = cd.cbdo_id "
					+ " INNER JOIN cobranca.cobranca_acao_ativ_crg caac on caac.caac_id = cd.caac_id "
					+ " INNER join cobranca.cobranca_acao_cronograma cac on cac.cbcr_id = caac.cbcr_id "
					+ " INNER join cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbcm_id = cac.cbcm_id "
					+ " INNER join cobranca.cobranca_grupo cg on cg.cbgr_id = cgcm.cbgr_id "
					+ " INNER JOIN micromedicao.contrato_empresa_servico ces on ces.cese_id = cg.cese_id "
					+ " INNER join atendimentopublico.ordem_servico os on os.cbdo_id = cd.cbdo_id  "
					+ " INNER JOIN atendimentopublico.atend_motivo_encmt atmen on os.amen_id = atmen.amen_id and amen_icexecucao = 1 "
					+ " LEFT JOIN faturamento.conta ct on ct.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.cnta_id = cdi.cnta_id "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id "
					+ " where cg.cbgr_id = :idGrupoCobranca and cgcm.cbcm_amreferencia = :referencia and cac.cbac_id = :idCobrancaAcao and "
					+ " os.orse_cdsituacao = :cdSituacao "
					+ " order by cd.imov_id";

			// executa o hql
			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.addScalar("situacaoAtualConta", Hibernate.INTEGER)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.addScalar("percentualTaxaSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("referenciaConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idGrupoCobranca", idGrupoCobranca)
					.setShort("cdSituacao", OrdemServico.SITUACAO_ENCERRADO)
					.setInteger("referencia", referencia)
					.setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA)
					.list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorBoletimOS(Collection idsOS)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em d?bito autom?tico a Data Exclus?o com a data corrente
			atualizaDataExclusao = "update gcom.atendimentopublico.ordemservico.OrdemServico "
					+ "set orse_icboletim = 1,orse_tmultimaalteracao = :ultimaAlteracao where orse_id in(:idsOS)";

			session.createQuery(atualizaDataExclusao)
					.setParameterList("idsOS", idsOS)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public void atualizaIndicadorCobrancaAcaoOSNaoAceitas(
			Collection idsOSNaoAceitas) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em d?bito autom?tico a Data Exclus?o com a data corrente
			atualizaDataExclusao = "update gcom.cobranca.CobrancaAcaoOrdemServicoNaoAceitas "
					+ "set caon_icdescontado = 1,caon_tmultimaltarecao = :ultimaAlteracao where orse_id in (:idsOSNaoAceitas) and "
					+ " caac_id = :idCobrancaAcao ";

			session.createQuery(atualizaDataExclusao)
					.setParameterList("idsOSNaoAceitas", idsOSNaoAceitas)
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idCobrancaAcao", CobrancaAcao.VISITA_COBRANCA)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1153] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Cobran?a
	 * 
	 * [FS0002] ? A??es n?o encerradas no cronograma.
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Integer pesquisarAcoesEncerradasCronograma(Integer anoMesReferencia,
			Integer idCobrancaGrupo) throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(*) AS contador "
					+ " FROM cobranca.cobranca_acao_ativ_crg caac "
					+ "   INNER JOIN cobranca.cobranca_acao_cronograma cbcr ON cbcr.cbcr_id = caac.cbcr_id "
					+ "   INNER JOIN cobranca.cobranca_grupo_crg_mes cbcm ON cbcm.cbcm_id = cbcr.cbcm_id "
					+ " WHERE cbcm.cbcm_amreferencia = :anoMesReferencia "
					+ "   AND cbcm.cbgr_id = :idCobrancaGrupo "
					+ "   AND caac.caac_tmrealizacao IS NULL ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * Pesquisa os Itens de Servi?o relacionados ao boletim de medi??o de
	 * cobran?a selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimDesconto(
			Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_desc cbds ON cbds.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbds.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo "
					+ "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbds.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbds.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * Pesquisa os Itens de Servi?o relacionados ao boletim de medi??o de
	 * cobran?a selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimExecutados(
			Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  itse.itse_id AS idItemServico, " // 1
					+ "  itse.itse_dsitemservico AS descricao, " // 2
					+ "  itse.itse_cdconstantecalculo AS constante, " // 3
					+ "  cobm_dtgeracao AS dataGeracao, " // 4
					+ "  itse_cditem AS codigoItem, " // 5
					+ "  loca.loca_nmlocalidade AS localidade, " // 6
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 7
					+ "  loca.loca_id AS idLoca, " // 8
					+ "  greg.greg_id AS idGerencia, " // 9
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 10
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbex.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo "
					+ "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbex.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbex.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg.uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, itse.itse_id, itse.itse_dsitemservico, itse.itse_cdconstantecalculo, "
					+ " cobm.cobm_dtgeracao, itse.itse_cditem ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.addScalar("constante", Hibernate.STRING)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("codigoItem", Hibernate.LONG)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * Pesquisa os Itens de Servi?o relacionados ao boletim de medi??o de
	 * cobran?a selecionado
	 * 
	 * @author Mariana Victor
	 * @created 21/03/2011
	 **/
	public Collection<Object[]> pesquisarItensServicoCobrancaBoletimSucesso(
			Integer anoMesReferencia, Integer idCobrancaGrupo,
			Integer idGerenciaRegional, Integer idUnidadeNegocio,
			Integer idLocalidadeInicial, Integer idLocalidadeFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT cobm.cobm_id AS idCobBoletimMed, " // 0
					+ "  cobm_dtgeracao AS dataGeracao, " // 1
					+ "  loca.loca_nmlocalidade AS localidade, " // 2
					+ "  greg.greg_nmregional AS gerenciaRegional, " // 3
					+ "  loca.loca_id AS idLoca, " // 4
					+ "  greg.greg_id AS idGerencia, " // 5
					+ "  uneg.uneg_nmunidadenegocio AS unidadeNegocio " // 6
					+ " FROM micromedicao.item_servico itse "
					+ "   INNER JOIN micromedicao.item_servico_contrato itsc ON itse.itse_id = itsc.itse_id "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cese_id = itsc.cese_id "
					+ "   INNER JOIN cobranca.cobr_boletim_sucesso cbsu ON cbsu.cobm_id = cobm.cobm_id "
					+ "   INNER JOIN cadastro.localidade loca ON  loca.loca_id = cbsu.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg ON  loca.greg_id = greg.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg ON uneg.uneg_id = loca.uneg_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo "
					+ "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			if (idGerenciaRegional != null) {

				consulta = consulta + "  AND loca.greg_id = :idGerencia";

			}

			if (idUnidadeNegocio != null) {

				consulta = consulta + "  AND uneg.uneg_id = :idUnidadeNegocio";

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				consulta = consulta + "  AND cbsu.loca_id = :idLocalidade";

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				consulta = consulta
						+ "  AND cbsu.loca_id between :idLocalidadeInical AND :idLocalidadeFinal ";

			}

			consulta = consulta
					+ " GROUP BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			consulta = consulta
					+ " ORDER BY greg.greg_nmregional, greg.greg_id, uneg_nmunidadenegocio, loca.loca_nmlocalidade, loca.loca_id, cobm.cobm_id, cobm.cobm_dtgeracao ";

			Query query = session.createSQLQuery(consulta)
					.addScalar("idCobBoletimMed", Hibernate.INTEGER)
					.addScalar("dataGeracao", Hibernate.DATE)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("idLoca", Hibernate.INTEGER)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("unidadeNegocio", Hibernate.STRING)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo);

			if (idGerenciaRegional != null && idGerenciaRegional > 0) {

				query.setInteger("idGerencia", idGerenciaRegional);

			}

			if (idUnidadeNegocio != null) {

				query.setInteger("idUnidadeNegocio", idUnidadeNegocio);

			}

			if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& (idLocalidadeFinal == null || idLocalidadeFinal <= 0)) {

				query.setInteger("idLocalidade", idLocalidadeInicial);

			} else if (idLocalidadeInicial != null && idLocalidadeInicial > 0
					&& idLocalidadeFinal != null && idLocalidadeFinal > 0) {

				query.setInteger("idLocalidadeInical", idLocalidadeInicial);
				query.setInteger("idLocalidadeFinal", idLocalidadeFinal);
			}
			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * De acordo com o c?digo da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobranca(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, "
					+ " itsc.itsc_vlitemservcontr AS valorItem, cbex.cbex_vlservico AS valorServico "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id ";

			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 2:
			case 6:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 3 ";
				break;

			case 3:
			case 7:
			case 9:
			case 11:
			case 13:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 2 ";
				break;

			case 4:
			case 8:
			case 10:
			case 12:
			case 14:
				consulta = consulta
						+ " INNER JOIN atendimentopublico.ordem_servico_boletim orbo ON orse.orse_id = orbo.orse_id "
						+ " AND orbo.orbo_icpavimento = 1 ";
				break;

			default:
				break;
			}

			consulta = consulta
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON orse.svtp_id = itsc.svtp_id AND cobm.cese_id = itsc.cese_id  "
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta
					+ " GROUP BY itsc.itsc_vlitemservcontr, cbex.cbex_vlservico ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("valorServico", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * De acordo com o c?digo da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 22/03/2011
	 **/
	public Object[] obterSomatorioOSBoletimMedicaoCobranca(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {
			switch (helper.getItemServico().getCodigoConstanteCalculo()) {

			case 15:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepasfalto) AS somatorio, ";
				break;

			case 16:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepparalelo) AS somatorio, ";
				break;

			case 17:
				consulta = consulta
						+ " SELECT sum(orbo.orbo_nnrepcalcada) AS somatorio, ";
				break;

			default:
				break;
			}

			consulta = consulta
					+ " itsc.itsc_vlitemservcontr AS valorItem "
					+ " FROM atendimentopublico.ordem_servico_boletim orbo "
					+ "  INNER JOIN cobranca.cobr_boletim_exec cbex ON cbex.orse_id = orbo.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbex.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON cobm.cese_id = itsc.cese_id "
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbex.cobm_id = :idCobBolMedicao "
					+ "  AND cbex.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * De acordo com o c?digo da constate do item, pesquisa os valores do mesmo.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterQuantidadeOSBoletimMedicaoCobrancaDesconto(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(orse.orse_id) AS contador, "
					+ " itsc.itsc_vlitemservcontr AS valorItem "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN cobranca.cobr_boletim_desc cbde ON cbde.orse_id = orse.orse_id "
					+ "  INNER JOIN cobranca.cobr_boletim_medicao cobm ON cbde.cobm_id = cobm.cobm_id "
					+ "  INNER JOIN micromedicao.item_servico_contrato itsc ON orse.svtp_id = itsc.svtp_id  "
					+ "    AND cobm.cese_id = itsc.cese_id "
					+ " WHERE itsc.itse_id = :idItemServico "
					+ "  AND cbde.cobm_id = :idCobBolMedicao "
					+ "  AND cbde.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY itsc.itsc_vlitemservcontr ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.setInteger("idItemServico",
							helper.getItemServico().getId())
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * Consulta os valores da totaliza??o da taxa de sucesso.
	 * 
	 * @author Mariana Victor
	 * @created 23/03/2011
	 **/
	public Object[] obterTotalizacaoOSBoletimMedicaoCobrancaSucesso(
			RelatorioBoletimMedicaoCobrancaHelper helper)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(cbsu.imov_id) AS contador, cese.cese_pctaxasucesso AS pcTxSucesso, "
					+ "    sum(cbsu.cbsu_vlrecuperado) AS somatorio, sum(cbsu.cbsu_vltxsucesso) AS comatorioCalculado "
					+ " FROM cobranca.cobr_boletim_sucesso cbsu "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm ON cobm.cobm_id = cbsu.cobm_id "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ " WHERE cbsu.cobm_id = :idCobBolMedicao "
					+ "   AND cbsu.loca_id = :idLocalidade ";

			consulta = consulta + " GROUP BY cese.cese_pctaxasucesso ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("contador", Hibernate.INTEGER)
					.addScalar("pcTxSucesso", Hibernate.BIG_DECIMAL)
					.addScalar("somatorio", Hibernate.BIG_DECIMAL)
					.addScalar("comatorioCalculado", Hibernate.BIG_DECIMAL)
					.setInteger("idCobBolMedicao",
							helper.getIdCobrancaBoletimMedicao())
					.setInteger("idLocalidade", helper.getIdLocalidade());

			retorno = (Object[]) query.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1152] Emiss?o Boletim Medi??o Cobran?a
	 * 
	 * Pesquisa dados da empresa e do contrado do boletim de cobran?a
	 * 
	 * @author Mariana Victor
	 * @created 24/03/2011
	 **/
	public Object[] pesquisarDadosBoletimMedicaoCobranca(
			Integer anoMesReferencia, Integer idCobrancaGrupo)
			throws ErroRepositorioException {

		Object[] retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT empr.empr_nmempresa AS nome, cese.cese_dsnumerocontrato AS numero, cobm.cobm_vltotal AS valorTotal "
					+ " FROM cobranca.cobr_boletim_medicao cobm "
					+ "  INNER JOIN micromedicao.contrato_empresa_servico cese ON cobm.cese_id = cese.cese_id "
					+ "  INNER JOIN cadastro.empresa empr ON cese.empr_id = empr.empr_id "
					+ " WHERE cobm.cbgr_id = :idCobrancaGrupo "
					+ "   AND cobm.cobm_amreferencia = :anoMesReferencia ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("nome", Hibernate.STRING)
					.addScalar("numero", Hibernate.STRING)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.setInteger("anoMesReferencia", anoMesReferencia)
					.setInteger("idCobrancaGrupo", idCobrancaGrupo)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Gerar Relat?rio de An?lise de Perdas com Cr?dito
	 * 
	 * [UC1155] Gerar Relat?rio de An?lise de Perdas com Cr?dito
	 * 
	 * 
	 * @author Paulo Diniz
	 * @date 16/03/2011
	 * 
	 * @param mesAno
	 *            para an?lise
	 * @throws ErroRepositorioException
	 */
	public RelatorioAnalisePerdasCreditosBean gerarRelatorioAnalisePerdasCreditos(
			String anoMesReferencia) throws ErroRepositorioException {
		RelatorioAnalisePerdasCreditosBean retorno = new RelatorioAnalisePerdasCreditosBean();
		List<Object[]> retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select  	 "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoAte180, "
					+ " sum( case when (drrs.drrs_qtdiasvencidos > 180 and fdrc.fdrc_id = 1 ) "
					+ " then drfx.drfx_vldocumentos end) as vencidoMais180, "
					+

					"  sum( case when (drrs.drrs_qtdiasvencidos > 0 and drrs.drrs_qtdiasvencidos <= 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoAte360, "
					+ "  sum( case when (drrs.drrs_qtdiasvencidos > 360 and fdrc.fdrc_id != 1) "
					+ " 	 then drfx.drfx_vldocumentos end) as vencidoMais360, "
					+

					" sum( case when (drrs.drrs_qtdiasvencidos <=0 or  drrs.drrs_qtdiasvencidos is null) "
					+ " then drfx.drfx_vldocumentos end) as a_vencer, "
					+ " sum(drfx.drfx_qtdocumentos) as qtd_documentos, "
					+ " sum(drfx.drfx_vldocumentos) as valor_total , "
					+ " fdrc.fdrc_vlfaixainicial as faixaInicial, "
					+ " fdrc.fdrc_vlfaixafinal as faixaFinal "
					+ " from  	financeiro.docs_a_rec_resumo drrs  "
					+ " inner join financeiro.doc_receber_faixa_resumo drfx on drfx.drrs_id = drrs.drrs_id "
					+ " inner join financeiro.faixa_docs_a_receber fdrc on fdrc.fdrc_id = drfx.fdrc_id"
					+ " where 	drrs.drrs_amreferenciarecebimentos = "
					+ anoMesReferencia
					+ " group by fdrc.fdrc_vlfaixainicial, fdrc.fdrc_vlfaixafinal "
					+ " order by fdrc.fdrc_vlfaixainicial";

			query = session.createSQLQuery(consulta);
			query.addScalar("vencidoAte180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais180", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoAte360", Hibernate.BIG_DECIMAL);
			query.addScalar("vencidoMais360", Hibernate.BIG_DECIMAL);
			query.addScalar("a_vencer", Hibernate.BIG_DECIMAL);
			query.addScalar("qtd_documentos", Hibernate.INTEGER);
			query.addScalar("valor_total", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaInicial", Hibernate.BIG_DECIMAL);
			query.addScalar("faixaFinal", Hibernate.BIG_DECIMAL);
			query.setMaxResults(3);
			retornoBanco = (List<Object[]>) query.list();

			if (retornoBanco != null && retornoBanco.size() == 3) {

				if (retornoBanco.get(0)[0] != null) {
					retorno.setPrimeiraFaixaVencidosAteSeisMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(0)[0] + "")));
				} else {
					retorno.setPrimeiraFaixaVencidosAteSeisMeses("");
				}
				if (retornoBanco.get(0)[1] != null) {
					retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(0)[1] + "")));
				} else {
					retorno.setPrimeiraFaixaVencidosSuperiorSeisMeses("");
				}
				if (retornoBanco.get(0)[4] != null) {
					retorno.setPrimeiraFaixaVencer(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(0)[4] + "")));
				} else {
					retorno.setPrimeiraFaixaVencer("");
				}
				if (retornoBanco.get(0)[6] != null) {
					retorno.setPrimeiraFaixaTotal(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(0)[6] + "")));
				} else {
					retorno.setPrimeiraFaixaTotal("");
				}

				if (retornoBanco.get(1)[2] != null) {
					retorno.setSegundaFaixaVencidosAteDoseMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(1)[2] + "")));
				} else {
					retorno.setSegundaFaixaVencidosAteDoseMeses("");
				}
				if (retornoBanco.get(1)[3] != null) {
					retorno.setSegundaFaixaVencidosSuperiorDoseMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(1)[3] + "")));
				} else {
					retorno.setSegundaFaixaVencidosSuperiorDoseMeses("");
				}
				if (retornoBanco.get(1)[4] != null) {
					retorno.setSegundaFaixaVencer(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(1)[4] + "")));
				} else {
					retorno.setSegundaFaixaVencer("");
				}
				if (retornoBanco.get(1)[6] != null) {
					retorno.setSegundaFaixaTotal(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(1)[6] + "")));
				} else {
					retorno.setSegundaFaixaTotal("");
				}

				if (retornoBanco.get(2)[2] != null) {
					retorno.setTerceiraFaixaVencidosAteDoseMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(2)[2] + "")));
				} else {
					retorno.setTerceiraFaixaVencidosAteDoseMeses("");
				}
				if (retornoBanco.get(2)[3] != null) {
					retorno.setTerceiraFaixaVencidosSuperiorDoseMeses(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(2)[3] + "")));
				} else {
					retorno.setTerceiraFaixaVencidosSuperiorDoseMeses("");
				}
				if (retornoBanco.get(2)[4] != null) {
					retorno.setTerceiraFaixaVencer(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(2)[4] + "")));
				} else {
					retorno.setTerceiraFaixaVencer("");
				}
				if (retornoBanco.get(2)[6] != null) {
					retorno.setTerceiraFaixaTotal(Util
							.formatarMoedaReal(new BigDecimal(retornoBanco
									.get(2)[6] + "")));
				} else {
					retorno.setTerceiraFaixaTotal("");
				}
			} else {
				retorno = null;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * Retorna o maior ano mesReferencia da tabela docs_a_rec_resumo
	 * 
	 * [UC1155] Gerar Relat?rio de An?lise de Perdas com Cr?dito
	 * 
	 * 
	 * @author Paulo Diniz
	 * @date 16/03/2011
	 * 
	 * @param mesAno
	 *            para an?lise
	 * @throws ErroRepositorioException
	 * @throws ErroRepositorioException
	 */
	public int maiorAnoMesReferenciaDocumentosAReceberResumo()
			throws ErroRepositorioException {
		int retorno = 0;
		Object retornoBanco = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		SQLQuery query = null;

		try {

			consulta = " select max(drrs.drrs_amreferenciarecebimentos) as max from  	financeiro.docs_a_rec_resumo drrs 	 ";

			query = session.createSQLQuery(consulta);
			query.addScalar("max", Hibernate.INTEGER);
			retornoBanco = (Object) query.uniqueResult();

			if (retornoBanco != null) {
				retorno = Integer.parseInt(retornoBanco + "");
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1151] Gerar Boletim de Medi??o
	 * 
	 * 
	 * @author S?vio Luiz
	 * @throws ControladorException
	 * @data 23/03/2011
	 * 
	 * @throws ControladorException
	 * */
	public Collection<BigDecimal> pesquisarValorContaouContaHistorico(
			Integer idImovel, Integer referencia)
			throws ErroRepositorioException {

		// cria a vari?vel que vai armazenar a cole??o pesquisada
		Collection<BigDecimal> retorno = new ArrayList();

		// cria uma sess?o com o hibernate
		Session session = HibernateUtil.getSession();

		// cria a vari?vel que vai conter o hql
		String consulta;

		try {
			// constroi o hql
			consulta = "select "
					+ " case when ( ct.dcst_idatual is not null ) then "
					+ "   pg.pgmt_vlpagamento "
					+ " else "
					+ "   pghistContaHist.pghi_vlpagamento "
					+ " end as valorPagamento  " // 0
					+ " from cadastro.imovel im "
					+ " LEFT JOIN faturamento.conta ct on ct.imov_id = im.imov_id and ct.cnta_amreferenciaconta = :referencia and ct.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento pg on pg.cnta_id = ct.cnta_id "
					+ " LEFT JOIN faturamento.conta_historico cthist on cthist.imov_id = im.imov_id and cthist.cnhi_amreferenciaconta = :referencia and cthist.dcst_idatual = :retificada "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghistContaHist on pghistContaHist.cnta_id = cthist.cnta_id "
					+ " where im.imov_id = :idImovel ";
			// executa o hql
			retorno = session.createSQLQuery(consulta)
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("retificada", DebitoCreditoSituacao.RETIFICADA)
					.setInteger("referencia", referencia).list();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		// retorna a cole??o do resultado da pesquisa
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoImovelPerfil(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "iper.iper_id as idImovelPerfil, "// 16
					+ "iper.iper_dsimovelperfil as dsImovelPerfil "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_per ceip on ceip.cecc_id = cecc.cecc_id "
					+ "left join cadastro.imovel_perfil iper on ceip.iper_id = iper.iper_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoGerenciaRegional(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "greg.greg_id as idGerenciaRegional, "// 16
					+ "greg.greg_nmregional as nmGerenciaRegional "// 17
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_ger cecg on cecg.cecc_id = cecc.cecc_id "
					+ "left join cadastro.gerencia_regional greg on cecg.greg_id = greg.greg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("nmGerenciaRegional", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0879] Gerar Extens?o de Comando de Contas em Cobran?a por Empresa -
	 * Pesquisa dados do popup
	 * 
	 * @author Mariana Victor
	 * @date 13/04/2011
	 */
	public Collection<Object[]> pesquisarDadosPopupExtensaoComandoUnidadeNegocio(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ "uneg.uneg_id as idUnidadeNegocio, "// 0
					+ "uneg.uneg_nmunidadenegocio as dsUnidadeNegocio "// 1
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "left join cobranca.cmd_empr_cobr_conta_uneg ceun on ceun.cecc_id = cecc.cecc_id "
					+ "left join cadastro.unidade_negocio uneg on ceun.uneg_id = uneg.uneg_id "
					+ "where cecc.cecc_id = :idComando ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)
					.addScalar("dsUnidadeNegocio", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * @author: Mariana Victor
	 * @date: 13/04/2011
	 */
	public Integer pesquisarQuantidadeContasArquivoTextoContasCobrancaEmpresa(
			Collection ids, Integer idImovel) throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = " SELECT COUNT(DISTINCT conta.cnta_id) AS quantidadeContas " // 1
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ " inner join  faturamento.conta conta on (conta.cnta_id = ecco.cnta_id and conta.dcst_idatual in (0 , 1 , 2)) "
					+ " inner join cadastro.imovel imovel  on imovel.imov_id = conta.imov_id and imovel.imov_id = :idImovel "
					+ " where ecco.cecc_id in (:ids) "
					+ " and  not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=conta.cnta_id) ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.setParameterList("ids", ids)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobranca por Empresa
	 * 
	 * Pesquisa a Situa??o de cobran?a a partir do c?digo constante.
	 * 
	 * @author: Mariana Victor
	 * @date: 18/04/2011
	 */
	public Integer pesquisarCobrancaSituacao(Integer codigoConstante)
			throws ErroRepositorioException {

		StatelessSession session = HibernateUtil.getStatelessSession();

		Integer retorno = null;
		String consulta = null;

		try {

			consulta = " SELECT cbst_id AS id "
					+ " FROM cobranca.cobranca_situacao "
					+ " WHERE cbst_cdconstante = :codigoConstante ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("codigoConstante", codigoConstante)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * Pesquisar Debito Cobrado de Parcelamento
	 * 
	 * @author Rog?rio Peixoto
	 * @throws ErroRepositorioException
	 * @date 29/03/2011
	 */
	public boolean pesquisarDebitoCobradoParcelamento(Integer codigoParcelamento)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebito = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade FROM "
					+ "cobranca.parcelamento parc "
					+ "INNER JOIN faturamento.debito_a_cobrar dac ON (parc.parc_id = dac.parc_id)"
					+ "INNER JOIN faturamento.debito_cobrado dec ON (dac.dbac_id = dec.dbac_id)"
					+ "WHERE parc.parc_id = :codigoParcelamento";

			quantidadeDebito = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("codigoParcelamento", codigoParcelamento)
					.setMaxResults(1).uniqueResult();

			if (quantidadeDebito != null && quantidadeDebito > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public Integer pesquisarReferenciaContaPorId(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String consulta;
		Integer referencia = null;

		try {

			consulta = "SELECT cnta_amreferenciaconta as referencia FROM "
					+ "faturamento.conta cnta " + "WHERE cnta_id = "
					+ idConta.intValue();

			referencia = (Integer) session.createSQLQuery(consulta)
					.addScalar("referencia", Hibernate.INTEGER)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return referencia;
	}

	public boolean verificaContaVinculadaAContratoParcelAtivo(Integer idConta)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.cnta_id = :idConta and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	public boolean verificaGuiaVinculadaAContratoParcelAtivo(Integer idGuia)
			throws ErroRepositorioException {
		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeContas = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
					+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.gpag_id = :idGuia and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeContas = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idGuia", idGuia).setMaxResults(1)
					.uniqueResult();

			if (quantidadeContas != null && quantidadeContas > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author R?mulo Aur?lio
	 * @throws ErroRepositorioException
	 * @date 12/05/2011
	 */
	public ContratoParcelamento pesquisarContratoParcelamento(
			String numeroParcelamento) throws ErroRepositorioException {
		ContratoParcelamento retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamento AS contratoParcelamento "
					+ "FROM  ContratoParcelamento contratoParcelamento "
					+ "INNER JOIN FETCH contratoParcelamento.parcelamentoSituacao parcelamentoSituacao "
					+ "LEFT JOIN FETCH contratoParcelamento.contratoAnterior contratoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoAnterior relacaoAnterior "
					+ "LEFT JOIN FETCH contratoParcelamento.usuarioResponsavel usuarioResponsavel "
					+ "LEFT JOIN FETCH contratoParcelamento.relacaoCliente relacaoCliente "
					+ "LEFT JOIN FETCH contratoParcelamento.resolucaoDiretoria resolucaoDiretoria "
					+ "LEFT JOIN FETCH contratoParcelamento.cobrancaForma cobrancaForma "
					+ "LEFT JOIN FETCH contratoParcelamento.motivoDesfazer motivoDesfazer "

					+ "WHERE contratoParcelamento.numero = :numeroParcelamento ";

			retorno = (ContratoParcelamento) session.createQuery(consulta)
					.setString("numeroParcelamento", numeroParcelamento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1140] Cancelar Contrato de Parcelamento por Cliente
	 * 
	 * @author R?mulo Aur?lio, Mariana Victor
	 * @throws ErroRepositorioException
	 * @date 12/05/2011, 18/07/2011
	 */
	public Collection pesquisarDebitoContratoParcelamentoPorTipoDocumento(
			ContratoParcelamento contratoParcelamento, Integer idDocumentoTipo)
			throws ErroRepositorioException {
		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = "SELECT  contratoParcelamentoItem AS contratoParcelamentoItem "
					+ "FROM  ContratoParcelamentoItem contratoParcelamentoItem "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contrato contratoParcelamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.contaGeral contageral "
					+ " LEFT JOIN fetch contratoParcelamentoItem.guiaPagamentoGeral guiaPagamentoGeral "
					+ " LEFT JOIN fetch guiaPagamentoGeral.guiaPagamento guiaPagamento "
					+ " LEFT JOIN fetch contratoParcelamentoItem.debitoACobrarGeral debitoACobrarGeral "
					+ " LEFT JOIN fetch debitoACobrarGeral.debitoACobrar debitoACobrar "
					+ "WHERE contratoParcelamento.numero = :numeroParcelamento "
					+ " and contratoParcelamentoItem.documentoTipo.id = "
					+ idDocumentoTipo
					+ " "
					+ " and contratoParcelamentoItem.valorItem not in (select  coalesce(sum(prestacaoItem.valorPago), 0) "
					+ "  from PrestacaoItemContratoParcelamento prestacaoItem "
					+ "  inner join prestacaoItem.prestacao b "
					+ "  where contratoParcelamento.id = b.contratoParcelamento.id "
					+ "  and contratoParcelamentoItem.id = prestacaoItem.item.id) ";

			retorno = (Collection) session
					.createQuery(consulta)
					.setParameter("numeroParcelamento",
							contratoParcelamento.getNumero()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobran?a por Empresa
	 * 
	 * Pesquisa os dados dos comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Collection pesquisarDadosConsultarComandosContasCobrancaEmpresaResumido(
			Integer idEmpresa, Date cicloInicial, Date cicloFinal,
			int numeroIndice, int quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que j? monta uma cole??o de
		 * ConsultarComandosContasCobrancaEmpresaHelper com tudo que ?
		 * necess?rio **
		 */
		try {
			consulta = "select new gcom.cobranca.cobrancaporresultado.ConsultarComandosContasCobrancaEmpresaHelper("
					+ " comandoEmpresaCobrancaConta.id," // 1
					+ " comandoEmpresaCobrancaConta.empresa.id," // 2
					+ " comandoEmpresaCobrancaConta.empresa.descricao," // 3
					+ " comandoEmpresaCobrancaConta.dataInicioCiclo," // 4
					+ " comandoEmpresaCobrancaConta.dataFimCiclo," // 5
					+ " comandoEmpresaCobrancaConta.dataExecucao," // 6
					+ " comandoEmpresaCobrancaConta.dataEncerramento," // 7
					+ " comandoEmpresaCobrancaConta.imovel.id," // 8
					+ " comandoEmpresaCobrancaConta.cliente.id," // 9
					+ " comandoEmpresaCobrancaConta.cliente.nome," // 10
					+ " comandoEmpresaCobrancaConta.gerenciaRegional.id," // 11
					+ " comandoEmpresaCobrancaConta.gerenciaRegional.nome," // 12
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.id," // 13
					+ " comandoEmpresaCobrancaConta.unidadeNegocio.nome," // 14
					+ " comandoEmpresaCobrancaConta.localidadeInicial.id," // 15
					+ " comandoEmpresaCobrancaConta.localidadeInicial.descricao," // 16
					+ " comandoEmpresaCobrancaConta.localidadeFinal.id," // 17
					+ " comandoEmpresaCobrancaConta.localidadeFinal.descricao," // 18
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialInicial," // 19
					+ " comandoEmpresaCobrancaConta.codigoSetorComercialFinal," // 20
					+ " comandoEmpresaCobrancaConta.numeroQuadraInicial," // 21
					+ " comandoEmpresaCobrancaConta.numeroQuadraFinal," // 22
					+ "	comandoEmpresaCobrancaConta.referenciaContaInicial," // 23
					+ "	comandoEmpresaCobrancaConta.referenciaContaFinal," // 24
					+ " comandoEmpresaCobrancaConta.dataVencimentoContaInicial," // 25
					+ "	comandoEmpresaCobrancaConta.dataVencimentoContaFinal," // 26
					+ "	comandoEmpresaCobrancaConta.valorMinimoConta," // 27
					+ " comandoEmpresaCobrancaConta.valorMaximoConta) " // 28
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "left join comandoEmpresaCobrancaConta.cliente cliente "
					+ "left join comandoEmpresaCobrancaConta.localidadeInicial localidadeInicial "
					+ "left join comandoEmpresaCobrancaConta.localidadeFinal localidadeFinal "
					+ "left join comandoEmpresaCobrancaConta.unidadeNegocio unidadeNegocio "
					+ "left join comandoEmpresaCobrancaConta.gerenciaRegional gerenciaRegional "
					+ "inner join comandoEmpresaCobrancaConta.empresa empresa "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + "ORDER BY comandoEmpresaCobrancaConta.id ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(numeroIndice * quantidadeRegistros).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1167] Consultar Comandos de Cobran?a por Empresa
	 * 
	 * Pesquisa os dados de um comando para exibir no popup
	 * 
	 * @author: Mariana Victor, Raimundo Martins
	 * @date: 04/05/2011, 13/10/2011
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosPopupExtensaoComandoCobranca(
			Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;
		String consulta2;
		String debitoOuConta;
		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();
		try {
			consulta = "select "
					+ "empre.empr_nmempresa as empresa, "// 0
					+ "cecc.cecc_dtiniciociclo as dataInicioCiclo, "// 1
					+ "cecc.cecc_dtfimciclo as dataFimCiclo, "// 2
					+ "cecc.cecc_dtexecucao as dataExecucao, "// 3
					+ "cecc.cecc_dtencerramento as dataEncerramento, "// 4
					+ "imov_id as imovel, "// 5
					+ "cli.clie_id as idCliente, "// 6
					+ "cli.clie_nmcliente as cliente, "// 7
					+ "cecc.cecc_icresidencial as icResidencial, "// 8
					+ "cecc.cecc_iccomercial as icComercial, "// 9
					+ "cecc.cecc_icindustrial as icIndustrial, "// 10
					+ "cecc.cecc_icpublico as icPublico, "// 11
					+ "iper.iper_id as idImovelPerfil, "// 12
					+ "iper.iper_dsimovelperfil as dsImovelPerfil, "// 13
					+ "greg.greg_id as idGerenciaRegional, "// 14
					+ "greg.greg_nmregional as dsGerenciaRegional, "// 15
					+ "uneg.uneg_id as idUneg, "// 16
					+ "uneg.uneg_nmunidadenegocio as nomeUneg, "// 17
					+ "loca_idinicial as locaIncial, "// 18
					+ "loca_idfinal as locaFinal, "// 19
					+ "cecc_cdsetorcomercialinicial as setorInicial, "// 20
					+ "cecc_cdsetorcomercialfinal as setorFinal, "// 21
					+ "cecc_nnquadrainicial as idQuadraInicial, "// 22
					+ "cecc_nnquadrafinal as idQuadraFinal, "// 23
					+ "cecc.cecc_amreferenciacontainicial as anoMesContaInicial, "// 24
					+ "cecc.cecc_amreferenciacontafinal as anoMesContaFinal, "// 25
					+ "cecc.cecc_dtvencimentocontainicial as vencimentoIncial, "// 26
					+ "cecc.cecc_dtvencimentocontafinal as vencimentoFinal, ";// 27

			consulta2 = "emco.emco_id as idEmpContrCob, "// 30
					+ "emco.emco_pcpagamentodevido as pcPagDevido, "// 31
					+ "cecc.cecc_icgeracaotxt as indicadorGeracaoTxt, "// 32
					+ "cecc.cecc_qtdcontasinicial as qtdContasInicial, "// 33
					+ "cecc.cecc_qtdcontasfinal as qtdContasFinal, "// 34
					+ "cecc.cecc_qtddiasvencimento as qtdDiasVencimento, "// 35
					+ "las.last_dsligacaoaguasituacao as situacaoAgua, "// 36
					+ "cecc.cecc_qtdimoveiscomando as qtdMaxImoveis "// 37
					+ "from cobranca.cmd_empr_cobr_conta cecc "
					+ "inner join cadastro.empresa empre on cecc.empr_id = empre.empr_id "
					+ "left join cadastro.empr_contrato_cobranca emco on emco.empr_id = empre.empr_id "
					+ "left join cadastro.cliente cli on cli.clie_id = cecc.clie_id "
					+ "left join cadastro.unidade_negocio uneg on uneg.uneg_id = cecc.uneg_id "
					+ "left join cadastro.imovel_perfil iper on iper.iper_id = cecc.iper_id "
					+ "left join cadastro.gerencia_regional greg on cecc.greg_id = greg.greg_id "
					+ "left join atendimentopublico.ligacao_agua_situacao las on cecc.last_id = las.last_id "
					+ "where cecc.cecc_id = :idComando ";

			if (sistemaParametro.getIndicadorTotalDebito() == 1) {
				debitoOuConta = "cecc_vldebitoinicial as vlMinino, "// 28
						+ "cecc_vldebitofinal as vlMaximo, ";// 29;
			} else {
				debitoOuConta = "cecc_vlminimoconta as vlMinino, "// 28
						+ "cecc_vlmaximoconta as vlMaximo, ";// 29;
			}
			retorno = session
					.createSQLQuery(consulta + debitoOuConta + consulta2)
					.addScalar("empresa", Hibernate.STRING)
					.addScalar("dataInicioCiclo", Hibernate.DATE)
					.addScalar("dataFimCiclo", Hibernate.DATE)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("cliente", Hibernate.STRING)
					.addScalar("icResidencial", Hibernate.SHORT)
					.addScalar("icComercial", Hibernate.SHORT)
					.addScalar("icIndustrial", Hibernate.SHORT)
					.addScalar("icPublico", Hibernate.SHORT)
					.addScalar("idImovelPerfil", Hibernate.INTEGER)
					.addScalar("dsImovelPerfil", Hibernate.STRING)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					.addScalar("dsGerenciaRegional", Hibernate.STRING)
					.addScalar("idUneg", Hibernate.INTEGER)
					.addScalar("nomeUneg", Hibernate.STRING)
					.addScalar("locaIncial", Hibernate.INTEGER)
					.addScalar("locaFinal", Hibernate.INTEGER)
					.addScalar("setorInicial", Hibernate.INTEGER)
					.addScalar("setorFinal", Hibernate.INTEGER)
					.addScalar("idQuadraInicial", Hibernate.INTEGER)
					.addScalar("idQuadraFinal", Hibernate.INTEGER)
					.addScalar("anoMesContaInicial", Hibernate.INTEGER)
					.addScalar("anoMesContaFinal", Hibernate.INTEGER)
					.addScalar("vencimentoIncial", Hibernate.DATE)
					.addScalar("vencimentoFinal", Hibernate.DATE)
					.addScalar("vlMinino", Hibernate.BIG_DECIMAL)
					.addScalar("vlMaximo", Hibernate.BIG_DECIMAL)
					.addScalar("idEmpContrCob", Hibernate.INTEGER)
					.addScalar("pcPagDevido", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorGeracaoTxt", Hibernate.INTEGER)
					.addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER)
					.addScalar("qtdDiasVencimento", Hibernate.INTEGER)
					.addScalar("situacaoAgua", Hibernate.STRING)
					.addScalar("qtdMaxImoveis", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobran?a por Empresa
	 * 
	 * - Pesquisa dados da cobran?a
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresa(
			Integer idComando) throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select "
					+ " ecc.ecco_vloriginalconta as valor"
					+ " from cobranca.empresa_cobranca_conta ecc"
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ecc.cecc_id = cecc.cecc_id"
					+ " inner join faturamento.conta conta on ecc.cnta_id = conta.cnta_id "
					+ " where cecc.cecc_id = :idComando"
					+ " and not exists (select pagamento.cnta_id from arrecadacao.pagamento pagamento where pagamento.cnta_id=ecc.cnta_id)"
					+ " and (conta.dcst_idatual in " + "("
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.RETIFICADA + ", "
					+ DebitoCreditoSituacao.INCLUIDA + " )) ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1167] Consultar Comandos de Cobran?a por Empresa
	 * 
	 * Pesquisa a quantidade de contas, agrupando por im?vel
	 * 
	 * @author: Mariana Victor
	 * @date: 06/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection pesquisarValorTotalCobrancaComandoEmpresaPorImovel(
			Integer idComando, Integer idEmpresaCobrancaFaixa)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select count(distinct ecco.imov_id) as qtdImoveis, "
					+ "count( distinct ecco.cnta_id) as qtdContas, "
					+ "coalesce("
					+ "		SUM(coalesce(ecco.ecco_vloriginalconta,0)),0)     AS valorTotalDebitos "
					+ "from COBRANCA.empresa_cobranca_conta ecco "
					+ "left join CADASTRO.empr_cobr_faixa emcf on emcf.emcf_pcfaixa = ecco.ecco_pcempresaconta "
					+ "where ecco.cecc_id = :idComando "
					+ "and ecco.ecco_cdincluido is null "
					+ "and ecco.ecco_icpagamentovalido = :indicadorPgValido "
					+ "and emcf.emcf_id = :idEmpresaCobrancaFaixa";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("qtdContas", Hibernate.INTEGER)
					.addScalar("valorTotalDebitos", Hibernate.BIG_DECIMAL)
					.addScalar("qtdImoveis", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("indicadorPgValido", ConstantesSistema.SIM)
					.setInteger("idEmpresaCobrancaFaixa",
							idEmpresaCobrancaFaixa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC0869] Gerar Arquivo Texto das Contas em Cobran?a por Empresa
	 * 
	 * @author Mariana Victor
	 * @data 09/05/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarIndicadorGeracaoTxt(Collection idsComandos)
			throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ "set cecc_icgeracaotxt = :icGeracao, cecc_tmultimaalteracao = :ultimaAlteracao where cecc_id in (";

			Iterator iterator = idsComandos.iterator();

			while (iterator.hasNext()) {
				consulta += ((Integer) iterator.next()).toString() + ", ";
			}
			// remove a virgula do final e coloca o par?ntese
			consulta = consulta.substring(0, consulta.length() - 2) + ")";

			session.createQuery(consulta)
					.setInteger("icGeracao", ConstantesSistema.SIM)
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1168] Encerrar Comandos de Cobran?a por Empresa
	 * 
	 * Pesquisa os ids dos im?veis e das ordens de servi?os geradas para um
	 * determinado comando
	 * 
	 * @author Mariana Victor
	 * @created 09/05/2011
	 * @throws ErroRepositorioException
	 * 
	 */
	public Collection<Object[]> pesquisarImovelOrdemServicoParaEncerrarComando(
			int quantidadeInicio, Integer idComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT emprCobConta.imov_id AS idImovel, "
					+ "  emprCobConta.orse_id AS idOS "
					+ " FROM cobranca.empresa_cobranca_conta emprCobConta "
					+ " WHERE emprCobConta.cecc_id = :idComando "
					+ " group by emprCobConta.imov_id, emprCobConta.orse_id "
					+ " order by emprCobConta.imov_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idOS", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setFirstResult(quantidadeInicio).setMaxResults(1000)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC1168] Encerrar Comandos de Cobran?a por Empresa
	 * 
	 * @author Mariana Victor
	 * @data 09/05/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarDataEncerramentoUsuarioComando(Integer idComando,
			Usuario usuario) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.ComandoEmpresaCobrancaConta "
					+ " set cecc_dtencerramento = :dataEncerramento, cecc_tmultimaalteracao = :ultimaAlteracao, "
					+ "   usur_id = :idUsuario "
					+ " where cecc_id = :idComando ";

			session.createQuery(consulta)
					.setTimestamp("dataEncerramento", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.setInteger("idComando", idComando)
					.setInteger("idUsuario", usuario.getId()).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * [UC1169] Movimentar Ordens de Servi?o de Cobran?a por Resultado
	 * 
	 * Gerar OS
	 * 
	 * @author Mariana Victor
	 * @data 17/05/2011
	 */
	public Collection<Integer> pesquisarIdsImoveis(
			MovimentarOrdemServicoGerarOSHelper helper)
			throws ErroRepositorioException {

		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select imov.imov_id as idImovel "
					+ " from cadastro.imovel imov "
					+ "   inner join cobranca.empresa_cobranca_conta ecco on ecco.imov_id = imov.imov_id "
					+ "   inner join cobranca.cmd_empr_cobr_conta cecc on ecco.cecc_id = cecc.cecc_id "
					+ "   inner join cadastro.imovel_subcategoria imsb on imsb.imov_id = imov.imov_id "
					+ "   inner join cadastro.subcategoria scat on scat.scat_id = imsb.scat_id "
					+ " where cecc.cecc_id = :idComando ";

			if (helper.getIdsCategoria() != null
					&& helper.getIdsCategoria().length != 0) {
				consulta += "   and scat.catg_id in (";

				for (int i = 0; i < helper.getIdsCategoria().length; i++) {
					consulta += helper.getIdsCategoria()[i] + ", ";
				}
				// remove a virgula do final e coloca o par?ntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsImovelPerfil() != null
					&& helper.getIdsImovelPerfil().length != 0) {
				consulta += "   and imov.iper_id in (";

				for (int i = 0; i < helper.getIdsImovelPerfil().length; i++) {
					consulta += helper.getIdsImovelPerfil()[i] + ", ";
				}
				// remove a virgula do final e coloca o par?ntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getIdsLigacaoAguaSituacao() != null
					&& helper.getIdsLigacaoAguaSituacao().length != 0) {
				consulta += "   and imov.last_id in (";

				for (int i = 0; i < helper.getIdsLigacaoAguaSituacao().length; i++) {
					consulta += helper.getIdsLigacaoAguaSituacao()[i] + ", ";
				}
				// remove a virgula do final e coloca o par?ntese
				consulta = consulta.substring(0, consulta.length() - 2) + ")";
			}

			if (helper.getValorMinimo() != null
					&& helper.getValorMaximo() != null) {

				consulta = consulta
						+ " and ( (select sum(ecc.ecco_vloriginalconta)  "
						+ " from cobranca.empresa_cobranca_conta ecc "
						+ " where ecc.ecco_id = ecco.ecco_id) between :valorInicial and :valorFinal) ";
			}

			consulta = consulta + " group by imov.imov_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", helper.getIdComandoContaCobranca());

			if (helper.getValorMinimo() != null
					&& helper.getValorMaximo() != null) {
				retorno = query
						.setBigDecimal("valorInicial", helper.getValorMinimo())
						.setBigDecimal("valorFinal", helper.getValorMaximo())
						.list();
			} else {
				retorno = query.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Servi?o de Cobran?a por Resultado
	 * 
	 * Emitir OS Gerada pela Empresa
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSGeradasPelaEmpresa(
			Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select orse.orse_id as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.ordem_servico_unidade osun on unid.unid_id = osun.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on osun.orse_id = orse.orse_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and osun.attp_id = 1 "
					+ "   and clim.crtp_id = 2 "
					+ "   and clim.clim_dtrelacaofim is null "
					+ "   and orse.orse_cdsituacao = 1 "
					+ "   and orse.orse_id not in (select eccc.orse_id from cobranca.empresa_cobranca_conta eccc where cecc.cecc_id = eccc.cecc_id) ";

			if (idTipoServico != null
					&& idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta
					+ " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Servi?o de Cobran?a por Resultado
	 * 
	 * Emitir OS de Registro de Atendimento
	 * 
	 * @author Mariana Victor
	 * @data 18/05/2011
	 */
	public Collection<Object[]> pesquisarDadosOSRegistroAtendimento(
			Integer idComando, Integer idTipoServico)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " select distinct(orse.orse_id) as idOS, svtp.svtp_dsservicotipo as servicoTipo, orse.imov_id as idImovel, clie.clie_nmcliente as nomeCliente "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ "   inner join cadastro.unidade_organizacional unid on unid.empr_id = cecc.empr_id "
					+ "   inner join atendimentopublico.tramite tram on tram.unid_iddestino = unid.unid_id "
					+ "   inner join atendimentopublico.ordem_servico orse on tram.rgat_id = orse.rgat_id "
					+ "   inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "   inner join cadastro.cliente_imovel clim on clim.imov_id = orse.imov_id "
					+ "   inner join cadastro.cliente clie on clie.clie_id = clim.clie_id "
					+ " where cecc.cecc_id = :idComando "
					+ "   and clim.crtp_id = 2 "
					+ "   and clim.clim_dtrelacaofim is null "
					+ "   and orse.orse_cdsituacao = 1 ";

			if (idTipoServico != null
					&& idTipoServico.compareTo(new Integer(-1)) != 0) {
				consulta += "   and orse.svtp_id = " + idTipoServico;
			}

			consulta = consulta
					+ " group by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente "
					+ " order by orse.orse_id, svtp.svtp_dsservicotipo, orse.imov_id, clie.clie_nmcliente ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("servicoTipo", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * obtem contas em d?bito do im?vel, comparando a data de vencimento
	 * original usado no emitir contas da CAEMA
	 * 
	 * Author: Vivianne Sousa Data: 15/06/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarContasImovelDataVencimentoOriginal(
			Integer idImovel, int indicadorPagamento, int indicadorConta,
			String contaSituacaoNormal, String contaSituacaoRetificada,
			String contaSituacaoIncluida, String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito, int indicadorDividaAtiva)
			throws ErroRepositorioException {

		Collection retorno = new ArrayList();

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "SELECT conta.cnta_id as idConta "
					+ "FROM faturamento.conta conta "
					+ "LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ "WHERE conta.imov_id = :idImovel "
					+ "and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida) "
					+ "and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ "and conta.cnta_dtvencimentooriginal between :inicialVencimento and :finalVencimento "
					+ "and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorConta == 2) {
				consulta += "and conta.cnta_dtrevisao is null ";
			}

			if (indicadorDividaAtiva == 1) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is not null ";
			} else if (indicadorDividaAtiva == 2) {
				consulta += "and conta.cnta_amreferenciabaixacontabil is null ";
			}

			if (indicadorPagamento == 1) {
				consulta += " HAVING sum(coalesce(pagto.pgmt_vlpagamento, 0.00)) < ((coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)))";
			}

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal",
							new Integer(contaSituacaoNormal))
					.setInteger("situacaoRetificada",
							new Integer(contaSituacaoRetificada))
					.setInteger("situacaoIncluida",
							new Integer(contaSituacaoIncluida))
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobran?a
	 * 
	 * Consulta chamada pelo "[FS0006 ? Validar Comando]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public ComandoEmpresaCobrancaConta pesquisarComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {

		ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = null;
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT empr_id AS idEmpresa, " // 0
					+ "    cecc_dtencerramento AS dataEncerramento, " // 1
					+ "    cecc_icgeracaotxt AS icGeracaoArqTxt " // 2
					+ "  FROM cobranca.cmd_empr_cobr_conta "
					+ "  WHERE cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.addScalar("icGeracaoArqTxt", Hibernate.INTEGER)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null) {
			comandoEmpresaCobrancaConta = new ComandoEmpresaCobrancaConta();

			comandoEmpresaCobrancaConta.setId(idComando);

			if (retorno[0] != null) {
				Empresa empresa = new Empresa();
				empresa.setId((Integer) retorno[0]);

				comandoEmpresaCobrancaConta.setEmpresa(empresa);
			}

			if (retorno[1] != null) {
				comandoEmpresaCobrancaConta
						.setDataEncerramento((Date) retorno[1]);
			}

			if (retorno[2] != null) {
				comandoEmpresaCobrancaConta
						.setIndicadorGeracaoTxt((Integer) retorno[2]);
			}

		}

		return comandoEmpresaCobrancaConta;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobran?a
	 * 
	 * Consulta chamada pelo "[FS0007 ? Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Short pesquisarSituacaoOrdemServico(Integer numeroOS)
			throws ErroRepositorioException {

		Short retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT orse_cdsituacao AS situacao " // 0
					+ "  FROM atendimentopublico.ordem_servico "
					+ "  WHERE orse_id = :numeroOS ";

			retorno = (Short) session.createSQLQuery(consulta)
					.addScalar("situacao", Hibernate.SHORT)
					.setInteger("numeroOS", numeroOS).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1182] Recepcionar Arquivo TXT Encerramento OS Cobran?a
	 * 
	 * Consulta chamada pelo "[FS0007 ? Validar OS]"
	 * 
	 * @author Mariana Victor
	 * @data 20/06/2011
	 */
	public Boolean verificarOrdemServicoComando(Integer numeroOS,
			Integer idComando) throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT count(*) AS quantidade " // 0
					+ "  FROM cobranca.empresa_cobranca_conta "
					+ "  WHERE cecc_id = :idComando "
					+ "    AND orse_id = :numeroOS ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("numeroOS", numeroOS).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (retorno != null && retorno.compareTo(new Integer(0)) > 0) {
			return true;
		}

		return false;

	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Paulo Diniz
	 * @throws ErroRepositorioException
	 * @data 30/06/2011
	 */
	public List<Object[]> pesquisarOrdensServicoContasPagasParceladas()
			throws ErroRepositorioException {
		List<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select orse.orse_id as orse_id, cecc.cecc_id as cecc_id  "
					+ "from COBRANCA.cmd_empr_cobr_conta cecc "
					+ "inner join COBRANCA.empresa_cobranca_conta ecco on ecco.cecc_id = cecc.cecc_id  "
					+ "inner join ATENDIMENTOPUBLICO.ordem_servico orse on ecco.orse_id = orse.orse_id "
					+ "inner join CADASTRO.imovel imov on orse.imov_id = imov.imov_id "
					+ "inner join FATURAMENTO.conta cnta on cnta.cnta_id = ecco.cnta_id "
					+ "where cecc.cecc_dtexecucao is not null and cecc.cecc_dtencerramento is null and cecc.cecc_icgeracaotxt = 1  and ( "
					+ "exists (select pgmt.cnta_id from arrecadacao.pagamento pgmt  "
					+ "where pgmt.cnta_id=ecco.cnta_id)"
					+ " or exists (select pghi.cnta_id from arrecadacao.pagamento_historico pghi"
					+ " where pghi.cnta_id=ecco.cnta_id) "
					+ " or cnta.dcst_idatual = 5"
					+ " or exists (select cnhi.cnta_id from FATURAMENTO.conta_historico cnhi "
					+ "where cnhi.cnta_id=ecco.cnta_id and cnhi.dcst_idatual = 5 )"
					+ ") group by orse.orse_id,  cecc.cecc_id ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("orse_id", Hibernate.INTEGER)
					.addScalar("cecc_id", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relat?rio Ordem de Servi?o Cobran?a p/Resultado
	 * 
	 * Pesquisar EmpresaCobrancaConta a partir do im?vel
	 * 
	 * @author Hugo Azevedo
	 * @data 02/07/2011
	 */

	public Collection obterColecaoEmpresaCobrancaContaResultadoporImovel(
			Integer id, Integer tipoServico, String comando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {

			consulta = "select distinct emprc.ordemServico "
					+ "from EmpresaCobrancaConta emprc, OrdemServico ordemServico "
					+ "inner join fetch emprc.comandoEmpresaCobrancaConta cecc "
					+ "inner join fetch emprc.imovel imovel "
					+ "inner join fetch ordemServico.servicoTipo "
					+ "left join fetch ordemServico.atendimentoMotivoEncerramento "
					+ "where emprc.ordemServico.id = ordemServico.id and imovel.id = :imovelId ";
			if (tipoServico != null && tipoServico.intValue() != -1) {
				consulta += "and emprc.ordemServico.servicoTipo.id = "
						+ tipoServico;
			}
			consulta += "and ((ordemServico.dataGeracao >= cecc.dataExecucao "
					+ "and cecc.dataExecucao is not null "
					+ "and cecc.dataEncerramento is null )" + "OR "
					+ "(ordemServico.dataGeracao >= cecc.dataExecucao "
					+ "and ordemServico.dataGeracao <= cecc.dataEncerramento "
					+ "and cecc.dataExecucao is not null "
					+ "and cecc.dataEncerramento is not null))"
					+ "and cecc.id = :idComando ";

			retorno = session.createQuery(consulta).setInteger("imovelId", id)
					.setInteger("idComando", new Integer(comando)).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 * */
	public Collection<Object[]> pesquisarEmpresasComandosCobrancaAtivosExecutados()
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct cecc.empr_id AS idEmpresa, empr.empr_dsemail AS emailEmpresa, emco.emco_dtiniciocontrato AS dataInicioContrato "
					+ "  FROM cobranca.cmd_empr_cobr_conta cecc "
					+ "  INNER JOIN cadastro.empresa empr ON empr.empr_id = cecc.empr_id "
					+ "  INNER JOIN cadastro.empr_contrato_cobranca emco ON emco.empr_id = empr.empr_id"
					+ "  WHERE cecc.cecc_dtexecucao is not null " //AND cecc.cecc_dtencerramento is null "
					+ "  AND cecc.cecc_icgeracaotxt = 1 "
					+ "  GROUP BY cecc.empr_id , empr.empr_dsemail, emco.emco_dtiniciocontrato "
					+ "  ORDER BY emco.emco_dtiniciocontrato DESC, cecc.empr_id DESC ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("emailEmpresa", Hibernate.STRING)
					.addScalar("dataInicioContrato", Hibernate.DATE).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2. O sistema dever? verificar todos os comandos de cobran?a por
	 * resultados ativos e executados
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Object[]> pesquisarComandosCobrancaAtivosExecutados(
			Integer idEmpresa) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cecc.cecc_id AS idComando, "
					+ " cecc.cecc_dtexecucao AS dataExecucao "
					+ "   FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " WHERE cecc.cecc_dtexecucao is not null "
					+ "   AND cecc.cecc_dtencerramento is null "
					+ "   AND cecc.cecc_icgeracaotxt = 1 "
					+ "   AND cecc.empr_id = :idEmpresa ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idComando", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					.setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1. Para cada comando selecionado o sistema dever? selecionar os ordens
	 * de servi?o ativas associadas ao mesmo
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Collection<Object[]> pesquisarOrdensServicoAtivasComando(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct orse.orse_id AS idOS, ecco.imov_id AS idImovel "
					+ "  FROM ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "    INNER JOIN cobranca.empresa_cobranca_conta ecco ON ecco.orse_id = orse.orse_id "
					+ "  WHERE ecco.cecc_id = :idComando AND orse.orse_cdsituacao = :PENDENTE ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setShort("PENDENTE", OrdemServico.SITUACAO_PENDENTE)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1.1. Para cada Ordem de Servi?o selecionada, o sistema dever? verificar
	 * se as contas associadas ao im?vel da ordem de servi?o est?o quitadas ou
	 * parceladas
	 * 
	 * @author Mariana Victor, Ana Maria
	 * @throws ErroRepositorioException
	 * @data 02/07/2011
	 */
	public Boolean verificarExisteContasEmAberto(Integer idOS)
			throws ErroRepositorioException {

		Boolean retorno = null;
		Integer dados = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(ecco.cnta_id) AS quantidadeConta "
					+ "  FROM cobranca.empresa_cobranca_conta ecco "
					+ "  WHERE ecco.orse_id = :idOS "
					// + "  AND ecco.ecco_cdincluido is null "
					+ "  AND ( NOT EXISTS (SELECT pgmt.cnta_id FROM arrecadacao.pagamento pgmt WHERE pgmt.cnta_id = ecco.cnta_id) "
					+ "  AND NOT EXISTS (SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi WHERE pghi.cnta_id = ecco.cnta_id) "
					+ "  AND NOT EXISTS (SELECT cnta.cnta_id FROM faturamento.conta cnta WHERE cnta.cnta_id = ecco.cnta_id AND (cnta.dcst_idatual = 5 OR cnta.dcst_idatual = 3) ) "
					+ "  AND NOT EXISTS (SELECT cntahi.cnta_id FROM faturamento.conta_historico cntahi WHERE cntahi.cnta_id = ecco.cnta_id AND cntahi.dcst_idatual = 5 OR cntahi.dcst_idatual = 3)) ";

			dados = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidadeConta", Hibernate.INTEGER)
					.setInteger("idOS", idOS).setMaxResults(1).uniqueResult();

			if (dados == null || dados.compareTo(new Integer(0)) == 0) {
				retorno = false;
			} else {
				retorno = true;
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente
	 * 
	 * @author Mariana Victor
	 * @date 21/07/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return boolean
	 * @throws ErroRepositorioException
	 */
	public boolean verificaDebitoACobrarVinculadoAContratoParcelAtivo(
			Integer idDebitoACobrar) throws ErroRepositorioException {

		boolean retorno = false;
		Session session = HibernateUtil.getSession();

		String consulta;
		Integer quantidadeDebitosACobrar = null;

		try {

			consulta = "SELECT COUNT(*) AS quantidade from cobranca.contrato_parcel_item item "
					+ "inner join cobranca.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
					+ " where item.dbac_id = :idDebitoACobrar and cpar.pcst_id = "
					+ ParcelamentoSituacao.NORMAL;

			quantidadeDebitosACobrar = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

			if (quantidadeDebitosACobrar != null
					&& quantidadeDebitosACobrar > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com C?digo de Barras
	 * 
	 * [SB0020] - Processar Pagamento de Contrato Parcelamento
	 * 
	 * @author Mariana Victor
	 * @data 03/08/2011
	 */
	public Object[] obterDadosDocumentoCobrancaItemContratoParcelamento(
			Integer idPrestacao) throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cdit.cdit_vlitemcobrado AS valorItem, "
					+ "   cppr.cppr_nnprestacao AS numeroPrestacao, "
					+ "   cppr.cpar_id AS idContrato "
					+ " FROM cobranca.cobranca_documento_item cdit "
					+ "   INNER JOIN cobranca.contrato_parcel_prest cppr ON cppr.cppr_id = cdit.cppr_id "
					+ " WHERE cdit.cppr_id = :idPrestacao ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacao", Hibernate.INTEGER)
					.addScalar("idContrato", Hibernate.INTEGER)
					.setInteger("idPrestacao", idPrestacao).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1167] Consultar Comandos de Cobran?a por Empresa Pesquisa dados do
	 * popup
	 * 
	 * @author Hugo Azevedo
	 * @date 25/08/2011
	 */

	public Collection pesquisarDadosPopupExtensaoComandoAguaSituacao(
			Integer idComando) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT las.last_id AS id,"
					+ " las.last_dsligacaoaguasituacao as descricao "
					+ " from cobranca.cmd_empr_cobr_conta_last cecc "
					+ " inner join atendimentopublico.ligacao_agua_situacao las on cecc.last_id = las.last_id "
					+ " where cecc.cecc_id = :idComando";

			retorno = session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobran?a por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Object[] pesquisarDadosQtdContasEDiasVencidos(Integer idComando)
			throws ErroRepositorioException {
		Object[] retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT cecc.CECC_QTDCONTASINICIAL AS qtdContasInicial, "
					+ "   cecc.CECC_QTDCONTASINICIAL AS qtdContasFinal, "
					+ "   cecc.CECC_QTDDIASVENCIMENTO AS qtdDiasVencidos, "
					+ "   last.last_id AS ligacaoId, "
					+ "   last.last_dsligacaoaguasituacao AS ligacaoNome "
					+ " FROM cobranca.cmd_empr_cobr_conta cecc "
					+ " left join atendimentopublico.ligacao_agua_situacao last on last.last_id = cecc.last_id "
					+ " WHERE cecc.cecc_id = :idComando ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("qtdContasInicial", Hibernate.INTEGER)
					.addScalar("qtdContasFinal", Hibernate.INTEGER)
					.addScalar("qtdDiasVencidos", Hibernate.INTEGER)
					.addScalar("ligacaoId", Hibernate.INTEGER)
					.addScalar("ligacaoNome", Hibernate.STRING)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0869] Gerar Arqv Texto das Contas em Cobran?a por Empresa
	 * 
	 * @author Paulo Diniz
	 * @data 03/08/2011
	 * 
	 */
	public Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> pesquisarColecaoLigacaoAguaSituacaoPorComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao> retorno = null;
		String consulta;

		try {
			consulta = "select \n "
					+ "	comandoLigacao \n "
					+ "from \n "
					+ "   CmdEmpresaCobrancaContaLigacaoAguaSituacao comandoLigacao \n "
					+ "   inner join fetch comandoLigacao.comandoEmpresaCobrancaConta comandoEmpresaCobrancaConta \n "
					+ "   inner join fetch comandoLigacao.ligacaoAguaSituacao ligacaoAguaSituacao \n "
					+ "where comandoEmpresaCobrancaConta.id = :idComando";

			retorno = (Collection<CmdEmpresaCobrancaContaLigacaoAguaSituacao>) session
					.createQuery(consulta).setInteger("idComando", idComando)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosClienteResponsavel(Integer idImovel)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select cli.indicadorAcrescimos from ClienteImovel cliImo "
					+ "inner join cliImo.clienteRelacaoTipo crt "
					+ "inner join cliImo.cliente cli "
					+ "inner join cliImo.imovel imo "
					+ "where imo.id = :idImovel AND "
					+ "crt.id = :idResponsavel AND "
					+ "cliImo.dataFimRelacao is null ";
			retorno = (Short) session
					.createQuery(consulta)
					.setInteger("idImovel", idImovel)
					.setInteger("idResponsavel", ClienteRelacaoTipo.RESPONSAVEL)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0067] Obter D?bito do Im?vel ou Cliente
	 * 
	 * @author Raphael Rossiter
	 * @date 19/09/2011
	 * 
	 * @param idImovel
	 * @return Short
	 * @throws ErroRepositorioException
	 */
	public Short obterIndicadorAcrescimosCliente(Integer idCliente)
			throws ErroRepositorioException {

		Short retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = "select clie.indicadorAcrescimos from Cliente clie "
					+ "where clie.id = :idCliente ";

			retorno = (Short) session.createQuery(consulta)
					.setInteger("idCliente", idCliente).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1233] - Encerrar Ordem de Servico de Visita de Cobran?a
	 * 
	 * @author Hugo Azevedo
	 * @date 23/09/2011
	 */
	public Collection<Integer> obterColecaoOrdemServicoVisitaCobranca(
			String idGrupo, String mesAno) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Integer> retorno = new ArrayList<Integer>();

		try {
			sql = " select os.orse_id"
					+ " from atendimentopublico.ordem_servico os "
					+ " inner join cobranca.cobranca_documento cobdoc on cobdoc.cbdo_id = os.cbdo_id"
					+ " inner join cobranca.cobranca_acao_ativ_crg cobaar on cobaar.caac_id = cobdoc.caac_id"
					+ " inner join cobranca.cobranca_acao_cronograma cac on cac.cbcr_id = cobaar.cbcr_id"
					+ " inner join cobranca.cobranca_grupo_crg_mes cgcm on cgcm.cbcm_id = cac.cbcm_id"
					+ " where cgcm.cbgr_id = :idGrupo"
					+ " and cgcm.cbcm_amreferencia = :mesAno"
					+ " and os.orse_cdsituacao = :situacao";

			retorno = session.createSQLQuery(sql)
					.addScalar("orse_id", Hibernate.INTEGER)
					.setInteger("idGrupo", new Integer(idGrupo))
					.setInteger("mesAno", new Integer(mesAno))
					.setInteger("situacao", OrdemServico.SITUACAO_PENDENTE)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	public Integer pesquisarQuantidadeImoveisPorGrupoCobrancaAgrupadosTitulo(
			Integer gerencia, Integer unidade, Integer localidade,
			Integer setorComercial, Integer quadra)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		String query = null;
		Integer quantidadeImoveis = 0;
		Short indicadorExcluido = ConstantesSistema.INDICADOR_USO_DESATIVO;
		try {
			query = "SELECT count(distinct i.imov_id) as QtdImoveis"
					+ " FROM cadastro.imovel i"
					+ " join cobranca.imovel_nao_gerado ing on ing.imov_id = i.imov_id"
					+ " join cadastro.localidade l on l.loca_id = i.loca_id"
					+ " join cadastro.setor_comercial sc on sc.stcm_id = i.stcm_id"
					+ " join cadastro.quadra q on q.qdra_id = i.qdra_id"
					+ " join micromedicao.rota r on r.rota_id = q.rota_id"
					+ " where i.imov_icexclusao = :indicadorExcluido";

			if (gerencia != null && gerencia.intValue() != -1)
				query += " and l.greg_id = :gerencia";
			if (unidade != null && unidade.intValue() != -1)
				query += " and l.uneg_id = :unidade";
			if (localidade != null && localidade.intValue() != -1)
				query += " and i.loca_id = :localidade";
			if (setorComercial != null && setorComercial.intValue() != -1)
				query += " and sc.stcm_cdsetorcomercial = :setorComercial";
			if (quadra != null && quadra.intValue() != -1)
				query += " and q.qdra_nnquadra = :quadra";

			Query q = session.createSQLQuery(query)
					.addScalar("QtdImoveis", Hibernate.INTEGER)
					.setShort("indicadorExcluido", indicadorExcluido);

			if (gerencia != null && gerencia.intValue() != -1)
				q.setInteger("gerencia", gerencia);
			if (unidade != null && unidade.intValue() != -1)
				q.setInteger("unidade", unidade);
			if (localidade != null && localidade.intValue() != -1)
				q.setInteger("localidade", localidade);
			if (setorComercial != null && setorComercial.intValue() != -1)
				q.setInteger("setorComercial", setorComercial);
			if (quadra != null && quadra.intValue() != -1)
				q.setInteger("quadra", quadra);

			quantidadeImoveis = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return quantidadeImoveis;
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a
	 * 
	 * Metodo que pesquisa contas canceladas associadas a comandos de cobran?a
	 * no mes de arrecada??o
	 * 
	 * @author Raimundo Martins
	 * @date 03/10/2011
	 * 
	 */
	public Collection<Object[]> pesquisarContasCanceladasMesAssocComandosCobranca(
			Integer anoMesArrecadacao, Integer debitoCreditoSituacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT ecco.ecco_id, "
					+ "  cnta.cmcn_id, "
					+ "  cnta.cnta_dtcancelamento, "
					+ "  CASE "
					+ "    WHEN cnta.cnta_vlimpostos IS NULL "
					+ "    THEN ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - cnta.cnta_vlcreditos) "
					+ "    WHEN ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos - cnta.cnta_vlimpostos)) IS NULL "
					+ "    THEN 0 "
					+ "    ELSE ((cnta.cnta_vlagua + cnta.cnta_vlesgoto + cnta.cnta_vldebitos) - (cnta.cnta_vlcreditos - cnta.cnta_vlimpostos)) "
					+ "  END AS valorContaCancelada, "
					+ "  cnta.imov_id "
					+ "FROM FATURAMENTO.conta cnta "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cnta_id                                  = cnta.cnta_id "
					+ "WHERE TO_CHAR(cnta.cnta_dtcancelamento,'YYYYMM') = :anoMesArrecadacao "
					+ "AND cnta.dcst_idatual                            = :debitoCreditoSituacao ";

			return session
					.createSQLQuery(sql)
					.addScalar("ecco_id", Hibernate.INTEGER)
					.addScalar("cmcn_id", Hibernate.INTEGER)
					.addScalar("valorContaCancelada", Hibernate.BIG_DECIMAL)
					.addScalar("imov_id", Hibernate.INTEGER)
					.addScalar("cnta_dtcancelamento", Hibernate.DATE)
					.setString("anoMesArrecadacao",
							anoMesArrecadacao.toString())
					.setInteger("debitoCreditoSituacao", debitoCreditoSituacao)
					.list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Empresa> obterColecaoEmpresasContratadasCobranca()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Empresa> colecaoEmpresa = new ArrayList<Empresa>();

		try {
			colecaoEmpresa = session
					.createCriteria(Empresa.class)
					.add(Restrictions.eq("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO))
					.add(Restrictions.eq("indicadorEmpresaContratadaCobranca",
							ConstantesSistema.INDICADOR_USO_ATIVO)).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoEmpresa;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Regiao> obterColecaoRegioes()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Regiao> colecaoRegiao = new ArrayList<Regiao>();

		try {
			colecaoRegiao = session
					.createCriteria(Regiao.class)
					.add(Restrictions.eq("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO))
					.addOrder(Order.asc("nome")).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return colecaoRegiao;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */

	public Collection<Microrregiao> obterColecaoMicroRegioes(String[] idsRegiao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Microrregiao> colecaoMicroRegiao = new ArrayList<Microrregiao>();
		String hql = "";

		try {
			hql = " select mr " + " from Microrregiao mr "
					+ " inner join mr.regiao r"
					+ " where mr.indicadorUso = :indicador";

			if (idsRegiao != null)
				hql += " and r.id in (:idsRegiao)";

			hql += " order by mr.nome";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsRegiao != null)
				q.setParameterList("idsRegiao", idsRegiao);

			colecaoMicroRegiao = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoMicroRegiao;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Municipio> obterColecaoMunicipios(String[] idsRegiao,
			String[] idsMicroRegiao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Municipio> colecaoMunicipio = new ArrayList<Municipio>();
		String hql = "";

		try {
			hql = " select m " + " from Municipio m "
					+ " inner join m.microrregiao mr"
					+ " inner join mr.regiao r"
					+ " where m.indicadorUso = :indicador";

			if (idsRegiao != null)
				hql += " and r.id in (:idsRegiao)";
			if (idsMicroRegiao != null)
				hql += " and mr.id in (:idsMicroRegiao)";

			hql += " order by m.nome ASC";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsRegiao != null)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);

			colecaoMunicipio = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoMunicipio;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<UnidadeNegocio> obterColecaoUnidadeNegocio(
			String[] idsGerencias) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String hql = "";
		Collection<UnidadeNegocio> retorno = new ArrayList<UnidadeNegocio>();

		try {
			hql = "select un " + " from UnidadeNegocio un "
					+ " inner join un.gerenciaRegional gr "
					+ " where un.indicadorUso = :indicador ";

			if (idsGerencias != null)
				hql += " and gr.id in (:idsGerencia)";

			hql += " order by un.nome";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsGerencias != null)
				q.setParameterList("idsGerencia", idsGerencias);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento
	 * 
	 * @author Hugo Azevedo
	 * @date 13/10/2011
	 */
	public Collection<Localidade> obterColecaoLocalidade(Integer idLocalidade,
			String[] idsGerencias, String[] idsUnidadeNegocio)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String hql = "";
		Collection<Localidade> retorno = new ArrayList<Localidade>();

		try {

			hql = " select l " + " from Localidade l "
					+ " inner join l.unidadeNegocio un"
					+ " inner join l.gerenciaRegional gr"
					+ " where l.indicadorUso = :indicador "
					+ " and l.id = :idLocalidade";

			if (idsGerencias != null)
				hql += " and gr.id in (:idsGerencia) ";
			if (idsUnidadeNegocio != null)
				hql += " and un.id in (:idsUnidadeNegocio) ";

			Query q = session
					.createQuery(hql)
					.setInteger("indicador",
							ConstantesSistema.INDICADOR_USO_ATIVO)
					.setInteger("idLocalidade", idLocalidade);
			if (idsGerencias != null)
				q.setParameterList("idsGerencia", idsGerencias);
			if (idsUnidadeNegocio != null)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2012
	 */
	public Collection<Localidade> obterColecaoLocalidade(String[] idsGerencias,
			String[] idsUnidadeNegocio) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String hql = "";
		Collection<Localidade> retorno = new ArrayList<Localidade>();

		try {

			hql = " select l " + " from Localidade l "
					+ " inner join l.unidadeNegocio un"
					+ " inner join l.gerenciaRegional gr"
					+ " where l.indicadorUso = :indicador ";

			if (idsGerencias != null)
				hql += " and gr.id in (:idsGerencia) ";
			if (idsUnidadeNegocio != null)
				hql += " and un.id in (:idsUnidadeNegocio) ";

			hql += " order by l.descricao asc";

			Query q = session.createQuery(hql).setInteger("indicador",
					ConstantesSistema.INDICADOR_USO_ATIVO);
			if (idsGerencias != null)
				q.setParameterList("idsGerencia", idsGerencias);
			if (idsUnidadeNegocio != null)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0001]
	 * - Emitir Relat?rio de Boletim de Medi??o - Recupera??o de Cr?ditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoGeralResumido(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " SELECT GREG.GREG_ID       AS idGerenciaRegional, " + // 0
					" ECBM.LOCA_ID              AS idLocalidade, " + // 1
					" emcf.emcf_id              AS idFaixaContas, " + // 2
					" re.regi_id                AS idRegiao, " + // 3
					" loca.muni_idprincipal     AS idMunicipio, " + // 4
					" empr.empr_nmempresa       AS nomeEmpresa, " + // 5
					" ces.cese_dsnumerocontrato AS numeroContrato, " + // 6
					" ecbm.ecbm_amreferencia    AS anoMesRef, " + // 7
					" loca.loca_nmlocalidade    AS nomeLocalidade, " + // 8
					" mun.muni_nmmunicipio      AS nomeMunicipio, " + // 9-
					" emcf.emcf_dsfaixa         AS descricaoFaixaContas,"; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += "  count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += " sum(ecbm.ecbm_vlcontaspagtoavista) as pagtoAVista, "
					+ // 13
					" sum(ecbm.ecbm_vlcontaspagtoparcelado) as pagtoParcelado, "
					+ // 14
					" emcf.emcf_pcfaixa as percentualFaixa,"
					+ // 15
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 16
					" re.REGI_NMREGIAO as regiao, "
					+ // 17
					" ecbm.ecbm_vldescontos as valorDesconto "
					+ // 18

					" FROM COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (CECC.cecc_ID = ECBM.cecc_ID) "
					+ " left JOIN CADASTRO.empresa EMPR ON (EMPR.EMPR_ID = CECC.EMPR_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_ID =ECBM.emcf_ID ) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id"
					+

					" WHERE empr.empr_id            = :idEmpresa "
					+ " AND ecbm.ecbm_amreferencia    = :anoMesReferencia "
					+ " AND EMPR.EMPR_ICUSO           = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA      = 1 "
					+ " AND GREG.GREG_ICUSO           = 1 "
					+ " AND (ecbm.ecbm_vlcontaspagtoavista > 0 "
					+ " 	OR ecbm.ecbm_vlcontaspagtoparcelado > 0) ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " loca.loca_nmlocalidade,"
					+ " mun.muni_nmmunicipio," + " emcf.emcf_dsfaixa,"
					+ " emcf.emcf_pcfaixa," + " ecbm.cecc_id,"
					+ " ecbm.imov_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO," + " ecbm.ecbm_vldescontos ";

			// 4.1. Caso informada a Op??o do Boletim=Geral e Op??o do
			// Relat?rio=Resumido
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas";
			else
				sql += " order by regiao, nomeMunicipio, idFaixaContas";

			Query q = session.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 16
					.addScalar("regiao", Hibernate.STRING)
					// 17
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					// 18
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao));

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0003]
	 * - Emitir Relat?rio de Boletim de Medi??o - Recupera??o de Cr?ditos
	 * Parcelados
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoResumidoParcelamento(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " SELECT GREG.GREG_ID       AS idGerenciaRegional, " + // 0
					" ECBM.LOCA_ID              AS idLocalidade, " + // 1
					" emcf.emcf_id              AS idFaixaContas, " + // 2
					" re.regi_id                AS idRegiao, " + // 3
					" loca.muni_idprincipal     AS idMunicipio, " + // 4
					" empr.empr_nmempresa       AS nomeEmpresa, " + // 5
					" ces.cese_dsnumerocontrato AS numeroContrato, " + // 6
					" ecbm.ecbm_amreferencia    AS anoMesRef, " + // 7
					" loca.loca_nmlocalidade    AS nomeLocalidade, " + // 8
					" mun.muni_nmmunicipio      AS nomeMunicipio, " + // 9
					" emcf.emcf_dsfaixa         AS descricaoFaixaContas,"; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += "SUM(ecbm.ecbm_vlcontaspagtoavista) AS pagtoAVista, "
					+ // 13
					"	(select sum(ecbm2.ecbm_vlcontaspagtoparcelado) "
					+ "	  from COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM2 "
					+ "	  where ecbm2.cecc_id = ecbm.cecc_id "
					+ "     and ecbm2.imov_id = ecbm.imov_id"
					+ "     and ecbm2.ecbm_amreferencia = :anoMesReferencia) as pagtoParcelado, "
					+ // 14
					"	emcf.emcf_pcfaixa  AS percentualFaixa, "
					+ // 15
					"	(select sum(ecco2.ecco_vloriginalconta) "
					+ "	  from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "	  where ecco2.cecc_id = ecbm.cecc_id "
					+ "     and ecco2.ecco_cdincluido is null "
					+ "     and ecco2.imov_id = ecbm.imov_id) as ValorNeg, "
					+ // 16

					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 17
					" re.REGI_NMREGIAO as regiao "
					+ // 18"

					" FROM  COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.empresa EMPR  ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.cliente_imovel clim on (clim.imov_id = ecbm.imov_id and clim.crtp_id = 2 AND clim.clim_dtrelacaofim is null ) "
					+ " inner join CADASTRO.cliente cli on (cli.clie_id = clim.clie_id) "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecbm.imov_id and eccp.eccp_ampagamento = ecbm.ecbm_amreferencia) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id ";

			sql += " WHERE empr.empr_id            = :idEmpresa "
					+ " AND ecbm.ecbm_amreferencia    = :anoMesReferencia "
					+ " AND  EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " AND  eccp.eccp_ictipopagamento = 2"
					+ " and clim.crtp_id = :clienteTipo ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID, " + "  ECBM.LOCA_ID, "
					+ "  emcf.emcf_id, " + "  re.regi_id, "
					+ "  loca.muni_idprincipal, " + "  empr.empr_nmempresa, "
					+ "  ces.cese_dsnumerocontrato, "
					+ "  ecbm.ecbm_amreferencia, "
					+ "  loca.loca_nmlocalidade, " + "  mun.muni_nmmunicipio, "
					+ "  emcf.emcf_dsfaixa, " + "  emcf.emcf_pcfaixa, "
					+ "  ecbm.cecc_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO," + " ecbm.imov_id";

			// 4.3. Caso informada a Op??o do Boletim=Parcelamento e Op??o do
			// Relat?rio=Resumido,
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas";
			else
				sql += " order by regiao, nomeMunicipio, idFaixaContas";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 16
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 17
					.addScalar("regiao", Hibernate.STRING)
					// 18
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO);

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0002]
	 * - Emitir Relat?rio de Acompanhamento dos Cr?ditos Pagos ? Vista
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoGeralAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    AND ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			String sql2 = " (select sum(count( DISTINCT ecco2.imov_id))  "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2  "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    AND ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id  " + "    having   ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

					sql2 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )  " + "  as qtdFaturasNegociadas, "; // 11

					sql2 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id  "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )   " + "  as contadorImoveis,"; // 12
				}

			}

			sql += sql1 + sql2;

			sql += " ecbm.ecbm_vlcontaspagtoavista as pagtoAVista,"
					+ // 13
					" ecbm.ecbm_vlcontaspagtoparcelado as pagtoParcelado,"
					+ // 14
					" emcf.emcf_pcfaixa as percentualFaixa,"
					+ // 15
					" cli.clie_nmcliente as clienteNome,"
					+ // 16
					" ecbm.imov_id as idImovel, "
					+ // 17
					"	(select sum(ecco2.ecco_vloriginalconta) "
					+ "	  from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "	  where ecco2.cecc_id = ecbm.cecc_id "
					+ "     and ecco2.ecco_cdincluido is null "
					+ "     and ecco2.imov_id = ecbm.imov_id) as ValorNeg, "
					+ // 18
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 19
					" re.REGI_NMREGIAO as regiao, "
					+ // 20
					" ecbm.ecbm_vldescontos as valorDesconto "
					+ // 21
					" from cobranca.EMPR_COBR_CONTA_BOL_MED ecbm  "
					+ " left join COBRANCA.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecbm.cecc_id   "
					+ " left join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join CADASTRO.empresa empr on cecc.empr_id = empr.empr_id  "
					+ " inner join CADASTRO.localidade loca on loca.loca_id = ecbm.loca_id  "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " inner join CADASTRO.municipio mun on mun.muni_id = loca.muni_idprincipal   "
					+ " inner join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id   "
					+ " inner join CADASTRO.regiao re on re.regi_id = mr.regi_id   "
					+ " inner join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id  "
					+ " inner join CADASTRO.cliente_imovel cliim on ecbm.imov_id = cliim.imov_id "
					+ " inner join CADASTRO.cliente cli on cliim.clie_id = cli.clie_id "
					+ " where empr.empr_id = :idEmpresa "
					+ " and ecbm.ecbm_amreferencia = :anoMesReferencia "
					+ " and cliim.clim_dtrelacaofim is null "
					+ " and cliim.crtp_id = :clienteTipo "
					+ " and ecbm.ecbm_vlcontaspagtoavista is not null "
					+ " and ecbm.ecbm_vlcontaspagtoavista <> 0 "
					+ " and EMPR.EMPR_ICUSO = 1 "
					+ " and EMPR.EMPR_ICCOBRANCA = 1 "
					+ " and GREG.GREG_ICUSO = 1";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY GREG.GREG_ID, ECBM.LOCA_ID, emcf.emcf_id, re.regi_id,loca.muni_idprincipal,"
					+ " empr.empr_nmempresa, ces.cese_dsnumerocontrato,ecbm.ecbm_amreferencia,"
					+ " loca.loca_nmlocalidade,ecbm.ecbm_vlcontaspagtoavista,ecbm.ecbm_vlcontaspagtoparcelado,"
					+ " mun.muni_nmmunicipio, emcf.emcf_dsfaixa, emcf.emcf_pcfaixa,cli.clie_nmcliente,ecbm.imov_id,ecbm.cecc_id,greg.GREG_NMREGIONAL,re.REGI_NMREGIAO,ecbm.ecbm_vldescontos";

			// 4.2. Caso informada a Op??o do Boletim=Geral e Op??o do
			// Relat?rio=Anal?tico,
			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade, idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("contadorImoveis", Hibernate.INTEGER)
					// 12
					.addScalar("pagtoAVista", Hibernate.BIG_DECIMAL)
					// 13
					.addScalar("pagtoParcelado", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)
					// 15
					.addScalar("clienteNome", Hibernate.STRING)
					// 16
					.addScalar("idImovel", Hibernate.INTEGER)
					// 17
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 19
					.addScalar("regiao", Hibernate.STRING)
					// 20
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					// 21
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO);

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0004]
	 * - Emitir Relat?rio de Acompanhamento dos Parcelamentos - Recupera??o de
	 * Cr?ditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoParcAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )  " + "  as qtdFaturasNegociadas, "; // 11
				}

			}

			sql += sql1;

			sql += " (select sum(ecco2.ecco_vloriginalconta) "
					+ " 		from COBRANCA.empresa_cobranca_conta ecco2 "
					+ " 		where ecco2.cecc_id = ecbm.cecc_id "
					+ "      and ecco2.ecco_cdincluido is null "
					+ " 		and ecco2.imov_id = ecbm.imov_id) as ValorNeg,"
					+ // 12
					" count(distinct eccp.eccp_nnparcelaatual) as ParcelasPaga, "
					+ // 13
					" (SELECT SUM(ecbm2.ecbm_vlcontaspagtoparcelado) "
					+ "    FROM cobranca.empr_cobr_conta_bol_med ecbm2 "
					+ "    WHERE ecbm2.cecc_id = ecbm.cecc_id "
					+ "      AND ecbm2.imov_id = ecbm.imov_id "
					+ "      and ecbm2.ecbm_amreferencia = :anoMesReferencia) as ValorPago, "
					+ // 14

					/*
					 * "   (select dbac.dbac_nnprestacaodebito "+
					 * "        from FATURAMENTO.debito_a_cobrar dbac  "+
					 * "        where dbac.imov_id = ecbm.imov_id "+
					 * "         and dbac.parc_id is not null "+
					 * "         and dbac.fntp_id in (2,3,4,8,9)" +
					 * "         and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					 * +
					 * "         inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					 * +
					 * "         where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					 * + "         ) "+
					 * "         and dbac.dbac_id = (select max(dbac2.dbac_id) "
					 * +
					 * "                  from FATURAMENTO.debito_a_cobrar dbac2  "
					 * +
					 * "                  where dbac2.imov_id = ecbm.imov_id "+
					 * "                   and dbac2.parc_id is not null "+
					 * "                   and dbac2.fntp_id in (2,3,4,8,9) " +
					 * "                   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					 * +
					 * "                   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					 * +
					 * "                   where pcit.parc_id = dbac2.parc_id and ecco2.cecc_id = ecbm.cecc_id "
					 * +
					 * "                   ))) as QuantidadeParcelasEmAberto, "+
					 * //15
					 */

					" (coalesce((select count(distinct dbcd.cnta_id) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where (pgmt.cnta_id = cnta.cnta_id OR pgmt.dbac_id = dbac.dbac_id))),0)"
					+ " + "
					+ " coalesce((SELECT max(DBAC.DBAC_NNPRESTACAODEBITO - DBAC.DBAC_NNPRESTACAOCOBRADAS) "
					+ "  FROM FATURAMENTO.debito_cobrado DBCD "
					+ "  INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC "
					+ "  ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ "  WHERE DBAC.PARC_ID IS NOT NULL "
					+ "  AND DBAC.IMOV_ID    = ECBM.IMOV_ID "
					+ "  AND dbac.fntp_id   IN (2,3,4,8,9)),0) "
					+ ") AS QuantidadeParcelasEmAberto, "
					+ // 15

					" coalesce((select dahi.dahi_nnprestacaodebito "
					+ "        from FATURAMENTO.deb_a_cobrar_hist dahi  "
					+ "        where dahi.imov_id = ecbm.imov_id "
					+ "         and dahi.parc_id is not null "
					+ "         and dahi.fntp_id in (2,3,4,8,9) "
					+ "         and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "         inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "         where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					+ "         ) "
					+ "         and dahi.dbac_id = (select max(dahi2.dbac_id) from FATURAMENTO.deb_a_cobrar_hist dahi2  "
					+ "                    where dahi2.imov_id = ecbm.imov_id "
					+ "                   and dahi2.parc_id is not null "
					+ "                   and dahi2.fntp_id in (2,3,4,8,9) "
					+ "                   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "                   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "                   where pcit.parc_id = dahi2.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					+ "                   )) "
					+ "         ),0) as QuantidadeParcelasEmAbertoHist,"
					+ // 16

					/*
					 * " (select sum(dbac.dbac_VLDEBITO) "+
					 * "   from FATURAMENTO.debito_a_cobrar dbac "+
					 * "   where dbac.imov_id = ecbm.imov_id  "+
					 * "   and dbac.parc_id is not null "+
					 * "   and dbac.fntp_id in (2,3,4,8,9) "+
					 * "   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					 * +
					 * "       inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					 * +
					 * "       where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					 * + "       ) "+ "   ) AS SaldoEmAberto, "+ //17
					 */

					" (coalesce((select sum(dbcd.dbcb_vlprestacao) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where (pgmt.cnta_id = cnta.cnta_id OR pgmt.dbac_id = dbac.dbac_id))),0)"
					+ " + "
					+ " coalesce((SELECT max((DBAC.DBAC_NNPRESTACAODEBITO - DBAC.DBAC_NNPRESTACAOCOBRADAS)*CP.PARC_VLPRESTACAO) "
					+ "  FROM COBRANCA.PARCELAMENTO CP "
					+ "  INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC "
					+ "  ON (DBAC.PARC_ID = CP.PARC_ID) "
					+ "  WHERE DBAC.PARC_ID IS NOT NULL "
					+ "  AND DBAC.IMOV_ID    = ECBM.IMOV_ID "
					+ "  AND dbac.fntp_id   IN (2,3,4,8,9)),0) "
					+ ") AS SaldoEmAberto, "
					+ // 17

					"	(select sum(dahi.dahi_VLDEBITO) "
					+ "	from FATURAMENTO.deb_a_cobrar_hist dahi "
					+ "	where dahi.imov_id = ecbm.imov_id  "
					+ "	 and dahi.parc_id is not null "
					+ "	 and dahi.fntp_id in (2,3,4,8,9) "
					+ "	 and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "	   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "	   where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					+ "      ) "
					+ "	 ) AS SaldoEmAbertoHist, "
					+ // 18

					" cli.clie_nmcliente as clienteNome,"
					+ // 19
					" ecbm.imov_id AS idImovel,"
					+ // 20
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 21
					" re.REGI_NMREGIAO as regiao "
					+ // 22

					" FROM  COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.empresa EMPR  ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.cliente_imovel clim on (clim.imov_id = ecbm.imov_id and clim.crtp_id = 2 AND clim.clim_dtrelacaofim is null ) "
					+ " inner join CADASTRO.cliente cli on (cli.clie_id = clim.clie_id) "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecbm.imov_id  and eccp.eccp_ampagamento = ecbm.ecbm_amreferencia) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id "
					+

					" WHERE EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " and eccp.eccp_ictipopagamento = 2 "
					+ " and clim.crtp_id = :clienteTipo "
					+ " and ECBM.ECBM_AMREFERENCIA = :anoMesReferencia "
					+ " and empr.empr_id= :idEmpresa ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY " + " GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " cli.clie_nmcliente, "
					+ " loca.loca_nmlocalidade," + " mun.muni_nmmunicipio,"
					+ " emcf.emcf_dsfaixa," + " ecbm.cecc_id,"
					+ " ecbm.imov_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO";

			// 4.4. Caso informada a Op??o do Boletim= Parcelamento e Op??o do
			// Relat?rio=Anal?tico,

			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade,idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 12
					.addScalar("ParcelasPaga", Hibernate.INTEGER)
					// 13
					.addScalar("ValorPago", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("QuantidadeParcelasEmAberto", Hibernate.INTEGER)
					// 15
					.addScalar("QuantidadeParcelasEmAbertoHist",
							Hibernate.INTEGER)
					// 16
					.addScalar("SaldoEmAberto", Hibernate.BIG_DECIMAL)
					// 17
					.addScalar("SaldoEmAbertoHist", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("clienteNome", Hibernate.STRING)
					// 19
					.addScalar("idImovel", Hibernate.INTEGER)
					// 20
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 21
					.addScalar("regiao", Hibernate.STRING)
					// 22
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO);

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0005]
	 * - Emitir Relat?rio de Acompanhamento dos Parcelamentos em Atraso -
	 * Recupera??o de Cr?ditos
	 * 
	 * @author Hugo Azevedo
	 * @date 17/10/2011
	 */
	public Collection<Object[]> gerarDadosRelatorioBoletimMedicaoAcompanhamentoParcEmAtrasoAnalitico(
			Integer idEmpresa, String periodoApuracao, Integer idLocalidade,
			String[] idsGerenciaRegional, String[] idsUnidadeNegocio,
			String[] idsRegiao, String[] idsMicroRegiao, String[] idsMunicipio,
			short indicadorOperacao, short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa

	) throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			sql = " select GREG.GREG_ID as idGerenciaRegional, " + // 0
					"	ECBM.LOCA_ID as idLocalidade, " + // 1
					"	emcf.emcf_id as idFaixaContas, " + // 2
					"	re.regi_id as idRegiao, " + // 3
					"	loca.muni_idprincipal as idMunicipio, " + // 4
					"	empr.empr_nmempresa as nomeEmpresa, " + // 5
					"	ces.cese_dsnumerocontrato as numeroContrato, " + // 6
					"	ecbm.ecbm_amreferencia as anoMesRef, " + // 7
					"	loca.loca_nmlocalidade as nomeLocalidade, " + // 8
					"	mun.muni_nmmunicipio as nomeMunicipio, " + // 9
					"	emcf.emcf_dsfaixa as descricaoFaixaContas, "; // 10

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			String sql1 = "  (select sum(count( DISTINCT ecco2.cnta_id)) "
					+ "    from COBRANCA.empresa_cobranca_conta ecco2 "
					+ "    where ecco2.cecc_id = ecbm.cecc_id "
					+ "    and ecco2.ecco_cdincluido is null "
					+ "    and ecco2.imov_id = ecbm.imov_id "
					+ "    group by ecco2.imov_id " + "    having  ";

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					sql1 += "    (count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ ") OR ";

				} else {
					sql1 += " count(distinct(CASE WHEN emcf.emcf_id = "
							+ faixa.getId().toString()
							+ "    THEN  ecco2.cnta_id "
							+ "    ELSE NULL END)) >= " + numeroMinimoContas
							+ " )  " + "  as qtdFaturasNegociadas, "; // 11
				}

			}

			sql += sql1;

			sql += " (select sum(ecco2.ecco_vloriginalconta) "
					+ " 		from COBRANCA.empresa_cobranca_conta ecco2 "
					+ " 		where ecco2.cecc_id = ecbm.cecc_id "
					+ " 		and ecco2.imov_id = ecbm.imov_id "
					+ "      and ecco2.ecco_cdincluido is null) as ValorNeg,"
					+ // 12
					" count(distinct eccp.eccp_nnparcelaatual) as ParcelasPaga, "
					+ // 13
					" (SELECT SUM(ecbm2.ecbm_vlcontaspagtoparcelado) "
					+ "    FROM cobranca.empr_cobr_conta_bol_med ecbm2 "
					+ "    WHERE ecbm2.cecc_id = ecbm.cecc_id "
					+ "      AND ecbm2.imov_id = ecbm.imov_id "
					+ "      and ecbm2.ecbm_amreferencia = :anoMesReferencia) as ValorPago,"
					+ // 14

					" (select count(distinct dbcd.cnta_id) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " AND trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta) > 3 "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where (pgmt.cnta_id = cnta.cnta_id OR pgmt.dbac_id = dbac.dbac_id))) AS parcelaAtraso, "
					+ // 15

					" (select sum(dbcd.dbcb_vlprestacao) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " AND trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta) > 3 "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where (pgmt.cnta_id = cnta.cnta_id OR pgmt.dbac_id = dbac.dbac_id))) AS ValorEmAtraso, "
					+ // 16

					/*
					 * " (select sum(dbac.dbac_VLDEBITO) "+
					 * "   from FATURAMENTO.debito_a_cobrar dbac "+
					 * "   where dbac.imov_id = ecbm.imov_id  "+
					 * "   and dbac.parc_id is not null "+
					 * "   and dbac.fntp_id in (2,3,4,8,9) "+
					 * "   and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					 * +
					 * "       inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					 * +
					 * "       where pcit.parc_id = dbac.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					 * + "       ) "+ "   ) AS SaldoEmAberto, "+ //17
					 */

					" ((select sum(dbcd.dbcb_vlprestacao) "
					+ " from FATURAMENTO.debito_cobrado DBCD "
					+ " INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC ON (DBAC.DBAC_ID = DBCD.DBAC_ID) "
					+ " INNER JOIN FATURAMENTO.CONTA CNTA ON (CNTA.CNTA_ID = DBCD.CNTA_ID) "
					+ " WHERE DBAC.PARC_ID IS NOT NULL  "
					+ " AND DBAC.IMOV_ID = ECBM.IMOV_ID "
					+ " and dbac.fntp_id in (2,3,4,8,9) "
					+ " and not exists (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where (pgmt.cnta_id = cnta.cnta_id OR pgmt.dbac_id = dbac.dbac_id)))"
					+ " + "
					+ " (SELECT max((DBAC.DBAC_NNPRESTACAODEBITO - DBAC.DBAC_NNPRESTACAOCOBRADAS)*CP.PARC_VLPRESTACAO) "
					+ "  FROM COBRANCA.PARCELAMENTO CP "
					+ "  INNER JOIN FATURAMENTO.DEBITO_A_COBRAR DBAC "
					+ "  ON (DBAC.PARC_ID = CP.PARC_ID) "
					+ "  WHERE DBAC.PARC_ID IS NOT NULL "
					+ "  AND DBAC.IMOV_ID    = ECBM.IMOV_ID "
					+ "  AND dbac.fntp_id   IN (2,3,4,8,9)) "
					+ ") AS SaldoEmAberto, "
					+ // 17

					"	(select sum(dahi.dahi_VLDEBITO) "
					+ "	from FATURAMENTO.deb_a_cobrar_hist dahi "
					+ "	where dahi.imov_id = ecbm.imov_id  "
					+ "	 and dahi.parc_id is not null "
					+ "	 and dahi.fntp_id in (2,3,4,8,9) "
					+ "	 and exists (select pcit.cnta_id from COBRANCA.parcelamento_item pcit  "
					+ "	   inner join COBRANCA.empresa_cobranca_conta ecco2 on pcit.cnta_id = ecco2.cnta_id "
					+ "	   where pcit.parc_id = dahi.parc_id and ecco2.cecc_id = ecbm.cecc_id"
					+ "      ) "
					+ "	 ) AS SaldoEmAbertoHist, "
					+ // 18

					" cli.clie_nmcliente as clienteNome,"
					+ // 19
					" ecbm.imov_id AS idImovel,"
					+ // 20
					" greg.GREG_NMREGIONAL as gerenciaRegional,"
					+ // 21
					" re.REGI_NMREGIAO as regiao "
					+ // 22

					" FROM  CADASTRO.empresa EMPR  "
					+ " INNER JOIN COBRANCA.CMD_EMPR_COBR_CONTA CECC ON (CECC.EMPR_ID = EMPR.EMPR_ID) "
					+ " INNER JOIN COBRANCA.EMPR_COBR_CONTA_BOL_MED ECBM ON (ECBM.CECC_ID = CECC.CECC_ID) "
					+ " INNER JOIN CADASTRO.LOCALIDADE LOCA ON (LOCA.LOCA_ID = ECBM.LOCA_ID ) "
					+ " INNER JOIN CADASTRO.GERENCIA_REGIONAL GREG ON (GREG.GREG_ID = LOCA.GREG_ID) "
					+ " INNER JOIN CADASTRO.UNIDADE_NEGOCIO UNEG ON (UNEG.UNEG_ID = LOCA.UNEG_ID) "
					+ " INNER join CADASTRO.municipio mun on mun.muni_id = LOCA.muni_idprincipal "
					+ " INNER join CADASTRO.microrregiao mr on mr.mreg_id = mun.mreg_id "
					+ " INNER join CADASTRO.regiao re on re.regi_id = mr.regi_id "
					+ " inner join CADASTRO.cliente_imovel clim on (clim.imov_id = ecbm.imov_id and clim.crtp_id = 2 AND clim.clim_dtrelacaofim is null ) "
					+ " inner join CADASTRO.cliente cli on (cli.clie_id = clim.clie_id) "
					+ " inner join CADASTRO.empr_cobr_faixa emcf on (emcf.emcf_id =ECBM.EMCF_ID ) "
					+ " inner join COBRANCA.empr_cobr_conta_pagto eccp on (eccp.imov_id = ecbm.imov_id and eccp.eccp_ampagamento = ecbm.ecbm_amreferencia) "
					+ " INNER join MICROMEDICAO.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id "
					+

					" WHERE EMPR.EMPR_ICUSO = 1 "
					+ " AND EMPR.EMPR_ICCOBRANCA = 1 "
					+ " AND GREG.GREG_ICUSO = 1 "
					+ " and eccp.eccp_ictipopagamento = 2 "
					+ " and clim.crtp_id = :clienteTipo "
					+ " and ECBM.ECBM_AMREFERENCIA = :anoMesReferencia "
					+ " and empr.empr_id= :idEmpresa "
					+ " and (select count(distinct dbcd.cnta_id) "
					+ " 		from FATURAMENTO.debito_cobrado DBCD "
					+ " 			INNER JOIN faturamento.debito_a_cobrar dbac ON (dbac.dbac_id = dbcd.dbac_id) "
					+ " 			INNER JOIN faturamento.conta cnta ON (cnta.cnta_id = dbcd.cnta_id) "
					+ " 		WHERE dbac.parc_id IS NOT NULL  "
					+ "			AND dbac.imov_id = ecbm.imov_id "
					+ " 			AND dbac.fntp_id IN (2,3,4,8,9) "
					+ " 			AND trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta) > 3 "
					+ " 			AND NOT EXISTS (select pgmt.pgmt_id from arrecadacao.pagamento pgmt where pgmt.cnta_id = cnta.cnta_id)) > 0 ";

			if (idLocalidade != null)
				sql += " and loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " and loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " and loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " and mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " and mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " and mun.muni_id in (:idsMunicipio)";

			sql += " GROUP BY " + " GREG.GREG_ID," + " ECBM.LOCA_ID,"
					+ " emcf.emcf_id," + " re.regi_id,"
					+ " loca.muni_idprincipal," + " empr.empr_nmempresa,"
					+ " ces.cese_dsnumerocontrato,"
					+ " ecbm.ecbm_amreferencia," + " cli.clie_nmcliente, "
					+ " loca.loca_nmlocalidade," + " mun.muni_nmmunicipio,"
					+ " emcf.emcf_dsfaixa," + " ecbm.cecc_id,"
					+ " ecbm.imov_id," + " greg.GREG_NMREGIONAL,"
					+ " re.REGI_NMREGIAO";

			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by gerenciaRegional, nomeLocalidade,idFaixaContas, idImovel";
			else
				sql += " order by regiao, nomeMunicipio,idFaixaContas, idImovel";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)
					// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)
					// 2
					.addScalar("idRegiao", Hibernate.INTEGER)
					// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)
					// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)
					// 5
					.addScalar("numeroContrato", Hibernate.STRING)
					// 6
					.addScalar("anoMesRef", Hibernate.STRING)
					// 7
					.addScalar("nomeLocalidade", Hibernate.STRING)
					// 8
					.addScalar("nomeMunicipio", Hibernate.STRING)
					// 9
					.addScalar("descricaoFaixaContas", Hibernate.STRING)
					// 10
					.addScalar("qtdFaturasNegociadas", Hibernate.INTEGER)
					// 11
					.addScalar("ValorNeg", Hibernate.BIG_DECIMAL)
					// 12
					.addScalar("ParcelasPaga", Hibernate.INTEGER)
					// 13
					.addScalar("ValorPago", Hibernate.BIG_DECIMAL)
					// 14
					.addScalar("parcelaAtraso", Hibernate.INTEGER)
					// 15
					.addScalar("ValorEmAtraso", Hibernate.BIG_DECIMAL)
					// 16
					.addScalar("SaldoEmAberto", Hibernate.BIG_DECIMAL)
					// 17
					.addScalar("SaldoEmAbertoHist", Hibernate.BIG_DECIMAL)
					// 18
					.addScalar("clienteNome", Hibernate.STRING)
					// 19
					.addScalar("idImovel", Hibernate.INTEGER)
					// 20
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 21
					.addScalar("regiao", Hibernate.STRING)
					// 22
					.setInteger("idEmpresa", idEmpresa)
					.setInteger("anoMesReferencia",
							new Integer(periodoApuracao))
					.setInteger("clienteTipo", ClienteRelacaoTipo.USUARIO)
					.setDate("dataAtual", new Date());

			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0004]
	 * - Emitir Relat?rio de Acompanhamento dos Parcelamentos - Recupera??o de
	 * Cr?ditos
	 * 
	 * 2.4.5. Quantidade de Parcelas Pagas 2.4.6. Valor Pago
	 * 
	 * Retorna a quantidade de parcelas pagas, bem como o valor total quitado.
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */

	public Collection obterParcelasPagasRecuperacaoCreditos(Integer idImovel)
			throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		try {
			sql = " select nvl(count(eccp.eccp_id),0) as contador,"
					+ // 0
					" nvl(sum(eccp.eccp_vlpagamentomes),0) as soma"
					+ // 1
					" from cobranca.empr_cobr_conta_pagto eccp "
					+ " where eccp.eccp_ictipopagamento = :tipoPagamento "
					+ " and eccp.imov_id = :imovel";

			col = session
					.createSQLQuery(sql)
					.addScalar("contador", Hibernate.INTEGER)
					// 0
					.addScalar("soma", Hibernate.BIG_DECIMAL)
					// 1
					.setInteger("tipoPagamento",
							ConstantesSistema.INDICADOR_USO_DESATIVO)
					.setInteger("imovel", idImovel).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0004]
	 * - Emitir Relat?rio de Acompanhamento dos Parcelamentos - Recupera??o de
	 * Cr?ditos
	 * 
	 * 2.4.7. Quantidade de Parcelas Em Aberto 2.4.8. Saldo em Aberto
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */

	public Collection obterDebitosQtdParcelasACobrarRecuperacaoCreditos(
			Integer idImovel) throws ErroRepositorioException {
		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		try {
			sql = " select nvl(sum(dac.dbac_nnprestacaodebito),0) as prestacoes,"
					+ " nvl(sum(dac.dbac_nnprestacaodebito*dac.dbac_vldebito),0) as valor "
					+ " from faturamento.debito_a_cobrar dac "
					+ " where dac.parc_id is not null "
					+ " and dac.imov_id = :idImovel ";

			col = session.createSQLQuery(sql)
					.addScalar("prestacoes", Hibernate.INTEGER)// 0
					.addScalar("valor", Hibernate.BIG_DECIMAL)// 1
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1237] Gerar Relat?rio de Boletim de Medi??o e Acompanhamento [SB0005]
	 * - Emitir Relat?rio de Acompanhamento dos Parcelamentos em Atraso -
	 * Recupera??o de Cr?ditos
	 * 
	 * 2.4.6. Quantidade de Parcelas Em Atraso
	 * 
	 * @author Hugo Azevedo
	 * @date 24/10/2011
	 */
	public Collection obterParcelasEmAtrasoRecuperacaoCreditos(Integer idImovel)
			throws ErroRepositorioException {

		String sql = "";
		Session session = HibernateUtil.getSession();
		Collection col = new ArrayList();
		Date dataAtual = new Date();

		try {
			sql = " select count(dc.dbcb_id) as contador,"
					+ " nvl(sum(dc.dbcb_vlprestacao),0) as soma"
					+ " from faturamento.debito_cobrado dc "
					+ " inner join faturamento.debito_a_cobrar dac on dac.dbac_id = dc.dbac_id "
					+ " inner join faturamento.conta cnta on cnta.cnta_id = dc.cnta_id "
					+ " where dac.parc_id is not null "
					+ " and dac.imov_id = :idImovel "
					+ " and (trunc(:dataAtual) - trunc(cnta.cnta_dtvencimentoconta)) > 3 "
					+ " and not exists ("
					+ "		select pg.cnta_id from arrecadacao.pagamento pg where pg.cnta_id = cnta.cnta_id"
					+ " )";

			col = session.createSQLQuery(sql)
					.addScalar("contador", Hibernate.INTEGER)
					// 0
					.addScalar("soma", Hibernate.BIG_DECIMAL)
					// 1
					.setInteger("idImovel", idImovel)
					.setDate("dataAtual", dataAtual).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return col;
	}

	/**
	 * [UC1239] Gerar Relat?rio de Penalidades por ?ndice de Atua??o e Sucesso
	 * Financeiro
	 * 
	 * @author Hugo Azevedo
	 * @date 27/10/2011
	 */

	public Collection<Object[]> obterComandosEmPenalidades(Integer idEmpresa,
			Date dataInicial, Date dataFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {
			sql = " select cecc.empr_id as idEmpresa, "
					+ " sum(ceccp.ecpe_qtosgeradas) as qtosgeradas, "
					+ " sum(ceccp.ecpe_qtosencdec) as qtosencdec, "
					+ " sum(ceccp.ecpe_vltotalenv) as vltotalenv, "
					+ " sum(ceccp.ecpe_vltotalneg) as vltotalneg,"
					+ " emp.empr_nmempresa as nomeEmpresa,"
					+ " ces.cese_dsnumerocontrato as numerocontrato"
					+ " from cobranca.empr_conta_cobr_pena ceccp "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on ceccp.cecc_id = cecc.cecc_id "
					+ " inner join cadastro.empresa emp on cecc.empr_id = emp.empr_id "
					+ " inner join micromedicao.contrato_empresa_servico ces on ces.empr_id = cecc.empr_id"
					+ " where cecc.empr_id = :idEmpresa "
					+ " and cecc.cecc_dtexecucao between :dataInicial and :dataFinal "
					+ " group by cecc.empr_id, emp.empr_nmempresa, ces.cese_dsnumerocontrato";

			retorno = session.createSQLQuery(sql)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("qtosgeradas", Hibernate.BIG_DECIMAL)
					.addScalar("qtosencdec", Hibernate.BIG_DECIMAL)
					.addScalar("vltotalenv", Hibernate.BIG_DECIMAL)
					.addScalar("vltotalneg", Hibernate.BIG_DECIMAL)
					.addScalar("nomeEmpresa", Hibernate.STRING)
					.addScalar("numerocontrato", Hibernate.STRING)
					.setInteger("idEmpresa", idEmpresa)
					.setDate("dataInicial", dataInicial)
					.setDate("dataFinal", dataFinal).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a
	 * 
	 * Metodo que retorna a soma data de encerramento do contrato mais
	 * quantidade de meses v?lido para pagamento de uma determinada conta
	 * 
	 * @author Raimundo Martins
	 * @date 06/10/2011
	 * 
	 */
	public Date pesquisarDataEncerContratoMaisQtdMesValPgmt(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT (empr.empr_dtenccontrcob + empr.empr_nnmesesvalidopagto) AS dataEncerramento "
					+ "FROM CADASTRO.empresa empr "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.empr_id = empr.empr_id "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cecc_id = cecc.cecc_id "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON cnta.cnta_id    = ecco.cnta_id "
					+ "WHERE cnta.cnta_id = :contaId";
			return (Date) session.createSQLQuery(sql)
					.addScalar("dataEncerramento", Hibernate.DATE)
					.setInteger("contaId", idConta).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a
	 * 
	 * metodo que pesquisa os comandos encerrados sem penalidades geradas
	 * 
	 * @author Raimundo Martins
	 * @date 20/10/2011
	 * */
	public Collection<Object[]> pesquisarComandosEncerradosSemPenalidades()
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT cecc.cecc_id as comandoId,"
					+ "  COUNT(DISTINCT ecco.imov_id) AS qtImoveisEnv, "
					+ "  COUNT(DISTINCT ecco.orse_id) AS qtOSGerada, "
					+ "  COUNT(DISTINCT( "
					+ "  CASE "
					+ "    WHEN orse.amen_id = :atMotEnc "
					+ "    THEN orse.orse_id "
					+ "    ELSE 0 "
					+ "  END))                        AS qtOsEncDec, "
					+ "  COUNT(DISTINCT ecco.cnta_id) AS qtFaturasEnv, "
					+ "  (SELECT COUNT(DISTINCT ecco2.cnta_id) "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp, "
					+ "    COBRANCA.empresa_cobranca_conta ecco2 "
					+ "  WHERE eccp.ecco_id = ecco2.ecco_id "
					+ "  AND ecco2.cecc_id  = cecc.cecc_id "
					+ "  )                              AS qtFaturasNeg, "
					+ "  SUM(ecco.ecco_vloriginalconta) AS vlTotalEnv, "
					+ "  (SELECT "
					+ "    CASE "
					+ "      WHEN SUM(ecco2.ecco_vloriginalconta) IS NULL "
					+ "      OR SUM(ecco2.ecco_vloriginalconta)    = 0 "
					+ "      THEN 0 "
					+ "      ELSE SUM(ecco2.ecco_vloriginalconta) "
					+ "    END "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp, "
					+ "    COBRANCA.empresa_cobranca_conta ecco2 "
					+ "  WHERE eccp.ecco_id = ecco2.ecco_id "
					+ "  AND ecco2.cecc_id  = cecc.cecc_id "
					+ "  ) AS vlTotalNeg "
					+ "FROM COBRANCA.cmd_empr_cobr_conta cecc "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.cecc_id = cecc.cecc_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "ON orse.orse_id                 = ecco.orse_id "
					+ "WHERE cecc.cecc_dtencerramento IS NOT NULL "
					+ "AND cecc.cecc_id NOT           IN "
					+ "  (SELECT eccpe.cecc_id FROM COBRANCA.empr_conta_cobr_pena eccpe "
					+ "  ) " + "GROUP BY cecc.cecc_id";

			return session
					.createSQLQuery(sql)
					.addScalar("comandoId", Hibernate.INTEGER)
					.addScalar("qtImoveisEnv", Hibernate.INTEGER)
					.addScalar("qtOSGerada", Hibernate.INTEGER)
					.addScalar("qtOsEncDec", Hibernate.INTEGER)
					.addScalar("qtFaturasEnv", Hibernate.INTEGER)
					.addScalar("qtFaturasNeg", Hibernate.INTEGER)
					.addScalar("vlTotalEnv", Hibernate.BIG_DECIMAL)
					.addScalar("vlTotalNeg", Hibernate.BIG_DECIMAL)
					.setInteger(
							"atMotEnc",
							AtendimentoMotivoEncerramento.CANCELADO_POR_DERCURSO_DE_PRAZO)
					.list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a
	 * 
	 * Metodo que pesquisa o ComandoEmpresaCobrancaConta que possui o id
	 * informado
	 * 
	 * @author Raimundo Martins
	 * @date 20/10/2011
	 * */
	public ComandoEmpresaCobrancaConta pesquisarDadosComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "select comando from ComandoEmpresaCobrancaConta comando where comando.id = :idComando";
			return (ComandoEmpresaCobrancaConta) session.createQuery(hql)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1240] Gerar Boletim de Cobran?a por Resultado
	 * 
	 * M?todo que pesquisa os dados para a gera??o do boletim de cobran?a por
	 * resultado
	 * 
	 * @author Raimundo Martins
	 * @date 24/10/2011
	 * */
	public Collection<Object[]> pesquisarDadosBoletimCobrancaResultado()
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT MIN(ecco.cecc_id)            AS comando, "
					+ "  sisp.parm_amreferenciaarrecadacao AS mesAno, "
					+ "  imov.loca_id                      AS localidade, "
					+ "  imov.imov_id                      AS imovel, "
					+ "  COUNT(dado.idCan)                 AS qtdContaCanceladas, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.valorCancelado IS NULL "
					+ "    THEN 0 "
					+ "    ELSE dado.valorCancelado "
					+ "  END) AS valorCancelamento, "
					+ "  COUNT( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 1 "
					+ "    THEN dado.idPag "
					+ "  END) AS qtdPgAVista, "
					+ "  SUM(DISTINCT( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 2 "
					+ "    THEN dado.totalParc "
					+ "    ELSE 0 "
					+ "  END)) AS qtdPgParc, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 1 "
					+ "    THEN dado.valorPago "
					+ "    ELSE 0 "
					+ "  END) AS vlPgAVista, "
					+ "  SUM( "
					+ "  CASE "
					+ "    WHEN dado.tipoPagamento = 2 "
					+ "    THEN dado.valorPago "
					+ "    ELSE 0 "
					+ "  END) AS vlPgParc, "
					+ "  SUM(DISTINCT( "
					+ "  CASE "
					+ "    WHEN dado.cobrDoc IS NOT NULL "
					+ "    THEN "
					+ "      (SELECT "
					+ "        CASE "
					+ "          WHEN cbdo.cbdo_vldesconto IS NOT NULL "
					+ "          AND cbdo.cbdo_vldesconto  <> 0 "
					+ "          AND (cbdo.cbdo_vlacrescimos IS NULL OR cbdo.cbdo_vlacrescimos = 0 "
					+ "				OR COALESCE(cbdo.cbdo_vldesconto,0) >= COALESCE(cbdo.cbdo_vlacrescimos,0) ) "
					+ "          THEN (COALESCE(cbdo.cbdo_vldesconto,0) - COALESCE(cbdo.cbdo_vlacrescimos,0)) "
					+ "          ELSE NULL " + "        END "
					+ "      FROM COBRANCA.cobranca_documento cbdo "
					+ "      WHERE cbdo.cbdo_id     = dado.cobrDoc "
					+ "      AND dado.tipoPagamento = 1 "
					+ "      AND cbdo.imov_id       = dado.imovel "
					+ "      ) "
					+ "  END)) AS valorDesconto, ecco.empr_id  AS empresa "
					+ "FROM " + "  (SELECT eccp.ecco_id        AS eccon, "
					+ "    eccp.imov_id              AS imovel, "
					+ "    eccp.eccp_ampagamento     AS amref, "
					+ "    NULL                      AS valorCancelado, "
					+ "    eccp.eccp_vlpagamentomes  AS valorPago, "
					+ "    eccp.eccp_ictipopagamento AS tipoPagamento, "
					+ "    eccp.eccp_id              AS idPag, "
					+ "    NULL                      AS idCan, "
					+ "    eccp.eccp_nntotalparcelas AS totalParc, "
					+ "    eccp.cbdo_id              AS cobrDoc "
					+ "  FROM COBRANCA.empr_cobr_conta_pagto eccp "
					+ "  UNION " + "  SELECT eccc.ecco_id , "
					+ "    eccc.imov_id, " + "    eccc.eccc_amrefarrecadacao, "
					+ "    eccc.eccc_vlcancelamento, " + "    NULL, "
					+ "    NULL, " + "    NULL, " + "    eccc.eccc_id, "
					+ "    NULL, " + "    NULL "
					+ "  FROM COBRANCA.empr_conta_cobr_canc eccc "
					+ "  ) dado "
					+ "INNER JOIN CADASTRO.sistema_parametros sisp "
					+ "ON dado.amref = sisp.parm_amreferenciaarrecadacao "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON dado.eccon = ecco.ecco_id "
					+ "INNER JOIN CADASTRO.imovel imov "
					+ "ON dado.imovel = imov.imov_id "
					+ "GROUP BY sisp.parm_amreferenciaarrecadacao, "
					+ "  imov.loca_id, " + "  imov.imov_id, " + "ecco.empr_id";

			return session.createSQLQuery(sql)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("qtdContaCanceladas", Hibernate.INTEGER)
					.addScalar("valorCancelamento", Hibernate.BIG_DECIMAL)
					.addScalar("qtdPgAVista", Hibernate.INTEGER)
					.addScalar("qtdPgParc", Hibernate.INTEGER)
					.addScalar("vlPgAVista", Hibernate.BIG_DECIMAL)
					.addScalar("vlPgParc", Hibernate.BIG_DECIMAL)
					.addScalar("valorDesconto", Hibernate.BIG_DECIMAL)
					.addScalar("empresa", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1186] Gerar Relat?rio Ordem de Servi?o Cobran?a p/Resultado
	 * 
	 * Pesquisar Valor enviado e quantidade de contas enviadas na cobranca por
	 * Resultado
	 * 
	 * @author R?mulo Aur?lio
	 * @data 24/10/2011
	 */

	public Collection obterValorEnviadoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum (coalesce(conta.CNTA_VLAGUA,0) + coalesce(conta.CNTA_VLESGOTO,0) + coalesce(conta.CNTA_VLDEBITOS,0) "
					+ "- coalesce(conta.CNTA_VLCREDITOS,0) - coalesce(conta.CNTA_VLIMPOSTOS,0)) as valorTotal, "
					+ "count (distinct conta.cnta_id) as qtdeContas, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta conta on conta.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";
			consulta += "group by emprc.imov_id ";

			consulta += "union select sum (coalesce(contaHistorico.cnhi_vlagua,0) + coalesce(contaHistorico.cnhi_vlesgoto,0) "
					+ "+ coalesce(contaHistorico.cnhi_vldebitos,0) - coalesce(contaHistorico.cnhi_vlcreditos,0) - coalesce(contaHistorico.cnhi_vlimpostos,0)) as valorTotal, "
					+ "count (distinct contaHistorico.cnta_id) as qtdeContas, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta_historico contaHistorico on contaHistorico.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			consulta += "group by emprc.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.addScalar("qtdeContas", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relat?rio Ordem de Servi?o Cobran?a p/Resultado
	 * 
	 * Pesquisar Valor Pago e quantidade de contas Pagas na cobranca por
	 * Resultado
	 * 
	 * @author R?mulo Aur?lio
	 * @data 24/10/2011
	 */

	public Collection obterValorPagoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum(coalesce(pgmt.pgmt_vlpagamento,0) + coalesce(pghi.pghi_vlpagamento,0)) as valorPago, "
					+ "count (pgmt.pgmt_id) + count(pghi.pghi_id) as qtdecontaspagas  "
					+ "from cobranca.empresa_cobranca_conta emprc  "
					+ "left join arrecadacao.pagamento pgmt on  pgmt.cnta_id = emprc.cnta_id "
					+ "left join arrecadacao.pagamento_historico pghi on pghi.cnta_id = emprc.cnta_id "
					+ "where emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorPago", Hibernate.BIG_DECIMAL)
					.addScalar("qtdecontaspagas", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1186] Gerar Relat?rio Ordem de Servi?o Cobran?a p/Resultado
	 * 
	 * Pesquisar Valor Parcelado na cobranca por Resultado
	 * 
	 * @author R?mulo Aur?lio
	 * @data 24/10/2011
	 */

	public Collection obterValorParceladoCobrancaPorResultado(OrdemServico os)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection retorno = null;

		try {
			consulta = "select sum (coalesce(conta.CNTA_VLAGUA,0) + coalesce(conta.CNTA_VLESGOTO,0) + coalesce(conta.CNTA_VLDEBITOS,0) "
					+ "- coalesce(conta.CNTA_VLCREDITOS,0) - coalesce(conta.CNTA_VLIMPOSTOS,0)) as valorTotal, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta conta on conta.cnta_id = emprc.cnta_id "
					+ "where conta.dcst_idatual = 5 and emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";
			consulta += "group by emprc.imov_id ";

			consulta += "union select sum (coalesce(contaHistorico.cnhi_vlagua,0) + coalesce(contaHistorico.cnhi_vlesgoto,0) "
					+ "+ coalesce(contaHistorico.cnhi_vldebitos,0) - coalesce(contaHistorico.cnhi_vlcreditos,0) - coalesce(contaHistorico.cnhi_vlimpostos,0)) as valorTotal, "
					+ "emprc.imov_id as imovel "
					+ "from cobranca.empresa_cobranca_conta emprc "
					+ "inner join faturamento.conta_historico contaHistorico on contaHistorico.cnta_id = emprc.cnta_id "
					+ "where contaHistorico.dcst_idatual = 5 and emprc.imov_id = :imovelId and "
					+ "emprc.orse_id = :idOrdemServico ";

			consulta += "group by emprc.imov_id";

			retorno = session.createSQLQuery(consulta)
					.addScalar("valorTotal", Hibernate.BIG_DECIMAL)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("imovelId", os.getImovel().getId())
					.setInteger("idOrdemServico", os.getId()).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1156] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * [SB0005] - Obter Motivo de Encerramento da A??o de Cobran?a
	 * 
	 * 1. Seleciona os motivos de encerramento da a??o de cobran?a
	 * 
	 * @author Mariana Victor
	 * @date 26/10/2011
	 */
	public Collection<AtendimentoMotivoEncerramento> selecionaMotivosEncerramentoAcaoCobranca(
			Integer idAcaoCobranca) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Collection<AtendimentoMotivoEncerramento> retorno = null;
		Collection<Object[]> colecaoDados = null;

		try {
			consulta = "select amen.amen_id AS idAtendMotEnc, "
					+ " amen.amen_dsmotivoencerramento AS descricao "
					+ " from atendimentopublico.atend_motivo_encmt amen "
					+ "   inner join atendimentopublico.atend_mot_enc_acao_cobr amea "
					+ "     on (amea.amen_id = amen.amen_id and amea.cbac_id = :idAcaoCobranca) "
					+ " where amea.amea_icexibedocumento = :indicadorExibeDocConsta "
					+ " order by amen.amen_dsmotivoencerramento ";

			colecaoDados = session
					.createSQLQuery(consulta)
					.addScalar("idAtendMotEnc", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					.setInteger("indicadorExibeDocConsta",
							ConstantesSistema.SIM).list();

			if (colecaoDados != null && !colecaoDados.isEmpty()) {
				retorno = new ArrayList<AtendimentoMotivoEncerramento>();
				Iterator<Object[]> iterator = colecaoDados.iterator();

				while (iterator.hasNext()) {
					Object[] dados = (Object[]) iterator.next();

					AtendimentoMotivoEncerramento atendimentoMotivoEncerramento = new AtendimentoMotivoEncerramento();
					atendimentoMotivoEncerramento.setId((Integer) dados[0]);
					atendimentoMotivoEncerramento
							.setDescricao((String) dados[1]);

					retorno.add(atendimentoMotivoEncerramento);
				}
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1156] Emitir Documentos de Cobran?a Em Lote
	 * 
	 * M?todo que pesquisa o endere?o da unidade de negocio a partir da
	 * localidade do imovel
	 * 
	 * @author Raimundo Martins
	 * @return id da localidade da unidade de negocio
	 * */

	public Integer obterEnderecoUnNegocioLocalImovel(Integer idLocalidadeImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "select loca_cdelo from cadastro.localidade where loca_id = :idLocalidadeImovel";

			return (Integer) session.createSQLQuery(consulta)
					.addScalar("loca_cdelo", Hibernate.INTEGER)
					.setInteger("idLocalidadeImovel", idLocalidadeImovel)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0243] Inserir Comando de A??o de Cobran?a
	 * 
	 * @author Raphael Rossiter
	 * @date 21/10/2011
	 * 
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeRotasPorGrupoCobranca(
			Integer idGrupoCobranca) throws ErroRepositorioException {

		Integer retorno = 0;
		Collection<Integer> rotas = new ArrayList();
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "select distinct(rota.id) "
					+ "from Rota rota "
					+ "inner join rota.cobrancaGrupo cbgr "
					+ "where cbgr.id = :idCobrancaGrupo and rota.indicadorUso = :indicadorUso ";

			rotas = session
					.createQuery(consulta)
					.setInteger("idCobrancaGrupo", idGrupoCobranca)
					.setShort("indicadorUso",
							ConstantesSistema.INDICADOR_USO_ATIVO).list();

			if (rotas != null && !rotas.isEmpty()) {
				retorno = rotas.size();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0214] Inserir A??o de Cobran?a
	 * 
	 * @author Raphael Rossiter
	 * @created 07/11/2011
	 * 
	 * @param idCobrancaAcao
	 * @param textoPersonalizado
	 * @throws ErroRepositorioException
	 */
	public void atualizarCobrancaAcaoTextoPersonalizado(Integer idCobrancaAcao,
			String textoPersonalizado) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String update;
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			update = "UPDATE cobranca.cobranca_acao SET cbac_dstextopersonalizado = ? "
					+ "WHERE cbac_id = ? ";

			st = jdbcCon.prepareStatement(update);
			st.setString(1, textoPersonalizado);
			st.setInt(2, idCobrancaAcao);

			st.executeUpdate();

			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0214] Consultar Comando de A??o de Cobran?a
	 * 
	 * @author Erivan Sousa
	 * @date 04/11/2011
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public String buscarTextoPersonalizadoAcaoCobranca(Integer idAcaoCobranca)
			throws ErroRepositorioException {
		StringBuilder builder = new StringBuilder();
		String retorno = "";
		Collection col = null;
		Session session = HibernateUtil.getSession();

		builder.append("SELECT cbac_dstextopersonalizado ");
		builder.append("FROM cobranca.cobranca_acao ");
		builder.append("WHERE cbac_id = :idAcaoCobranca");

		try {
			col = session.createSQLQuery(builder.toString())
					.addScalar("cbac_dstextopersonalizado", Hibernate.STRING)
					.setInteger("idAcaoCobranca", idAcaoCobranca).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		if (col != null && !col.isEmpty()) {
			retorno = (String) col.iterator().next();
		}

		return retorno;
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a Metodo que remove
	 * contas canceladas associadas a comandos de cobran?a no mes de arrecada??o
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 **/
	public void removerContasCanceladasMesAssocComandosCobranca(
			Integer anoMesArrecadacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaContaCobrancaCancelada empresa WHERE empresa.amRefArrecadacao = :anoMes";
			session.createQuery(sql).setInteger("anoMes", anoMesArrecadacao)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC120] Gerar Boletim de Cobran?a por Resultado
	 * 
	 * M?todo que remove os dados para a gera??o do boletim de cobran?a por
	 * resultado a partir do mes de arrecada??o
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 * */
	public void removerDadosBoletimCobrancaResultado(Integer anoMesArrecadacao)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaCobrancaContaBoletimMedicao boletim WHERE boletim.anoMesReferenciaConta = :anoMes";
			session.createQuery(sql).setInteger("anoMes", anoMesArrecadacao)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobran?a
	 * 
	 * M?todo que pesquisa o comando a partir do ID de EmpresaCobrancaConta
	 * 
	 * @author Raimundo Martins
	 * @date 28/10/2011
	 * */

	public ComandoEmpresaCobrancaConta pesquisarComandoEmpresaCobrancaContaPorEmpresaCobrancaConta(
			Integer idEmpresaCobrancaConta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "SELECT ecc.comandoEmpresaCobrancaConta FROM EmpresaCobrancaConta ecc WHERE ecc.id = :idEmpresaCobrancaConta ";
			return (ComandoEmpresaCobrancaConta) session
					.createQuery(hql)
					.setInteger("idEmpresaCobrancaConta",
							idEmpresaCobrancaConta).uniqueResult();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * [SB0003] - Gerar Atividade de A??o de Cobran?a o Im?vel
	 * 
	 * 2.3.1. Caso exista a??o de cobran?a para o motivo de encerramento
	 * 
	 * @author Mariana Victor
	 * @date 28/10/2011
	 */
	public boolean existeCobrancaAcaoMotivoEncerramento(
			Integer idAcaoCobrancaPrecedente) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Integer quantidade = null;
		boolean retorno = false;

		try {
			consulta = "select count(*) AS quantidade "
					+ " from atendimentopublico.atend_mot_enc_acao_cobr "
					+ " where cbac_id = :idAcaoCobrancaPrecedente ";

			quantidade = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idAcaoCobrancaPrecedente",
							idAcaoCobrancaPrecedente).setMaxResults(1)
					.uniqueResult();

			if (quantidade != null && quantidade > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0251] Gerar Atividade de A??o de Cobran?a
	 * 
	 * [SB0003] - Gerar Atividade de A??o de Cobran?a o Im?vel
	 * 
	 * 2.3.1.1. Caso n?o exista ordem de servi?o, relativa ? a??o precedente,
	 * realizada at? a data m?nima de emiss?o/realiza??o da a??o precedente
	 * 
	 * @author Mariana Victor
	 * @date 28/10/2011
	 */
	public Integer documentoCobrancaOrdemServicoAcaoPrecedente(
			Integer idImovel, Integer idServicoTipo, Date dataEncerramento,
			Integer idAcaoPrecedente) throws ErroRepositorioException {

		Integer retorno = null;
		// Query
		String consulta;
		// obt?m a sess?o
		Session session = HibernateUtil.getSession();

		try {
			consulta = "select orse.cbdo_id AS idDocCob "
					+ " from atendimentopublico.ordem_servico orse "
					+ "  inner join atendimentopublico.servico_tipo svtp on svtp.svtp_id = orse.svtp_id "
					+ "  inner join cadastro.imovel imov on imov.imov_id = orse.imov_id "
					+ "  inner join atendimentopublico.atend_mot_enc_acao_cobr amea on amea.amen_id = orse.amen_id "
					+ " where orse.orse_tmencerramento is not null "
					+ "  and imov.imov_id = :idImovel and svtp.svtp_id = :idServicoTipo  "
					+ "  and orse.orse_tmencerramento <= :dataEncerramento "
					+ "  and amea.cbac_id = :idAcaoPrecedente and amea.amea_icgerasucessor = :icGeraSucessor ";

			retorno = (Integer) session.createSQLQuery(consulta)
					.addScalar("idDocCob", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idServicoTipo", idServicoTipo)
					.setInteger("idAcaoPrecedente", idAcaoPrecedente)
					.setDate("dataEncerramento", dataEncerramento)
					.setInteger("icGeraSucessor", ConstantesSistema.SIM)
					.setMaxResults(1).uniqueResult();

			// erro no hibernate
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1238] Gerar Relat?rio de Acompanhamento dos Comandos de Cobran?a
	 * 
	 * Pesquisa a quantidade de comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Integer pesquisarQuantidadeComandosContasCobrancaEmpresa(
			Integer idEmpresa, Date cicloInicial, Date cicloFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "select "
					+ " count(comandoEmpresaCobrancaConta) " // 1
					+ "from ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta "
					+ "where comandoEmpresaCobrancaConta.empresa.id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta
						+ " and "
						+ "  comandoEmpresaCobrancaConta.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1238] Gerar Relat?rio de Acompanhamento dos Comandos de Cobran?a
	 * 
	 * Pesquisa os dados dos comandos
	 * 
	 * @author: Mariana Victor
	 * @date: 04/05/2011
	 */
	public Collection<Object[]> pesquisarTotalizacaoComandoContasCobrancaEmpresa(
			List<EmpresaCobrancaFaixa> colecaoEmpresaCobrancaFaixa,
			Integer idEmpresa, Date cicloInicial, Date cicloFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {
			consulta = "select count(distinct ecco.cnta_id) AS quantidadeContas, " // 0
					+ "   count(distinct ecco.imov_id) AS quantidadeClientes, " // 1
					+ "   sum(ecco.ecco_vloriginalconta) AS valorOriginal, " // 2
					+ "   ecco.cecc_id AS comando, " // 3
					+ "   cecc.cecc_dtexecucao AS dataExecucao, " // 4
					+ "   cecc.cecc_dtiniciociclo AS dataInicio, " // 5
					+ "   cecc.cecc_dtfimciclo AS dataFim, " // 6
					+ "   emcf.emcf_id AS faixa, " // 7
					+ "   emcf.emcf_dsfaixa AS descricaoFaixa " // 8
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ "   inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ "   inner join cadastro.empr_cobr_faixa emcf on emcf.emcf_pcfaixa = ecco.ecco_pcempresaconta "
					+ " where cecc.empr_id = :idEmpresa ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta + " and "
						+ "  cecc.cecc_dtexecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + "   and exists "
					+ "    (select eccc.imov_id "
					+ "      from cobranca.empresa_cobranca_conta eccc "
					+ "      where eccc.imov_id = ecco.imov_id "
					+ "       and ecco.cecc_id = eccc.cecc_id "
					+ "      group by eccc.imov_id " + "      having ";

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
					.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa
					.getNumeroMinimoContasFaixa() - 1;

			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
						.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa
							.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {

					consulta = consulta
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					consulta = consulta
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) >= " + numeroMinimoContas;

				}
			}

			consulta = consulta
					+ " ) "
					+ " GROUP BY ecco.cecc_id, cecc.cecc_dtexecucao, cecc.cecc_dtiniciociclo, "
					+ "   cecc.cecc_dtfimciclo, emcf.emcf_id, emcf.emcf_dsfaixa";

			retorno = session.createSQLQuery(consulta)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.addScalar("quantidadeClientes", Hibernate.INTEGER)
					.addScalar("valorOriginal", Hibernate.BIG_DECIMAL)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("dataExecucao", Hibernate.DATE)
					.addScalar("dataInicio", Hibernate.DATE)
					.addScalar("dataFim", Hibernate.DATE)
					.addScalar("faixa", Hibernate.INTEGER)
					.addScalar("descricaoFaixa", Hibernate.STRING)
					.setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1153] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Cobran?a
	 * 
	 * Met?do que pesquisa as a??es de penalidade a partir do grupo e o m?s de
	 * referencia
	 * 
	 * @author Raimundo Martins
	 * 
	 * @date 10/11/2011
	 */

	public Collection<Object[]> pesquisarAcoesPenalidadesPorGrupoMes(
			Integer idGrupo, Integer anoMes) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = " select cbac.cbac_id as idAcao, cbac.cbac_dscobrancaacao as acao"
					+ " from cobranca.cobranca_acao cbac "
					+ " inner join cobranca.cobranca_acao_cronograma cbgr on cbac.cbac_id = cbgr.cbac_id "
					+ " inner join cobranca.cobranca_grupo_crg_mes  cbcm on cbcm.cbcm_id = cbgr.cbcm_id "
					+ " where cbcm.cbgr_id = :idGrupo "
					+ " and cbcm.cbcm_amreferencia = :anoMes "
					+ " order by cbac.cbac_id";
			return session.createSQLQuery(sql)
					.addScalar("idAcao", Hibernate.INTEGER)
					.addScalar("acao", Hibernate.STRING)
					.setInteger("idGrupo", idGrupo)
					.setInteger("anoMes", anoMes).list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1153] Solicitar Gera??o / Emiss?o Boletim de Medi??o
	 * 
	 * Metodo que retorna a CobrancaA??oCronograma a partir da A??o, Ano/Mes e
	 * Grupo de a??o de cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public CobrancaAcaoCronograma pesquisarCobrancaAcaoCronograma(
			Integer idGrupo, Integer anoMes, Integer idAcaoCobranca)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "select cbgr "
					+ "from CobrancaAcaoCronograma cbgr "
					+ "inner join cbgr.cobrancaAcao cbac "
					+ "inner join cbgr.cobrancaGrupoCronogramaMes cbcm "
					+ "where cbac.id = :idAcaoCobranca "
					+ "and cbcm.anoMesReferencia = :anoMes "
					+ "and cbcm.cobrancaGrupo.id = :idGrupo";

			return (CobrancaAcaoCronograma) session.createQuery(consulta)
					.setInteger("idAcaoCobranca", idAcaoCobranca)
					.setInteger("anoMes", anoMes)
					.setInteger("idGrupo", idGrupo).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1151] Gerar Boletim Medi??o
	 * 
	 * Metodo que pesquisa as justificativas de n?o penalidades para o grupo de
	 * cobran?a a partir do ano / m?s informado
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public Collection<Integer> pesquisarNaoPenalidades(Integer idGrupo,
			Integer anoMes) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select bmpj_id as id "
					+ " from cobranca.bol_med_ac_pen_just where cbcr_id in ( select cbgr.cbcr_id from cobranca.cobranca_acao cbac "
					+ " inner join cobranca.cobranca_acao_cronograma cbgr on cbac.cbac_id = cbgr.cbac_id "
					+ " inner join cobranca.cobranca_grupo_crg_mes  cbcm on cbcm.cbcm_id = cbgr.cbcm_id "
					+ " where cbcm.cbcm_amreferencia = :anoMes and cbcm.cbgr_id = :idGrupo) ";
			return (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("anoMes", anoMes)
					.setInteger("idGrupo", idGrupo).list();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1151] Gerar Boletim Medi??o
	 * 
	 * Metodo que atualiza a tabela cobranca.bol_med_ac_pen_just inserindo o id
	 * do boletim gerado para as justificativas de n?o penalidades geradas para
	 * um grupo de cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 17/11/2011
	 * */
	public void atualizarBoletimGeradoEmBolMedAcPenJust(Integer idBmpj,
			Integer idBoletimGerado) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {

			String sql = "UPDATE BoletimMedicaoJustificativaPenalidade "
					+ "SET cobm_id = :idBoletimGerado, bmpj_tmultimaalteracao = :data "
					+ "WHERE bmpj_id = :idBmpj";
			session.createQuery(sql)
					.setInteger("idBoletimGerado", idBoletimGerado)
					.setDate("data", new Date()).setInteger("idBmpj", idBmpj)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1152] Emitir Boletim Medi??o Cobran?a
	 * 
	 * Metodo que pesquisa a justificativa da penalidade de um boletim de
	 * medi??o
	 * 
	 * @author Raimundo Martins
	 * @date 22/11/2011
	 * */
	public BoletimMedicaoJustificativaPenalidade pesquisarBoletimMedicaoJustificativaPenalidade(
			Integer idBoletim) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "select bol from BoletimMedicaoJustificativaPenalidade bol "
					+ " inner join fetch bol.cobrancaAcaoCronograma acaoCrono "
					+ " inner join fetch acaoCrono.cobrancaAcao acao"
					+ " where bol.id = :idBoletim ";
			return (BoletimMedicaoJustificativaPenalidade) session
					.createQuery(hql).setInteger("idBoletim", idBoletim)
					.uniqueResult();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * 1.5.1. O usu?rio informa o filtro e ao clicar no bot?o "Selecionar" o
	 * sistema dever? exibir, em uma tabela, todos os boletins de medi??o
	 * 
	 * @author Mariana Victor
	 * @date 21/11/2011
	 * */
	public Collection<Object[]> pesquisarBoletimMedicaoContrato(
			Integer idContrato, Integer anoMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = "select cobm.cobm_amreferencia AS anoMesRef, "
					+ "  cobm.cobm_id AS idCobrancaGrupo,  "
					+ "  cbgr.cbgr_dscobrancagrupo AS cobrancaGrupo "
					+ " from cobranca.cobr_boletim_medicao cobm "
					+ " inner join cobranca.cobranca_grupo cbgr on cbgr.cbgr_id = cobm.cbgr_id ";

			if (anoMes != null) {
				sql = sql + " where cobm.cobm_amreferencia = :anoMes ";
			}

			sql = sql + "  and cobm.cobc_id is null "
					+ "  and cbgr.cese_id = :idContrato "
					+ " order by cbgr.cbgr_dscobrancagrupo ";

			Query query = session.createSQLQuery(sql)
					.addScalar("anoMesRef", Hibernate.INTEGER)
					.addScalar("idCobrancaGrupo", Hibernate.INTEGER)
					.addScalar("cobrancaGrupo", Hibernate.STRING)
					.setInteger("idContrato", idContrato);

			if (anoMes != null) {
				query = query.setInteger("anoMes", anoMes);
			}

			return (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0001] - Gerar Boletim Medi??o de Contrato
	 * 
	 * 2. E, para cada boletim de medi??o selecionado, atualiza os dados da
	 * tabela COBR_BOLETIM_MEDICAO:
	 * 
	 * @author Mariana Victor
	 * @data 21/11/2011
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarBoletimMedicaoCobranca(String[] idsBoletim,
			Integer idCobrancaBoletimContrato) throws ErroRepositorioException {

		String consulta;
		Session session = HibernateUtil.getSession();

		try {
			consulta = "update gcom.cobranca.CobrancaBoletimMedicao "
					+ " set cobc_id = :idCobrancaBoletimContrato, cobm_tmultimaalteracao = :ultimaAlteracao "
					+ " where cobm_id in (:idsBoletim) ";

			session.createQuery(consulta)
					.setInteger("idCobrancaBoletimContrato",
							idCobrancaBoletimContrato)
					.setTimestamp("ultimaAlteracao", new Date())
					.setParameterList("idsBoletim", idsBoletim).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> filtrarRelatorioAcompanhamentoBoletimMedicaoContrato(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = " SELECT itensServico.idItemServico, "// 0 - ID
																	// Item
																	// Servi?o
					+ "  itensServico.descricaoServico, "// 1 - Descri??o Item
															// Servi?o
					+ "  itensServico.quantidadeOrcada, "// 2 - Quantidade
															// Or?ada
					+ "  itensServico.valorUnitario, "// 3 - Valor Unit?rio
					+ "  sum(itensServico.quantidade) as quantidadeItem, "// 4 -
																			// Quantidade
																			// do
																			// Item
					+ "  (itensServico.valorUnitario * sum(itensServico.quantidade)) as valorItem, "// 5
																									// -
																									// Valor
																									// Item
					+ "  itensServico.unidadeItem, "// 6 - Unidade do Item
					+ "  itensServico.valorOrcado, "// 7 - Valor Orcado
					+ "  sum(itensServico.valorMedidoPeriodo) AS valorMedidoPeriodo "// 8
																						// -
																						// Valor
																						// medido
																						// no
																						// per?odo
					+ " FROM (SELECT "
					+ "    itse.itse_id AS idItemServico, "
					+ "    itse.itse_dsitemservico AS descricaoServico, "
					+ "    itsc.itsc_qtorcadaitemservico AS quantidadeOrcada, "
					+ "    1 AS quantidade, "
					+ "    itsc.itsc_vlitemservcontr AS valorUnitario, "
					+ "    (CASE WHEN itse.itse_cdconstantecalculo IN (3, 7, 9, 11, 13, 4, 8, 10, 12, 14) THEN 'UND' "
					+ "      WHEN itse.itse_cdconstantecalculo IN (15, 16, 17) THEN 'M2' "
					+ "      ELSE '' END) AS unidadeItem, "
					+ "    itsc.itsc_vlorcadoitemservico AS valorOrcado, "
					+ "    cbex.cbex_vlservico AS valorMedidoPeriodo "
					+ "   FROM cobranca.cobr_boletim_exec cbex "
					+ "    INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id) "
					+ "    INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id AND cobc.cobc_id = :idBoletimContrato) "
					+ "    INNER JOIN micromedicao.contrato_empresa_servico cese ON (cobc.cese_id = cese.cese_id AND cese.cese_id = :idContrato) "
					+ "    INNER JOIN atendimentopublico.ordem_servico orse ON (cbex.orse_id = orse.orse_id) "
					+ "    INNER JOIN micromedicao.item_servico_contrato itsc ON (cese.cese_id = itsc.cese_id AND orse.svtp_id = itsc.svtp_id) "
					+ "    INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id) "
					+ "    LEFT OUTER JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id) "
					+ "   WHERE (itse.itse_cdconstantecalculo IN (2,6) AND orbo.orbo_icpavimento = 3) "
					+ "    OR (itse.itse_cdconstantecalculo IN (3,7,9,11,13) AND orbo.orbo_icpavimento = 2) "
					+ "    OR (itse.itse_cdconstantecalculo IN (4,8,10,12,14) AND orbo.orbo_icpavimento = 1) "
					+ "    OR (itse.itse_cdconstantecalculo IN (1,5) OR itse.itse_cdconstantecalculo > 14) "
					+ "   ORDER BY idItemServico) itensServico "
					+ "   GROUP BY idItemServico, descricaoServico, quantidadeOrcada, valorUnitario, unidadeItem, valorOrcado "
					+ " ORDER BY idItemServico ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricaoServico", Hibernate.STRING)
					.addScalar("quantidadeOrcada", Hibernate.BIG_DECIMAL)
					.addScalar("valorUnitario", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeItem", Hibernate.INTEGER)
					.addScalar("valorItem", Hibernate.BIG_DECIMAL)
					.addScalar("unidadeItem", Hibernate.STRING)
					.addScalar("valorOrcado", Hibernate.BIG_DECIMAL)
					.addScalar("valorMedidoPeriodo", Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * M?todo que vai retornar as quantidades acumuladas e os valores acumulados
	 * no per?odo para gera??o do relat?rio de acompanhamento do boletim de
	 * medi??o de cobran?a.
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoAcumuladas(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "SELECT itensServico.idItemServico, "// 0 - ID
																	// Item
																	// Servi?o
					+ "   itensServico.descricaoServico, "// 1 - Descri??o Item
															// Servi?o
					+ "   sum(itensServico.quantidade) as quantidadeAcumuladaPeriodo, "// 2
																						// -
																						// Quantidade
																						// Acumulada
																						// Per?odo
					+ "   sum(itensServico.valorMedidoPeriodo) AS valorAcumuladoPeriodo "// 3
																							// -
																							// Valor
																							// Acumulado
																							// Per?odo
					+ " FROM (SELECT "
					+ "      itse.itse_id AS idItemServico, "
					+ "      itse.itse_dsitemservico AS descricaoServico, "
					+ "      1 AS quantidade, "
					+ "      cbex.cbex_vlservico AS valorMedidoPeriodo "
					+ "     FROM cobranca.cobr_boletim_exec cbex "
					+ "      INNER JOIN cobranca.cobr_boletim_medicao cobm ON (cbex.cobm_id = cobm.cobm_id) "
					+ "      INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id) "
					+ "      INNER JOIN micromedicao.contrato_empresa_servico cese ON (cobc.cese_id = cese.cese_id AND cese.cese_id = :idContrato) "
					+ "      INNER JOIN atendimentopublico.ordem_servico orse ON (cbex.orse_id = orse.orse_id) "
					+ "      INNER JOIN micromedicao.item_servico_contrato itsc ON (cese.cese_id = itsc.cese_id AND orse.svtp_id = itsc.svtp_id) "
					+ "      INNER JOIN micromedicao.item_servico itse ON (itsc.itse_id = itse.itse_id) "
					+ "      LEFT OUTER JOIN atendimentopublico.ordem_servico_boletim orbo ON (cbex.orse_id = orbo.orse_id) "
					+ "     WHERE (itse.itse_cdconstantecalculo IN (2,6) AND orbo.orbo_icpavimento = 3) "
					+ "      OR (itse.itse_cdconstantecalculo IN (3,7,9,11,13) AND orbo.orbo_icpavimento = 2) "
					+ "      OR (itse.itse_cdconstantecalculo IN (4,8,10,12,14) AND orbo.orbo_icpavimento = 1) "
					+ "      OR (itse.itse_cdconstantecalculo IN (1,5) OR itse.itse_cdconstantecalculo > 14) "
					+ "     ORDER BY idItemServico) itensServico "
					+ " GROUP BY idItemServico, descricaoServico "
					+ " ORDER BY idItemServico ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idItemServico", Hibernate.INTEGER)
					.addScalar("descricaoServico", Hibernate.STRING)
					.addScalar("quantidadeAcumuladaPeriodo", Hibernate.INTEGER)
					.addScalar("valorAcumuladoPeriodo", Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarTaxaSucessoBoletimMedicaoContrato(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		BigDecimal taxaSucesso = new BigDecimal("0.00");

		try {
			String consulta = " SELECT sum(cbsu.CBSU_VLTXSUCESSO) AS taxaSucesso "
					+ " FROM cobranca.COBR_BOLETIM_SUCESSO cbsu "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbsu.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) ";

			taxaSucesso = (BigDecimal) session
					.createSQLQuery(consulta)
					.addScalar("taxaSucesso", Hibernate.BIG_DECIMAL)
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato())
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return taxaSucesso;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	public Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidades(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {
		Collection<BigDecimal> relatorios = null;
		try {
			relatorios = this
					.filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesOSFiscalizacao(filtro);
			relatorios
					.addAll(this
							.filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesCorteSupressaoNaoRealizacaoServico(filtro));
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		}
		return relatorios;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	private Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesOSFiscalizacao(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> relatorios = new ArrayList<Object[]>();
		Collection<BigDecimal> retorno = new ArrayList<BigDecimal>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "SELECT "
					+ "   SUM((SELECT cbde.cbde_vldesconto "
					+ "      FROM atendimentopublico.ordem_servico orse "
					+ "      WHERE orse.orse_id = cbde.orse_id AND orse.amen_id = 32)) AS penalidadeOS, "// 0
																											// -
																											// Penalidade
																											// OS
					+ "   SUM((SELECT cbde.cbde_vldesconto "
					+ "      FROM atendimentopublico.ordem_servico orse "
					+ "      WHERE orse.orse_id = cbde.orse_id AND orse.amen_id != 32)) AS penalidadeFiscalizacao "// 0
																													// -
																													// Penalidade
																													// Fiscaliza??o
					+ " FROM cobranca.COBR_BOLETIM_DESC cbde "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbde.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.CONTRATO_EMPRESA_SERVICO cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) ";

			relatorios = session
					.createSQLQuery(consulta)
					.addScalar("penalidadeOS", Hibernate.BIG_DECIMAL)
					.addScalar("penalidadeFiscalizacao", Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

			Object[] penalidades = relatorios.iterator().next();
			BigDecimal penalidadeOS = new BigDecimal("0.00");
			if (penalidades[0] != null) {
				penalidadeOS = (BigDecimal) penalidades[0];
			}
			BigDecimal penalidadeFiscalizacao = new BigDecimal("0.00");
			if (penalidades[1] != null) {
				penalidadeFiscalizacao = (BigDecimal) penalidades[1];
			}
			retorno.add(penalidadeOS);
			retorno.add(penalidadeFiscalizacao);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * [SB0002] - Emitir Boletim de Contrato
	 * 
	 * @author Mariana Victor
	 * @date 22/11/2011
	 * 
	 * @param FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper
	 * 
	 * @return Collection<BigDecimal>
	 * @throws ErroRepositorioException
	 */
	private Collection<BigDecimal> filtrarRelatorioAcompanhamentoBoletimMedicaoContratoPenalidadesCorteSupressaoNaoRealizacaoServico(
			FiltrarRelatorioAcompanhamentoBoletimMedicaoHelper filtro)
			throws ErroRepositorioException {

		Collection<Object[]> relatorios = new ArrayList<Object[]>();
		Collection<BigDecimal> retorno = new ArrayList<BigDecimal>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "SELECT "
					+ "   SUM((SELECT (cbex.cbex_vlservico) * 2 "
					+ "        FROM cobranca.motivo_nao_aceit_enc_os mnac "
					+ "        WHERE caon.mnac_id = mnac.mnac_id and mnac.mnac_nnmultdesccortesupindev IS NOT NULL)) AS penalidadeCorteSupressao, "
					+ "   SUM((SELECT (cbex.cbex_vlservico) * 2 "
					+ "        FROM cobranca.motivo_nao_aceit_enc_os mnac "
					+ "        WHERE caon.mnac_id = mnac.mnac_id and mnac.mnac_nnmultdescservnaoexec IS NOT NULL)) AS penalidadeNaoRealizacaoServico "
					+ " FROM cobranca.cobr_boletim_exec cbex "
					+ "   INNER JOIN cobranca.cobr_boletim_medicao cobm on (cbex.cobm_id = cobm.cobm_id) "
					+ "   INNER JOIN cobranca.cobr_boletim_contrato cobc ON (cobc.cobc_id = cobm.cobc_id and cobc.cobc_id = :idBoletimContrato) "
					+ "   INNER JOIN micromedicao.contrato_empresa_servico cese on (cobc.cese_id = cese.cese_id and cese.cese_id = :idContrato) "
					+ "   INNER JOIN cobranca.cob_ac_os_nao_aceitas caon on (cbex.orse_id = caon.orse_id) ";

			relatorios = session
					.createSQLQuery(consulta)
					.addScalar("penalidadeCorteSupressao",
							Hibernate.BIG_DECIMAL)
					.addScalar("penalidadeNaoRealizacaoServico",
							Hibernate.BIG_DECIMAL)
					.setInteger("idContrato",
							filtro.getIdContratoEmpresaServico())
					.setInteger("idBoletimContrato",
							filtro.getIdBoletimContrato()).list();

			Object[] penalidades = relatorios.iterator().next();
			BigDecimal penalidadeCorteSupressao = new BigDecimal("0.00");
			if (penalidades[0] != null) {
				penalidadeCorteSupressao = (BigDecimal) penalidades[0];
			}
			BigDecimal penalidadeNaoRealizacaoServicos = new BigDecimal("0.00");
			if (penalidades[1] != null) {
				penalidadeNaoRealizacaoServicos = (BigDecimal) penalidades[1];
			}
			retorno.add(penalidadeCorteSupressao);
			retorno.add(penalidadeNaoRealizacaoServicos);

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * M?todo que pesquisa se o comando possui setores associados na tabela
	 * cobranca.cmd_empr_cobr_conta_stcm
	 * 
	 * @author Raimundo Martins
	 * @date 02/12/2011
	 * 
	 * */
	public Collection<SetorComercial> pesquisarSetoresComerciaisComandoEmpresaCobrancaContaSetorComercial(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<SetorComercial> retorno = null;
		try {
			String sql = "SELECT cest.setorComercial FROM ComandoEmpresaCobrancaContaSetorComercial cest "
					+ " WHERE cest.comando.id = :idComando";
			retorno = session.createQuery(sql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 23/11/2011
	 */
	public boolean existeParcelamentoQuantidadePrestacaoSituacaoLigacaoAgua(
			Integer idSituacaoLigacaoAgua,
			Integer idParcelamentoQuantidadePrestacao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String consulta;

		Integer quantidade = null;
		boolean retorno = false;

		try {
			consulta = "select pqps.id "
					+ " from ParcelamentoQuantidadePrestacaoSituacaoLigacaoAgua pqps "
					+ " where pqps.ligacaoAguaSituacao.id = :idSituacaoLigacaoAgua and "
					+ " pqps.parcelamentoQuantidadePrestacao.id = :idParcelamentoQuantidadePrestacao ";

			quantidade = (Integer) session
					.createQuery(consulta)
					.setInteger("idSituacaoLigacaoAgua", idSituacaoLigacaoAgua)
					.setInteger("idParcelamentoQuantidadePrestacao",
							idParcelamentoQuantidadePrestacao).setMaxResults(1)
					.uniqueResult();

			if (quantidade != null && quantidade > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * retorna uma colecao de ResolucaoDiretoria
	 * 
	 * [UC0214] - Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 28/11/2011
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ResolucaoDiretoria pesquisarResolucaoDiretoriaPortal()
			throws ErroRepositorioException {

		ResolucaoDiretoria retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where  "
					+ "(rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ "and rd.indicadorParcelamentoLojaVirtual = :indicadorParcelamentoLojaVirtual ";

			retorno = (ResolucaoDiretoria) session
					.createQuery(consulta)
					.setDate("dataAtual", new Date())
					.setShort("indicadorParcelamentoLojaVirtual",
							ConstantesSistema.SIM).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * Verifica a quantidade de boletim de contrato para o m?s/ano
	 * 
	 * @author Mariana Victor
	 * @date 15/12/2011
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadeBoletimMedicaoContrato(Integer idContrato)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		StringBuilder sb = new StringBuilder();
		Integer quantidade = null;

		try {
			String consulta = " select count(*) AS quantidade "
					+ " from cobranca.cobr_boletim_contrato "
					+ " where cobc_amreferencia = :amReferencia "
					+ " and cese_id = :idContrato ";

			quantidade = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("amReferencia",
							Util.recuperaAnoMesDaData(new Date()))
					.setInteger("idContrato", idContrato).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return quantidade;
	}

	/**
	 * [UC1250] Solicitar Gera??o/Emiss?o Boletim de Medi??o de Contratos
	 * 
	 * 1.6.2. O usu?rio informa o filtro e ao clicar no bot?o "Selecionar" o
	 * sistema dever? exibir, em uma tabela, todos os boletins de contrato
	 * 
	 * @author Mariana Victor
	 * @date 16/12/2011
	 * */
	public Collection<Object[]> pesquisarBoletimMedicaoContratoEmitir(
			Integer idContrato, Integer anoMes) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = "select cobc.cobc_amreferencia AS anoMesRef, "
					+ "   cobc.cobc_id AS idBoletim, "
					+ "   cobc.cobc_dsboletimcontrato AS descricaoContrato  "
					+ " from cobranca.cobr_boletim_contrato cobc "
					+ " where cobc.cese_id = :idContrato "
					+ "   and cobc.cobc_amreferencia = :anoMes "
					+ " order by cobc.cobc_dsboletimcontrato ";

			return (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("anoMesRef", Hibernate.INTEGER)
					.addScalar("idBoletim", Hibernate.INTEGER)
					.addScalar("descricaoContrato", Hibernate.STRING)
					.setInteger("idContrato", idContrato)
					.setInteger("anoMes", anoMes).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1257] - Gerar Relat?rio dos Im?veis e Contas Retirados das Empresas de
	 * Cobran?a
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Collection obterRelatorioImoveisRetiradosEmpresasCobranca(
			Integer idEmpresa, int amReferenciaInicial, int amReferenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {
			String sql = " select distinct irc.imov_id as idImovel, "
					+ // 1
					" irc.cecc_id as idComando, "
					+ // 2
					" imov.loca_id as idLocalidade, "
					+ // 3
					" sc.stcm_cdsetorcomercial as codSetorComercial, "
					+ // 4
					" q.qdra_nnquadra as numeroQuadra, "
					+ // 5
					" imov.imov_nnlote as numeroLote, "
					+ // 6
					" imov.imov_nnsublote as numeroSubLote, "
					+ // 7
					" cecc.cecc_dtexecucao as dataExecucao, "
					+ // 8
					" irc.imrc_dtretirada as dataRetirada, "
					+ // 9
					" mrc.mrcb_dsmotivoretirada as motivoRetirada "
					+ // 10
					" from cobranca.imovel_retirada_comando irc "
					+ " inner join cobranca.empresa_cobranca_conta ecc on (irc.imov_id = ecc.imov_id and irc.cecc_id = ecc.cecc_id) "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on (ecc.cecc_id = cecc.cecc_id) "
					+ " inner join cadastro.imovel imov on (irc.imov_id = imov.imov_id) "
					+ " inner join cadastro.setor_comercial sc on (sc.stcm_id = imov.stcm_id) "
					+ " inner join cadastro.quadra q on (q.qdra_id = imov.qdra_id) "
					+ " inner join cadastro.motivo_retirada_cobranca mrc on (mrc.mrcb_id = irc.mrcb_id) "
					+ " where irc.imrc_dtretirada between :amReferenciaInicial and :amReferenciaFinal "
					+ " and cecc.empr_id = :codEmpresa "
					+ " order by irc.imov_id, irc.cecc_id";

			System.out.println(sql);

			retorno = session
					.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					// 1
					.addScalar("idComando", Hibernate.INTEGER)
					// 2
					.addScalar("idLocalidade", Hibernate.INTEGER)
					// 3
					.addScalar("codSetorComercial", Hibernate.INTEGER)
					// 4
					.addScalar("numeroQuadra", Hibernate.INTEGER)
					// 5
					.addScalar("numeroLote", Hibernate.INTEGER)
					// 6
					.addScalar("numeroSubLote", Hibernate.INTEGER)
					// 7
					.addScalar("dataExecucao", Hibernate.DATE)
					// 8
					.addScalar("dataRetirada", Hibernate.DATE)
					// 9
					.addScalar("motivoRetirada", Hibernate.STRING)
					// 10
					.setDate(
							"amReferenciaInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(amReferenciaInicial))
					.setDate(
							"amReferenciaFinal",
							Util.gerarDataApartirAnoMesRefencia(amReferenciaFinal))
					.setInteger("codEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1257] - Gerar Relat?rio dos Im?veis e Contas Retirados das Empresas de
	 * Cobran?a
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Integer obterQtdRelatorioImoveisRetiradosEmpresasCobranca(
			Integer idEmpresa, int amReferenciaInicial, int amReferenciaFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = new Integer(0);

		try {
			String sql = " select count(distinct irc.imov_id) as idImovel "
					+ " from cobranca.imovel_retirada_comando irc "
					+ " inner join cobranca.empresa_cobranca_conta ecc on (irc.imov_id = ecc.imov_id and irc.cecc_id = ecc.cecc_id) "
					+ " inner join cobranca.cmd_empr_cobr_conta cecc on (ecc.cecc_id = cecc.cecc_id) "
					+ " where irc.imrc_dtretirada between :amReferenciaInicial and :amReferenciaFinal "
					+ " and cecc.empr_id = :codEmpresa ";

			retorno = (Integer) session
					.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setDate(
							"amReferenciaInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(amReferenciaInicial))
					.setDate(
							"amReferenciaFinal",
							Util.gerarDataApartirAnoMesRefencia(amReferenciaFinal))
					.setInteger("codEmpresa", idEmpresa).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1257] - Gerar Relat?rio dos Im?veis e Contas Retirados das Empresas de
	 * Cobran?a
	 * 
	 * @author: Hugo Azevedo
	 * @date: 19/12/2011
	 */
	public Collection obterRelatorioContasRetiradasEmpresasCobranca(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {

			String sql = " select "
					+ " ecc.ecco_amreferenciaconta as amreferencia, "
					+ // 1
					" ecc.ecco_vloriginalconta as valorOriginal, "
					+ // 2
					" ecc.ecco_dtenvioconta as dataEnvio, "
					+ // 3
					" ecc.ecco_dtretiradaconta as dataRetirada, "
					+ // 4
					" mrc.mrcb_dsmotivoretirada as motivoRetirada "
					+ // 5
					" from cobranca.empresa_cobranca_conta ecc "
					+ " inner join cadastro.motivo_retirada_cobranca mrc on (mrc.mrcb_id = ecc.mrcb_id) "
					+ " where ecc.imov_id = :idImovel "
					+ " and ecc.cecc_id = :idComando "
					+ " and ecc.ecco_dtretiradaconta is not null "
					+ " order by ecc.ecco_amreferenciaconta";

			retorno = session.createSQLQuery(sql)
					.addScalar("amreferencia", Hibernate.INTEGER)
					// 1
					.addScalar("valorOriginal", Hibernate.BIG_DECIMAL)
					// 2
					.addScalar("dataEnvio", Hibernate.DATE)
					// 3
					.addScalar("dataRetirada", Hibernate.DATE)
					// 4
					.addScalar("motivoRetirada", Hibernate.STRING)
					// 5
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imoveis e COntas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa os comandos que podem ser retirados imoveis e
	 * cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 13/12/2011
	 * */
	public Collection<ComandoEmpresaCobrancaConta> pesquisarDadosRetirarImoveisContasEmpresaCobranca(
			Integer idEmpresa, Date periodoIni, Date periodoFin,
			Integer numPaginas, Integer quantidadeRegistros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ComandoEmpresaCobrancaConta> retorno = null;
		try {
			String hql = "SELECT c FROM ComandoEmpresaCobrancaConta c WHERE c.empresa.id = :idEmpresa "
					+ " AND c.dataExecucao is not null ";
			if (periodoIni != null && periodoFin != null) {
				hql += " AND c.dataExecucao >= :periodoIni AND c.dataExecucao <= :periodoFin";
			}
			hql += " ORDER BY c.id";
			Query q = session.createQuery(hql).setInteger("idEmpresa",
					idEmpresa);
			if (periodoIni != null && periodoFin != null) {
				q.setDate("periodoIni", periodoIni);
				q.setDate("periodoFin", periodoFin);
			}
			/*
			 * if(numPaginas != 0){ retorno =
			 * q.setMaxResults(quantidadeRegistros
			 * ).setFirstResult(numPaginas*quantidadeRegistros).list(); }else{
			 * retorno = q.list(); }
			 */

			retorno = q.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Imoveis e COntas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa a quantidade de contas por comando cujo a data de
	 * retirada seja nula
	 * 
	 * @author Raimundo Martins
	 * @date 13/12/2011
	 * */
	public Integer pesquisarqtdContasPorComandoDtRetiradaComandoNulo(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT ecco.contaGeral.id) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.dataRetiradaConta is null "
					+ " AND ecco.cdIncluido is null";
			retorno = (Integer) session.createQuery(hql)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa a quantidade de comandos que podem ser retirados das
	 * empresas de cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 14/12/2011
	 * */

	public Integer pesquisarDadosRetirarImoveisContasEmpresaCobrancaCount(
			Integer idEmpresa, Date periodoIni, Date periodoFin)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT c.id) FROM ComandoEmpresaCobrancaConta c WHERE c.empresa.id = :idEmpresa "
					+ " AND c.dataExecucao is not null";
			if (periodoIni != null && periodoFin != null) {
				hql += " AND c.dataExecucao >= :periodoIni AND c.dataExecucao <= :periodoFin";
			}
			Query q = session.createQuery(hql).setInteger("idEmpresa",
					idEmpresa);
			if (periodoIni != null && periodoFin != null) {
				q.setDate("periodoIni", periodoIni);
				q.setDate("periodoFin", periodoFin);
			}
			retorno = (Integer) q.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa os im?veis que v?o ser retirados de cobran?a por
	 * empresa a partir do comando
	 * 
	 * @author Raimundo Martins
	 * @date 15/12/2011
	 * */

	public Collection<Imovel> pesquisarImoveisRetirarComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Imovel> retorno = null;
		try {
			String hql = "SELECT distinct ecco.imovel FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.dataRetiradaConta is null AND ecco.cdIncluido is null";
			retorno = session.createQuery(hql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do im?veis que podem ser retirados
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */

	public Collection<Integer> pesquisarContasNaoVencidas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Collection<Integer> retorno = new ArrayList<Integer>();
		retorno.addAll(this.pesquisarContasNaoVencidasEmConta(idComando,
				idImovel));
		retorno.addAll(this.pesquisarContasNaoVencidasEmContaHistorico(
				idComando, idImovel));
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a [SB0004 -
	 * Retirar Conta de Cobran?a]
	 * 
	 * Metodo que retira as contas de cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public void retirarContasDeCobranca(Integer idComando, Integer idConta,
			Integer idMotivoRetirada) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE gcom.cobranca.EmpresaCobrancaConta SET mrcb_id = :idMotivoRetirada, ecco_dtretiradaconta = :dataAtual, "
					+ " ecco_tmultimaalteracao = :dataAtual2 WHERE cecc_id = :idComando and cnta_id = :idConta AND ecco_cdincluido IS NULL";
			session.createQuery(sql).setInteger("idComando", idComando)
					.setInteger("idConta", idConta)
					.setDate("dataAtual", new Date())
					.setTimestamp("dataAtual2", new Date())
					.setInteger("idMotivoRetirada", idMotivoRetirada)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que verifica a quantidade de contas por comando e imovel
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Integer quantidadeContasPorImovelEComando(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT COUNT(distinct ecco.cnta_id) as cont FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando AND ecco.imov_id = :idImovel AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.ecco_cdincluido is null";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("cont", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que verifica se as contas de determinado im?vel est?o pagas ou em
	 * parcelamento
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Collection<Integer> pesquisarContasPagasOuParceladas(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Collection<Integer> retorno = new ArrayList<Integer>();
		retorno.addAll(this.pesquisarContasPagas(idComando, idImovel));
		retorno.addAll(this.pesquisarContasParceladas(idComando, idImovel));
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que verifica se a conta esta paga
	 * 
	 * @author Raimundo Martins
	 * @date 16/12/2011
	 * */
	public Boolean contaPaga(Integer idConta) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT pg.conta as id FROM ("
					+ "	SELECT pgmt.cnta_id as conta FROM arrecadacao.pagamento pgmt "
					+ "	UNION	"
					+ "	SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi"
					+ "	) pg " + " WHERE pg.conta = :idConta";

			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idConta", idConta).uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public Boolean contaParcelada(Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT pcit.cnta_id as id FROM cobranca.parcelamento_item pcit WHERE pcit.cnta_id = :idConta";
			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa a data de envio do im?vel para cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */

	public Date pesquisarDataEnvioImovelCobranca(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Date retorno = null;
		try {
			String hql = "SELECT MIN(ecco.dataEnvioConta) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando AND ecco.imovel.id = :idImovel AND ecco.cdIncluido is null";
			retorno = (Date) session.createQuery(hql)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa a data de envio do im?vel para cobran?a
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */
	public Collection<Integer> pesquisarContasEmpresaCobrancaContaPorImovelComando(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND"
					+ " ecco.ecco_cdincluido is null";
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa a quantidade de imov?is em cobran?a para aquele
	 * comando
	 * 
	 * @author Raimundo Martins
	 * @date 19/12/2011
	 * */
	public Integer pesquisarqtdImoveisPorComandoDtRetiradaComandoNulo(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String hql = "SELECT COUNT(DISTINCT ecco.imovel) FROM EmpresaCobrancaConta ecco "
					+ " WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando "
					+ " AND ecco.cdIncluido is null "
					+ " AND ecco.imovel.id NOT IN (SELECT irc.imovel.id FROM ImovelRetiradaComando irc WHERE irc.comando.id = :idComando)";
			retorno = (Integer) session.createQuery(hql)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do im?veis que podem ser retirados na
	 * tabela conta
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasNaoVencidasEmConta(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_id AS id"
					+ " FROM  faturamento.conta cnta "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on cnta.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ " LEFT JOIN cobranca.cmd_empr_cobr_conta_ext ccce on ccce.ccce_id = ecco.ccce_id "
					+ " WHERE ecco.cecc_id = :idComando "
					+ " AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.imov_id = :idImovel "
					+ " AND ecco.ecco_cdincluido is null"
					+ " AND ("
					+ "	CASE "
					+ "		WHEN ecco.ccce_id is not null and ccce.ccce_nndiasvencimentocontas is not null "
					+ "			THEN "
					+ "			cnta.cnta_dtvencimentoconta > (to_date(:dataAtual,'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas)	"
					+ "		WHEN cecc.cecc_qtddiasvencimento is not null "
					+ "			THEN		"
					+ "			cnta.cnta_dtvencimentoconta > (to_date(:dataAtual,'YYYY-MM-DD') - cecc.cecc_qtddiasvencimento)"
					+ "	END )";
			SimpleDateFormat formatador = new SimpleDateFormat("yyyy-MM-dd");
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setString("dataAtual", formatador.format(new Date()))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a [SB0005 -
	 * Verificar vencimento da conta]
	 * 
	 * Metodo que pesquisa as contas do im?veis que podem ser retirados na
	 * tabela conta historico
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasNaoVencidasEmContaHistorico(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT cnhi.cnta_id AS id"
					+ " FROM  faturamento.conta_historico cnhi "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on cnhi.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ " LEFT JOIN cobranca.cmd_empr_cobr_conta_ext ccce on ccce.ccce_id = ecco.ccce_id "
					+ " WHERE ecco.cecc_id = :idComando "
					+ " AND ecco.ecco_dtretiradaconta is null "
					+ " AND ecco.imov_id = :idImovel "
					+ " AND ecco.ecco_cdincluido is null"
					+ " AND ("
					+ "	CASE "
					+ "		WHEN ecco.ccce_id is not null and ccce.ccce_nndiasvencimentocontas is not null "
					+ "			THEN "
					+ "			cnhi.cnhi_dtvencimentoconta > (to_date(:dataAtual,'YYYY-MM-DD') - ccce.ccce_nndiasvencimentocontas)	"
					+ "		WHEN cecc.cecc_qtddiasvencimento is not null "
					+ "			THEN		"
					+ "			cnhi.cnhi_dtvencimentoconta > (to_date(:dataAtual,'YYYY-MM-DD') - cecc.cecc_qtddiasvencimento)"
					+ "	END )";

			SimpleDateFormat formatador = new SimpleDateFormat("yyyy-MM-dd");
			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setString("dataAtual", formatador.format(new Date()))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa as contas parceladas de determinado imovel
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasParceladas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM cobranca.empresa_cobranca_conta ecco "
					+ " INNER JOIN cobranca.parcelamento_item pcit on pcit.cnta_id = ecco.cnta_id "
					+ " INNER JOIN cobranca.parcelamento parc on parc.parc_id = pcit.parc_id "
					+ " INNER JOIN cobranca.parcelamento_situacao pcst on pcst.pcst_id = parc.pcst_id "
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null AND "
					+ " pcst.pcst_id = :situacaoParcelamento";

			retorno = session
					.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoParcelamento",
							ParcelamentoSituacao.NORMAL).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que pesquisa as contas pagas de determinado imovel
	 * 
	 * @author Raimundo Martins
	 * @date 22/12/2011
	 * */
	private Collection<Integer> pesquisarContasPagas(Integer idComando,
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id as id FROM  arrecadacao.pagamento pgmt "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on ecco.cnta_id = pgmt.cnta_id"
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null ";

			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).list();

			sql = "SELECT ecco.cnta_id as id FROM  arrecadacao.pagamento_historico pghi "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecco on ecco.cnta_id = pghi.cnta_id"
					+ " WHERE ecco.cecc_id = :idComando AND "
					+ " ecco.ecco_dtretiradaconta is null AND "
					+ " ecco.imov_id = :idImovel AND "
					+ " ecco.ecco_cdincluido is null ";

			if (retorno != null && !retorno.isEmpty()) {
				Collection<Integer> retorno2 = session.createSQLQuery(sql)
						.addScalar("id", Hibernate.INTEGER)
						.setInteger("idComando", idComando)
						.setInteger("idImovel", idImovel).list();
				if (retorno2 != null && !retorno2.isEmpty()) {
					for (Integer idConta : retorno2) {
						if (!retorno.contains(idConta)) {
							retorno.add(idConta);
						}
					}
				}
			} else {
				retorno = session.createSQLQuery(sql)
						.addScalar("id", Hibernate.INTEGER)
						.setInteger("idComando", idComando)
						.setInteger("idImovel", idImovel).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a [SB0004 -
	 * Retirar Conta de Cobran?a]
	 * 
	 * Metodo que retira as contas de cobran?a atrav?s do imovel
	 * 
	 * @author Raimundo Martins
	 * @date 27/12/2011
	 * */
	public void retirarContasDeCobrancaPorImovel(Integer idComando,
			Integer idImovel, Integer idMotivoRetirada)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE gcom.cobranca.EmpresaCobrancaConta SET mrcb_id = :idMotivoRetirada, ecco_dtretiradaconta = :dataAtual, "
					+ " ecco_tmultimaalteracao = :dataAtual2 WHERE cecc_id = :idComando and imov_id = :idConta and ecco_dtretiradaconta is null "
					+ " and ecco_cdincluido is null ";
			session.createQuery(sql).setInteger("idComando", idComando)
					.setInteger("idConta", idImovel)
					.setDate("dataAtual", new Date())
					.setTimestamp("dataAtual2", new Date())
					.setInteger("idMotivoRetirada", idMotivoRetirada)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0473] Consultar Dados Complementares do Im?vell
	 * 
	 * Metodo que pesquisa as contas enviadas para cobran?a por im?vel
	 * 
	 * @author Raimundo Martins
	 * @date 27/12/2011
	 * */
	public Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovel(
			Integer idImovel, Date dataImplantacao,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		retorno.addAll(pesquisarContasEnviadasCobrancaPorImovelEmConta(
				idImovel, dataImplantacao, idImovelCobrancaSituacao));
		retorno.addAll(pesquisarContasEnviadasCobrancaPorImovelEmContaHistorico(
				idImovel, dataImplantacao, idImovelCobrancaSituacao));
		return retorno;
	}

	private Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovelEmConta(
			Integer idImovel, Date dataImplantacao,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta as amRef, "
					+ "  ecco.ecco_vloriginalconta as vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao as descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta ON ecco.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN COBRANCA.cmd_imovel_cobr_situacao cics ON cics.cecc_id = cecc.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb ON iscb.iscb_id = cics.iscb_id "
					+ "INNER JOIN COBRANCA.cobranca_situacao cbst ON cbst.cbst_id = iscb.cbst_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id             = cnta.dcst_idatual "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND cbst.cbst_cdconstante = :conCobrancaSituacao "
					+ "AND ecco.imov_id            = :idImovel "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY cnta.cnta_amreferenciaconta, "
					+ "  ecco.ecco_vloriginalconta, "
					+ "  dcst.dcst_dsdebitocreditosituacao "
					+ "ORDER BY cnta.cnta_amreferenciaconta DESC ";

			retorno = session
					.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("conCobrancaSituacao",
							CobrancaSituacao.EMPRESA_DE_COBRANCA)
					.setInteger("idImovel", idImovel)
					.setInteger("idImovelCobrancaSituacao",
							idImovelCobrancaSituacao).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarContasEnviadasCobrancaPorImovelEmContaHistorico(
			Integer idImovel, Date dataImplantacao,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnhi.cnhi_amreferenciaconta  AS amRef, "
					+ "  ecco.ecco_vloriginalconta         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta_historico cnhi ON ecco.cnta_id = cnhi.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN COBRANCA.cmd_imovel_cobr_situacao cics ON cics.cecc_id = cecc.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb ON iscb.iscb_id = cics.iscb_id "
					+ "INNER JOIN COBRANCA.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id             = cnhi.dcst_idatual "
					+ "WHERE ecco.ecco_cdincluido IS NULL "
					+ "AND cbst.cbst_cdconstante = :conCobrancaSituacao "
					+ "AND ecco.imov_id            = :idImovel "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY cnhi.cnhi_amreferenciaconta, "
					+ "  ecco.ecco_vloriginalconta, "
					+ "  dcst.dcst_dsdebitocreditosituacao "
					+ "ORDER BY cnhi.cnhi_amreferenciaconta DESC ";
			;

			retorno = session
					.createSQLQuery(sql)
					.addScalar("amRef", Hibernate.INTEGER)
					.addScalar("vlConta", Hibernate.BIG_DECIMAL)
					.addScalar("descSitu", Hibernate.STRING)
					.setInteger("idImovel", idImovel)
					.setInteger("conCobrancaSituacao",
							CobrancaSituacao.EMPRESA_DE_COBRANCA)
					.setInteger("idImovelCobrancaSituacao",
							idImovelCobrancaSituacao).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0473] Consultar Dados Complementares do Im?vell
	 * 
	 * Metodo que pesquisa as contas pagas em cobran?a por im?vel
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovel(
			Integer idImovel, Date dataRetirada,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		retorno.addAll(pesquisarContasPagasEmCobrancaPorImovelEmPagamento(
				idImovel, dataRetirada, idImovelCobrancaSituacao));
		retorno.addAll(pesquisarContasPagasEmCobrancaPorImovelEmPagamentoHistorico(
				idImovel, dataRetirada, idImovelCobrancaSituacao));
		retorno.addAll(pesquisarContasParceladasEmCobrancaPorImovelEmPagamento(
				idImovel, dataRetirada, idImovelCobrancaSituacao));
		retorno.addAll(pesquisarContasHistoricoParceladasEmCobrancaPorImovelEmPagamento(
				idImovel, dataRetirada, idImovelCobrancaSituacao));
		return retorno;
	}

	private Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovelEmPagamento(
			Integer idImovel, Date dataRetirada,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			SistemaParametro sistemaParametro = RepositorioUtilHBM
					.getInstancia().pesquisarParametrosDoSistema();

			String sql = "SELECT cnta.cnta_amreferenciaconta  AS amRef, "
					+ "  pgmt.pgmt_vlpagamento         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu, "
					+ "  pgmt.pgmt_dtpagamento AS dtPagamento, "
					+ "  dotp.dotp_dsdocumentotipo AS documentoTipo "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta ON ecco.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN COBRANCA.cmd_imovel_cobr_situacao cics ON cics.cecc_id = cecc.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb ON iscb.iscb_id = cics.iscb_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst ON dcst.dcst_id = cnta.dcst_idatual "
					+ "INNER JOIN ARRECADACAO.pagamento pgmt ON ecco.cnta_id = pgmt.cnta_id AND ecco.imov_id = pgmt.imov_id "
					+ "INNER JOIN COBRANCA.documento_tipo dotp ON pgmt.dotp_id = dotp.dotp_id "
					+ "WHERE ecco.imov_id            = :idImovel ";

			if (dataRetirada != null) {

				sql = sql
						+ "AND pgmt.pgmt_dtpagamento BETWEEN cecc.cecc_dtexecucao AND :dataRetirada ";
			}

			sql = sql
					+ "AND (pgmt.pgmt_dtpagamento > (cnta.cnta_dtvencimentooriginal + :qtdDias) or (ecco.ecco_cdincluido IS NOT NULL)) "
					+ "AND pgmt.pgst_idatual = :pagamentoSituacao "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY  cnta.cnta_amreferenciaconta, pgmt.pgmt_vlpagamento, dcst.dcst_dsdebitocreditosituacao, pgmt.pgmt_dtpagamento, "
					+ "dotp.dotp_dsdocumentotipo "
					+ "ORDER BY cnta.cnta_amreferenciaconta DESC";

			if (dataRetirada != null) {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger(
								"qtdDias",
								sistemaParametro
										.getNumeroDiasVencimentoCobrancaResultado())
						.setDate("dataRetirada", dataRetirada)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			} else {

				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger(
								"qtdDias",
								sistemaParametro
										.getNumeroDiasVencimentoCobrancaResultado())
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");

		} finally {
			HibernateUtil.closeSession(session);

		}

		return retorno;
	}

	private Collection<Object[]> pesquisarContasPagasEmCobrancaPorImovelEmPagamentoHistorico(
			Integer idImovel, Date dataRetirada,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			SistemaParametro sistemaParametro = RepositorioUtilHBM
					.getInstancia().pesquisarParametrosDoSistema();
			String sql = "SELECT cnhi.cnhi_amreferenciaconta  AS amRef, "
					+ "  pghi.pghi_vlpagamento             AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu, "
					+ "  pghi.pghi_dtpagamento             AS dtPagamento, "
					+ "  dotp.dotp_dsdocumentotipo         AS documentoTipo "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta_historico cnhi "
					+ "ON ecco.cnta_id = cnhi.cnta_id "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN COBRANCA.cmd_imovel_cobr_situacao cics "
					+ "ON cics.cecc_id = cecc.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_id = cics.iscb_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id = cnhi.dcst_idatual "
					+ "INNER JOIN ARRECADACAO.pagamento_historico pghi "
					+ "ON ecco.cnta_id = pghi.cnta_id "
					+ "INNER JOIN COBRANCA.documento_tipo dotp "
					+ "ON pghi.dotp_id    = dotp.dotp_id "
					+ "WHERE ecco.imov_id = :idImovel ";

			if (dataRetirada != null) {
				sql = sql
						+ "AND pghi.pghi_dtpagamento BETWEEN cecc.cecc_dtexecucao AND :dataRetirada ";
			}

			sql = sql
					+ "AND (pghi.pghi_dtpagamento > (cnhi.cnhi_dtvencimentooriginal + :qtdDias) or (ecco.ecco_cdincluido IS NOT NULL)) "
					+ "AND pghi.pgst_idatual     = :pagamentoSituacao "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY cnhi.cnhi_amreferenciaconta, "
					+ "  pghi.pghi_vlpagamento, "
					+ "  dcst.dcst_dsdebitocreditosituacao, "
					+ "  pghi.pghi_dtpagamento, "
					+ "  dotp.dotp_dsdocumentotipo "
					+ "ORDER BY cnhi.cnhi_amreferenciaconta DESC";

			if (dataRetirada != null) {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setDate("dataRetirada", dataRetirada)
						.setInteger(
								"qtdDias",
								sistemaParametro
										.getNumeroDiasVencimentoCobrancaResultado())
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			} else {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setInteger(
								"qtdDias",
								sistemaParametro
										.getNumeroDiasVencimentoCobrancaResultado())
						.setInteger("pagamentoSituacao",
								PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarContasParceladasEmCobrancaPorImovelEmPagamento(
			Integer idImovel, Date dataRetirada,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta  AS amRef, "
					+ "  ecco.ecco_vloriginalconta         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu, "
					+ "  parc.parc_tmparcelamento          AS dtPagamento, "
					+ "  NULL                              AS documentoTipo "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON ecco.cnta_id = cnta.cnta_id AND cnta.parc_id IS NULL "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id = cnta.dcst_idatual "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit "
					+ "ON pcit.cnta_id = cnta.cnta_id "
					+ "INNER JOIN COBRANCA.parcelamento parc "
					+ "ON parc.parc_id    = pcit.parc_id "
					+ "WHERE ecco.imov_id = :idImovel ";

			if (dataRetirada != null) {
				sql = sql
						+ "AND parc.parc_tmparcelamento BETWEEN cecc.cecc_dtexecucao AND :dataRetirada ";
			}

			sql = sql + "AND parc.pcst_id = 1 "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY cnta.cnta_amreferenciaconta, "
					+ "  ecco.ecco_vloriginalconta, "
					+ "  dcst.dcst_dsdebitocreditosituacao, "
					+ "  parc.parc_tmparcelamento "
					+ "ORDER BY cnta.cnta_amreferenciaconta DESC ";

			if (dataRetirada != null) {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setDate("dataRetirada", dataRetirada)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			} else {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			}
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarContasHistoricoParceladasEmCobrancaPorImovelEmPagamento(
			Integer idImovel, Date dataRetirada,
			Integer idImovelCobrancaSituacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT cnhi.cnhi_amreferenciaconta  AS amRef, "
					+ "  ecco.ecco_vloriginalconta         AS vlConta, "
					+ "  dcst.dcst_dsdebitocreditosituacao AS descSitu, "
					+ "  parc.parc_tmparcelamento          AS dtPagamento, "
					+ "  NULL                              AS documentoTipo "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN FATURAMENTO.conta_historico cnhi "
					+ "ON cnhi.cnta_id = ecco.cnta_id AND cnhi.parc_id IS NULL "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc "
					+ "ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN CADASTRO.imovel_cobranca_situacao iscb "
					+ "ON iscb.iscb_dtimplantacaocobranca = cecc.cecc_dtexecucao "
					+ "AND iscb.imov_id                   = ecco.imov_id "
					+ "INNER JOIN FATURAMENTO.debito_credito_situacao dcst "
					+ "ON dcst.dcst_id = cnhi.dcst_idatual "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit "
					+ "ON pcit.cnta_id = cnhi.cnta_id "
					+ "INNER JOIN COBRANCA.parcelamento parc "
					+ "ON parc.parc_id    = pcit.parc_id "
					+ "WHERE ecco.imov_id = :idImovel ";

			if (dataRetirada != null) {
				sql = sql
						+ "AND parc.parc_tmparcelamento BETWEEN cecc.cecc_dtexecucao AND :dataRetirada ";
			}

			sql = sql + "AND parc.pcst_id = 1 "
					+ "AND iscb.iscb_id = :idImovelCobrancaSituacao "
					+ "GROUP BY cnhi.cnhi_amreferenciaconta, "
					+ "  ecco.ecco_vloriginalconta, "
					+ "  dcst.dcst_dsdebitocreditosituacao, "
					+ "  parc.parc_tmparcelamento "
					+ "ORDER BY cnhi.cnhi_amreferenciaconta DESC ";

			if (dataRetirada != null) {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setDate("dataRetirada", dataRetirada)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			} else {
				retorno = session
						.createSQLQuery(sql)
						.addScalar("amRef", Hibernate.INTEGER)
						.addScalar("vlConta", Hibernate.BIG_DECIMAL)
						.addScalar("descSitu", Hibernate.STRING)
						.addScalar("dtPagamento", Hibernate.DATE)
						.addScalar("documentoTipo", Hibernate.STRING)
						.setInteger("idImovel", idImovel)
						.setInteger("idImovelCobrancaSituacao",
								idImovelCobrancaSituacao).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1264] Incluir Contas em Cobran?a
	 * 
	 * 1.1. Para cada parcelamento efetuado no m?s 1.1.1. O sistema dever?
	 * verificar se o im?vel do parcelamento est? associado a uma cobran?a por
	 * resultado ou o parcelamento foi efetuado antes da data de retirada da
	 * cobran?a por resultado 1.1.1.1. Para cada conta parcelada, o sistema
	 * dever? verificar se a mesma est? em cobran?a
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesArrecadacao
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarContasParceladasIncluirCobranca(
			Integer idLocalidade, Integer anoMesArrecadacao)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cnta.imov_id AS imovel, "
					+ "   cnta.cnta_id AS conta, "
					+ "   cnta.cnta_amreferenciaconta AS referencia, "
					+ "   coalesce(cnta.cnta_vlagua, 0) "
					+ "    + coalesce(cnta.cnta_vlesgoto, 0) "
					+ "    + coalesce(cnta.cnta_vldebitos, 0) "
					+ "    - coalesce(cnta.cnta_vlcreditos, 0) "
					+ "    - coalesce(cnta.cnta_vlimpostos, 0) AS valorConta "
					+ " from cobranca.parcelamento parc "
					+ "   inner join cobranca.parcelamento_item pcit on parc.parc_id = pcit.parc_id "
					+ "   inner join faturamento.conta cnta on cnta.cnta_id = pcit.cnta_id "
					+ " where parc.loca_id = :idLocalidade "
					+ "   and to_date(to_char(parc.parc_tmparcelamento, 'dd/MM/yyyy'), 'dd/MM/yyyy') between :dataInicial and :dataFinal "
					+ "	  and parc.pcst_id = 1 "
					+ "   and exists (select iscb.imov_id "
					+ "           from cadastro.imovel_cobranca_situacao iscb "
					+ "             inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "           where iscb.imov_id = parc.imov_id "
					+ "             and cbst.cbst_cdconstante = 1 "
					+ "             and ((iscb.iscb_dtretiradacobranca is null "
					+ "				and (to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= iscb.iscb_dtimplantacaocobranca)) "
					+ "				or (iscb.iscb_dtretiradacobranca is not null "
					+ "                  and (to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between "
					+ "                     iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca) "
					+ "                  )) "
					+ "				and not exists (select ecco.cnta_id "
					+ "	                            from cobranca.empresa_cobranca_conta ecco "
					+ "	                              inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ "	                            where ecco.cnta_id = pcit.cnta_id "
					+ "									and (cecc.cecc_dtencerramento is null or to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and cecc.cecc_dtencerramento) "
					+ " 								and (ecco.ecco_dtretiradaconta is null  or to_date(to_char(parc.parc_tmparcelamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and ecco.ecco_dtretiradaconta)"
					+ "	                           )"
					+ "            ) "
					+ " group by cnta.imov_id, cnta.cnta_id, cnta.cnta_amreferenciaconta, "
					+ "   cnta.cnta_vlagua, cnta.cnta_vlesgoto, cnta.cnta_vldebitos, "
					+ "   cnta.cnta_vlcreditos, cnta.cnta_vlimpostos "
					+ " order by cnta.imov_id, cnta.cnta_id ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setDate(
							"dataInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(anoMesArrecadacao))
					.setDate(
							"dataFinal",
							Util.gerarDataApartirAnoMesRefencia(anoMesArrecadacao))
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1264] Incluir Contas em Cobran?a
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idImovel
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarDadosImoveisIncluirCobranca(Integer idImovel)
			throws ErroRepositorioException {

		Object[] retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select ecco.empr_id AS empresa,  "
					+ "   ecco.ecco_pcempresaconta AS percentual, "
					+ "   ecco.cecc_id AS comando, "
					+ "   ecco.orse_id AS ordemServico "
					+ " from cobranca.empresa_cobranca_conta ecco "
					+ " where ecco.imov_id = :idImovel "
					+ " order by ecco.ecco_tmultimaalteracao desc ";

			retorno = (Object[]) session.createSQLQuery(consulta)
					.addScalar("empresa", Hibernate.INTEGER)
					.addScalar("percentual", Hibernate.BIG_DECIMAL)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("ordemServico", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1264] Incluir Contas em Cobran?a
	 * 
	 * 2.1.1. Para cada pagamento de conta efetuado no m?s da arrecada??o para
	 * os im?veis em situa??o de cobran?a durante o m?s 2.1.1.1. O sistema
	 * dever? verificar se a quantidade de dias do vencimento ? diferente de
	 * nulo ou zero, caso seja, o sistema dever? verificar se o pagamento foi
	 * efetuado ap?s a data de vencimento somando a quantidade de dias informada
	 * 2.1.1.2. Para cada conta que n?o exista na tabela EMPRESA_COBRANCA_CONTA
	 * 
	 * @author Mariana Victor
	 * @date 27/12/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesArrecadacao
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarContasPagasIncluirCobranca(
			Integer idLocalidade, Integer anoMesArrecadacao,
			Integer numeroDiasVencimentoCobrancaResultado)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cnta.imov_id AS imovel, "
					+ "   cnta.cnta_id AS conta, "
					+ "   cnta.cnta_amreferenciaconta AS referencia, "
					+ "   coalesce(cnta.cnta_vlagua, 0) "
					+ "    + coalesce(cnta.cnta_vlesgoto, 0) "
					+ "    + coalesce(cnta.cnta_vldebitos, 0) "
					+ "    - coalesce(cnta.cnta_vlcreditos, 0) "
					+ "    - coalesce(cnta.cnta_vlimpostos, 0) AS valorConta "
					+ " from arrecadacao.pagamento pgmt "
					+ "   inner join faturamento.conta cnta on cnta.cnta_id = pgmt.cnta_id "
					+ " where pgmt.loca_id = :idLocalidade "
					+ "   and pgmt.pgmt_dtpagamento between to_date(:dataInicial,'YYYY-MM-DD') and to_date(:dataFinal,'YYYY-MM-DD') "
					+ "	  and pgmt.pgst_idatual in (:pgtoClassificado, :pgtoValorNaoConf, :pgtoAContabilizar) "
					+ "   and exists (select iscb.imov_id "
					+ "           from cadastro.imovel_cobranca_situacao iscb "
					+ "             inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ "           where iscb.imov_id = pgmt.imov_id "
					+ "             and cbst.cbst_cdconstante = 1 "
					+ "             and ((iscb.iscb_dtretiradacobranca is null "
					+ "				and (to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= iscb.iscb_dtimplantacaocobranca)) "
					+ "				or (iscb.iscb_dtretiradacobranca is not null "
					+ "                  and (to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between "
					+ "                     iscb.iscb_dtimplantacaocobranca and iscb.iscb_dtretiradacobranca) "
					+ "                  )) "
					+ "				and not exists (select ecco.cnta_id "
					+ "	                            from cobranca.empresa_cobranca_conta ecco "
					+ "	                              inner join cobranca.cmd_empr_cobr_conta cecc on cecc.cecc_id = ecco.cecc_id "
					+ "	                            where ecco.cnta_id = pgmt.cnta_id "
					+ "									and (cecc.cecc_dtencerramento is null or to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and cecc.cecc_dtencerramento) "
					+ " 								and (ecco.ecco_dtretiradaconta is null  or to_date(to_char(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') between cecc.cecc_dtexecucao and ecco.ecco_dtretiradaconta)"
					+ "	                           )" + "            ) ";

			// 2.1.1.1. O sistema dever? verificar se a quantidade de dias do
			// vencimento ? diferente de nulo ou zero,
			// caso seja, o sistema dever? verificar se o pagamento foi efetuado
			// ap?s a data de vencimento
			// somando a quantidade de dias informada
			if (numeroDiasVencimentoCobrancaResultado != null
					&& numeroDiasVencimentoCobrancaResultado
							.compareTo(new Integer(0)) > 0) {
				consulta = consulta
						+ "   and pgmt.pgmt_dtpagamento > (cnta.cnta_dtvencimentooriginal + :quantidadeDias) ";
			}

			consulta = consulta
					+ " group by cnta.imov_id, cnta.cnta_id, cnta.cnta_amreferenciaconta, "
					+ "   cnta.cnta_vlagua, cnta.cnta_vlesgoto, cnta.cnta_vldebitos, "
					+ "   cnta.cnta_vlcreditos, cnta.cnta_vlimpostos "
					+ " order by cnta.imov_id, cnta.cnta_id ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("referencia", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.setInteger("idLocalidade", idLocalidade)
					.setDate(
							"dataInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(anoMesArrecadacao))
					.setDate(
							"dataFinal",
							Util.gerarDataApartirAnoMesRefencia(anoMesArrecadacao))
					.setInteger("pgtoClassificado",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("pgtoValorNaoConf",
							PagamentoSituacao.VALOR_NAO_CONFERE)
					.setInteger("pgtoAContabilizar",
							PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

			if (numeroDiasVencimentoCobrancaResultado != null) {
				query = query.setInteger("quantidadeDias",
						numeroDiasVencimentoCobrancaResultado);
			}

			retorno = query.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0867] Atualizar Pagamentos Contas em Cobran?a
	 * 
	 * Metodo que verifica o Documento de Cobranca pra uma conta paga
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Collection<Integer> pesquisarDocumentoCobrancaConta(
			Integer idPagamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT pgmt.cbdo_id AS doc FROM ARRECADACAO.pagamento pgmt WHERE pgmt.pgmt_id = :idPagamento";
			retorno = session.createSQLQuery(sql)
					.addScalar("doc", Hibernate.INTEGER)
					.setInteger("idPagamento", idPagamento).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0867] Atualizar Pagamentos Contas em Cobran?a
	 * 
	 * Metodo que pesquisa a data de retirada da conta de EmpresaCobrancaConta
	 * 
	 * @author Raimundo Martins
	 * @date 28/12/2011
	 * */
	public Date pesquisarDataRetiradaConta(Integer idEmpresaCobrancaConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Date retorno = null;
		try {
			// String consulta = "select ecc.dataRetiradaConta " +
			// " from EmpresaCobrancaConta ecc "
			// + " inner join ecc.contaGeral cntaG " +
			// " where ecc.id = :idEmpresaCobrancaConta ";

			String consulta = "SELECT ecc.ecco_dtretiradaconta as dataRetirada "
					+ "FROM cobranca.empresa_cobranca_conta ecc "
					+ "WHERE ecc.cnta_id is not null AND "
					+ "ecc.ecco_id = :idEmpresaCobrancaConta ";

			retorno = (Date) session
					.createSQLQuery(consulta)
					.addScalar("dataRetirada", Hibernate.DATE)
					.setInteger("idEmpresaCobrancaConta",
							idEmpresaCobrancaConta).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1256] Retirar Im?veis e Contas das Empresas de Cobran?a
	 * 
	 * Metodo que verifica se o imovel ja foi retirado para aquele comando
	 * 
	 * @author Raimundo Martins
	 * @date 30/12/2011
	 * */
	public Boolean isImovelRetirado(Integer idImovel, Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer id = null;
		Boolean retorno = false;
		try {
			String sql = "SELECT imrc.imov_id as id FROM cobranca.imovel_retirada_comando imrc "
					+ " WHERE imrc.imov_id = :idImovel AND imrc.cecc_id = :idComando";

			id = (Integer) session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (id != null && id > 0)
				retorno = true;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC120] Gerar Boletim de Cobran?a por Resultado
	 * 
	 * M?todo que pesquisa a Empresa Cobran?a faixa A partir de um comando e
	 * imovel
	 * 
	 * @author Raimundo Martins
	 * @date 24/01/2012
	 * */
	public Integer pesquisarEmpresaCobrancaFaixa(Integer idComando,
			Integer idImovel, Integer idEmpresa)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "SELECT emcf.emcf_id AS faixa "
					+ "FROM CADASTRO.empr_cobr_faixa emcf "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON emcf.emcf_pcfaixa = ecco.ecco_pcempresaconta "
					+ " inner join CADASTRO.empr_contrato_cobranca eccc "
					+ " on eccc.empr_id = ecco.empr_id and emcf.emco_id = eccc.emco_id "
					+ "WHERE ecco.cecc_id   = :idComando "
					+ "AND ecco.imov_id     = :idImovel "
					+ "AND ecco.empr_id = :idEmpresa";

			return (Integer) Util.retonarObjetoDeColecao(session
					.createSQLQuery(hql).addScalar("faixa", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel)
					.setInteger("idEmpresa", idEmpresa).list());
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0896] Gerar Arquivo Texto das Contas em Cobran?a por Empresa
	 * 
	 * Metodo que verifica a quantidade de contas para um determinado comando
	 * 
	 * @author Mariana Victor
	 * @date 09/02/2012
	 * */
	public Integer pesquisarQuantidadeContasComando(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT COUNT(distinct ecco.cnta_id) as quantidade "
					+ " FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando ";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 2.1.1. Para cada Ordem de Servi?o selecionada, o sistema dever? verificar
	 * se as contas associadas ao comando de cobran?a, que tenham sido enviadas
	 * no comando, ao im?vel da ordem de servi?o est?o quitadas ou parceladas
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public Collection<Object[]> verificarContasAssociadasComandosCobrancaEnviadasImovel(
			Integer idOS) throws ErroRepositorioException {

		Collection<Object[]> dados = null;
		Session session = HibernateUtil.getSession();
		try {

			String consulta = " SELECT ecco.cnta_id AS conta, ecco.ecco_amreferenciaconta AS mesAno "
					+ "  FROM cobranca.empresa_cobranca_conta ecco "
					+ "  WHERE ecco.orse_id = :idOS "
					+ "  AND ecco.ecco_cdincluido is null "
					+ "  AND (EXISTS (SELECT pgmt.cnta_id FROM arrecadacao.pagamento pgmt WHERE pgmt.cnta_id = ecco.cnta_id) "
					+ "  OR EXISTS (SELECT pghi.cnta_id FROM arrecadacao.pagamento_historico pghi WHERE pghi.cnta_id = ecco.cnta_id) "
					+ "  OR EXISTS (SELECT cnta.cnta_id FROM faturamento.conta cnta WHERE cnta.cnta_id = ecco.cnta_id AND (cnta.dcst_idatual = 5 OR cnta.dcst_idatual = 3) ) "
					+ "  OR EXISTS (SELECT cntahi.cnta_id FROM faturamento.conta_historico cntahi WHERE cntahi.cnta_id = ecco.cnta_id AND cntahi.dcst_idatual = 5 OR cntahi.dcst_idatual = 3)) ";

			dados = session.createSQLQuery(consulta)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.setInteger("idOS", idOS).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return dados;

	}

	/**
	 * Metodo que retorna o valor de um pagamento de uma determinada conta
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public BigDecimal valorPagamento(Integer idConta)
			throws ErroRepositorioException {
		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		try {

			String consulta = "SELECT pg.valor as valor FROM ( "
					+ "SELECT pgmt.pgmt_vlpagamento as valor, pgmt.cnta_id as conta FROM arrecadacao.pagamento pgmt "
					+ "UNION "
					+ "SELECT pghi.pghi_vlpagamento, pghi.cnta_id FROM arrecadacao.pagamento_historico pghi) pg "
					+ "WHERE pg.conta = :idConta ";

			retorno = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorna a date de pagamento de uma determinada conta
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public String dataPagamento(Integer idConta)
			throws ErroRepositorioException {
		String retorno = null;
		Session session = HibernateUtil.getSession();
		try {

			String consulta = "SELECT pg.dtPagamento as dataPagamento FROM ( "
					+ "SELECT pgmt.pgmt_dtpagamento as dtPagamento, pgmt.cnta_id as conta FROM arrecadacao.pagamento pgmt "
					+ "UNION "
					+ "SELECT pghi.pghi_dtpagamento, pghi.cnta_id FROM arrecadacao.pagamento_historico pghi ) pg "
					+ "WHERE pg.conta = :idConta ";
			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("dataPagamento", Hibernate.STRING)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorna o numero de parcelas de uma determinada conta
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public String numeroParcelas(Integer idConta)
			throws ErroRepositorioException {
		String retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "SELECT distinct parc.parc_nnprestacoes as prestacoes "
					+ "FROM cobranca.parcelamento_item pcit "
					+ "INNER JOIN COBRANCA.parcelamento parc on parc.parc_id = pcit.parc_id "
					+ "WHERE pcit.cnta_id = :idConta ";

			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("prestacoes", Hibernate.STRING)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que verifica se uma conta parcelada possui entrada de parcelametno
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public Boolean possuiEntradaParcelamento(Integer idConta)
			throws ErroRepositorioException {
		Boolean retorno = null;
		Session session = HibernateUtil.getSession();
		BigDecimal valor = null;
		try {
			String consulta = "SELECT pgmt.pgmt_vlpagamento as valor "
					+ "FROM cobranca.parcelamento_item pcit "
					+ "inner join FATURAMENTO.guia_pagamento gpag on gpag.parc_id = pcit.parc_id	"
					+ "inner join arrecadacao.pagamento pgmt on pgmt.gpag_id = gpag.gpag_id "
					+ "where gpag.dbtp_id = 33 "
					+ "and pcit.cnta_id = :idConta ";
			valor = (BigDecimal) session.createSQLQuery(consulta)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();
			if (valor != null && valor.compareTo(new BigDecimal("0")) > 0)
				retorno = true;
			else
				retorno = false;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1318] Filtrar Motivo de Não Geração Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 17/04/2012
	 */
	public Collection obterColecaoNaoGeracaoCobrancaResultado(String codigo,
			String descricao, String tipoDescricao, String descricaoAbreviada,
			String indicadorUso, String tipoMotivo, int numeroPagina)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {
			String sql = "SELECT mngcr FROM MotivoNaoGeracaoCobrancaResultado mngcr WHERE ";

			if (codigo != null && !codigo.equals("")) {
				sql += " mngcr.id = :codigo AND ";
			}

			if (descricao != null && !descricao.equals("")) {
				if (tipoDescricao != null && tipoDescricao.equals("1"))
					sql += " upper(mngcr.descricao)  LIKE upper(:descricao) AND";
				else
					sql += " upper(mngcr.descricao)  LIKE upper(:descricao) AND";
			}

			if (descricaoAbreviada != null && !descricaoAbreviada.equals("")) {
				sql += " mngcr.descricaoAbreviada = :descricaoAbreviada AND";
			}

			if (tipoMotivo != null && !tipoMotivo.equals("4")) {
				sql += " mngcr.codigoTipoMotivo = :tipoMotivo AND";
			}

			if (indicadorUso != null && !indicadorUso.equals("3")) {
				sql += " mngcr.indicadorUso = :indicadorUso AND";
			}

			sql += " 1=1 ";

			Query q = session.createQuery(sql);

			if (codigo != null && !codigo.equals("")) {
				q.setInteger("codigo", new Integer(codigo));
			}

			if (descricao != null && !descricao.equals("")) {
				if (tipoDescricao != null && tipoDescricao.equals("1"))
					q.setString("descricao", descricao + "%");
				else
					q.setString("descricao", "%" + descricao + "%");
			}

			if (descricaoAbreviada != null && !descricaoAbreviada.equals("")) {
				q.setString("descricaoAbreviada", descricaoAbreviada);
			}

			if (tipoMotivo != null && !tipoMotivo.equals("4")) {
				q.setInteger("tipoMotivo", new Integer(tipoMotivo));
			}

			if (indicadorUso != null && !indicadorUso.equals("3")) {
				q.setShort("indicadorUso", new Short(indicadorUso));
			}

			retorno = q.setFirstResult(10 * numeroPagina).setMaxResults(10)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1318] Filtrar Motivo de Não Geração Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 17/04/2012
	 */
	public Integer obterQtdNaoGeracaoCobrancaResultado(String codigo,
			String descricao, String tipoDescricao, String descricaoAbreviada,
			String indicadorUso, String tipoMotivo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT count(*) as qtd FROM COBRANCA.MTVO_NAO_GER_COB_RES mngcr WHERE ";

			if (codigo != null && !codigo.equals("")) {
				sql += " mngcr.MNGC_ID = :codigo AND ";
			}

			if (descricao != null && !descricao.equals("")) {
				if (tipoDescricao != null && tipoDescricao.equals("1"))
					sql += " upper(mngcr.MNGC_DSMOTIVO) LIKE upper(:descricao) AND";
				else
					sql += " upper(mngcr.MNGC_DSMOTIVO) LIKE upper(:descricao) AND";
			}

			if (descricaoAbreviada != null && !descricaoAbreviada.equals("")) {
				sql += " UPPER(mngcr.MNGC_DSABREVIADO) = UPPER(:descricaoAbreviada) AND";
			}

			if (tipoMotivo != null && !tipoMotivo.equals("4")) {
				sql += " mngcr.MNGC_CDTIPOMOTIVO = :tipoMotivo AND";
			}

			if (indicadorUso != null && !indicadorUso.equals("3")) {
				sql += " mngcr.MNGC_ICUSO = :indicadorUso AND";
			}

			sql += " 1=1 ";

			Query q = session.createSQLQuery(sql).addScalar("qtd",
					Hibernate.INTEGER);

			if (codigo != null && !codigo.equals("")) {
				q.setInteger("codigo", new Integer(codigo));
			}

			if (descricao != null && !descricao.equals("")) {
				if (tipoDescricao != null && tipoDescricao.equals("1"))
					q.setString("descricao", descricao + "%");
				else
					q.setString("descricao", "%" + descricao + "%");
			}

			if (descricaoAbreviada != null && !descricaoAbreviada.equals("")) {
				q.setString("descricaoAbreviada", descricaoAbreviada);
			}

			if (tipoMotivo != null && !tipoMotivo.equals("4")) {
				q.setInteger("tipoMotivo", new Integer(tipoMotivo));
			}

			if (indicadorUso != null && !indicadorUso.equals("3")) {
				q.setShort("indicadorUso", new Short(indicadorUso));
			}

			System.out.println(q.getQueryString());

			retorno = (Integer) q.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1319] Manter Motivo de Não Geração Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 20/04/2012
	 */
	public MotivoNaoGeracaoCobrancaResultado obterMotivoNaoGeracaoCobrancaResultado(
			Integer idMotivoINT) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		MotivoNaoGeracaoCobrancaResultado retorno = null;

		try {

			String sql = " SELECT mngcr FROM MotivoNaoGeracaoCobrancaResultado mngcr WHERE "
					+ " mngcr.id = :id ";

			retorno = (MotivoNaoGeracaoCobrancaResultado) session
					.createQuery(sql).setInteger("id", idMotivoINT)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * * [UC1320] Consultar Motivo de Não Geração Cobrança por Resultado * *
	 * Pesquisa os dados dos comandos * * @author: Raimundo Martins * @date:
	 * 19/04/2012
	 */
	public Collection pesquisarDadosNaoGeracaoImoveisContasComandos(
			Integer idEmpresa, Date cicloInicial, Date cicloFinal, int pagina,
			int quantidadeRegistros) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		String consulta = null;

		/**
		 * * Script HQL que já monta uma coleção de
		 * ConsultarComandosContasCobrancaEmpresaHelper com tudo que é
		 * necessário **
		 */
		try {
			consulta = "select new gcom.gui.cobranca.cobrancaporresultado.ConsultarNaoGeracaoImoveisContasComandosHelper(cecc.id) "
					+ "from ComandoEmpresaCobrancaConta cecc "
					+ "where cecc.empresa.id = :idEmpresa "
					+ "and cecc.dataExecucao is not null ";

			if (cicloInicial != null && cicloFinal != null) {

				consulta = consulta + " and "
						+ "  cecc.dataInicioCiclo between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(cicloFinal)
						+ "','YYYY-MM-DD') ";

			}

			consulta = consulta + "ORDER BY cecc.id ";

			retorno = session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa)
					.setMaxResults(quantidadeRegistros)
					.setFirstResult(pagina * quantidadeRegistros).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1320] Consultar Motivo de Não Geração Cobrança por Resultado
	 * 
	 * Pesquisa a quantidade de comandos
	 * 
	 * @author: Raimundo Martins
	 * @date: 19/04/2012
	 */
	public Integer pesquisarDadosNaoGeracaoImoveisContasComandosCount(
			Integer idEmpresa, Date comandoInicial, Date comandoFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Integer retorno = null;
		String consulta = null;

		try {
			consulta = "SELECT COUNT(DISTINCT cecc.id) "
					+ "from ComandoEmpresaCobrancaConta cecc "
					+ "where cecc.empresa.id = :idEmpresa "
					+ " and cecc.dataExecucao is not null ";

			if (comandoInicial != null && comandoFinal != null) {

				consulta = consulta + " and "
						+ "  cecc.dataExecucao between to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoInicial)
						+ "','YYYY-MM-DD') and to_date('"
						+ Util.formatarDataComTracoAAAAMMDD(comandoFinal)
						+ "','YYYY-MM-DD') ";

			}

			retorno = (Integer) session.createQuery(consulta)
					.setInteger("idEmpresa", idEmpresa).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC 1320] Consultar Motivo Nao Geracao Cobranca Por Resultado
	 * 
	 * Metodo que pesquisa os motivos de não geração de contas de cobrança por
	 * resultado por imovel
	 * 
	 * @author: Raimundo Martins
	 * @date: 19/04/2012
	 * */
	public Collection<Object[]> pesquisarImoveisContasNaoGeradasCobrancaPorResultadoImovel(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;

		try {
			String consulta = "SELECT mngc.mngc_dsmotivo AS motivo, "
					+ "  icgc.imov_id                      AS imovel, "
					+ "  clie.clie_nmcliente               AS nomeCliente, "
					+ "  clie.clie_nncpf                   AS cpf, "
					+ "  clie.clie_nncnpj                  AS cnpj, "
					+ "  iper.iper_dsimovelperfil          AS imovelPerfil, "
					+ "  last.last_dsligacaoaguasituacao   AS aguaSituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao AS esgotoSituacao, "
					+ "  imov.loca_id AS localidade, "
					+ "  stcm.stcm_cdsetorcomercial AS setor, "
					+ "  qdra.qdra_nnquadra AS quadra, "
					+ "  imov.imov_nnlote AS lote, "
					+ "  imov.imov_nnsublote AS sublote "
					+ "FROM COBRANCA.imo_cnta_nao_ger_cob_res icgc "
					+ "INNER JOIN cobranca.mtvo_nao_ger_cob_res mngc "
					+ "ON mngc.mngc_id = icgc.mngc_id "
					+ "LEFT JOIN CADASTRO.cliente_imovel clim  "
					+ "ON clim.imov_id = icgc.imov_id  AND clim.clim_dtrelacaofim IS NULL  AND clim.crtp_id  = :idClienteRelacaoTipo "
					+ "LEFT JOIN CADASTRO.cliente clie  "
					+ "ON clie.clie_id = clim.clie_id "
					+ "INNER JOIN CADASTRO.imovel imov "
					+ "ON imov.imov_id = icgc.imov_id "
					+ "INNER JOIN CADASTRO.imovel_perfil iper "
					+ "ON imov.iper_id = iper.iper_id "
					+ "INNER JOIN atendimentopublico.ligacao_agua_situacao last "
					+ "ON last.last_id = imov.last_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ligacao_esgoto_situacao lest "
					+ "ON lest.lest_id             = imov.lest_id "
					+ "INNER JOIN CADASTRO.setor_comercial stcm ON stcm.stcm_id = imov.stcm_id "
					+ "INNER JOIN CADASTRO.quadra qdra ON qdra.qdra_id = imov.qdra_id "
					+ "WHERE cecc_id               = :idComando "
					+ "AND icgc.cnta_id           IS NULL "
					+ "GROUP BY mngc.mngc_dsmotivo, " + "  icgc.imov_id, "
					+ "  clie.clie_nmcliente, " + "  clie.clie_nncpf, "
					+ "  clie.clie_nncnpj, " + "  iper.iper_dsimovelperfil, "
					+ "  last.last_dsligacaoaguasituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao, "
					+ "  imov.loca_id, " + "  stcm.stcm_cdsetorcomercial, "
					+ "  qdra.qdra_nnquadra, " + "  imov.imov_nnlote, "
					+ "  imov_nnsublote " + "ORDER BY mngc.mngc_dsmotivo, "
					+ "  icgc.imov_id ASC";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("motivo", Hibernate.STRING)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("cpf", Hibernate.STRING)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("imovelPerfil", Hibernate.STRING)
					.addScalar("aguaSituacao", Hibernate.STRING)
					.addScalar("esgotoSituacao", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("setor", Hibernate.STRING)
					.addScalar("quadra", Hibernate.STRING)
					.addScalar("lote", Hibernate.STRING)
					.addScalar("sublote", Hibernate.STRING)
					.setInteger("idComando", idComando)
					.setShort("idClienteRelacaoTipo",
							ClienteRelacaoTipo.USUARIO.shortValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1320] Consultar Motivo Nao Geracao Cobranca Por Resultado
	 * 
	 * Metodo que pesquisa os motivos de não geração de contas de cobrança por
	 * resultado por contas
	 * 
	 * @author: Raimundo Martins
	 * @date: 27/04/2012
	 * */

	public Collection<Object[]> pesquisarImoveisContasNaoGeradasCobrancaPorResultadoContas(
			Integer idComando) throws ErroRepositorioException {
		Collection<Object[]> retorno = new ArrayList<Object[]>();
		retorno.addAll(pesquisarImoveisContasNaoGeradasCobrancaPorResultadoTConta(idComando));
		retorno.addAll(pesquisarImoveisContasNaoGeradasCobrancaPorResultadoTContaHistorico(idComando));
		return retorno;
	}

	private Collection<Object[]> pesquisarImoveisContasNaoGeradasCobrancaPorResultadoTContaHistorico(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;

		try {
			String consulta = "SELECT mngc.mngc_dsmotivo AS motivo, "
					+ "  icgc.imov_id AS imovel, "
					+ "  cnhi.cnhi_amreferenciaconta AS mesAno, "
					+ "  SUM(COALESCE(cnhi.cnhi_vlagua,0) + COALESCE(cnhi.cnhi_vlesgoto,0) + COALESCE(cnhi.cnhi_vldebitos,0) - COALESCE(cnhi.cnhi_vlcreditos,0) - COALESCE(cnhi.cnhi_vlimpostos,0)) AS valorConta, "
					+ "  clie.clie_nmcliente               AS nomeCliente, "
					+ "  clie.clie_nncpf                   AS cpf, "
					+ "  clie.clie_nncnpj                  AS cnpj, "
					+ "  iper.iper_dsimovelperfil          AS imovelPerfil, "
					+ "  last.last_dsligacaoaguasituacao   AS aguaSituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao AS esgotoSituacao, "
					+ "  imov.loca_id AS localidade, "
					+ "  stcm.stcm_cdsetorcomercial AS setor, "
					+ "  qdra.qdra_nnquadra AS quadra, "
					+ "  imov.imov_nnlote AS lote, "
					+ "  imov.imov_nnsublote AS sublote "
					+ "FROM COBRANCA.imo_cnta_nao_ger_cob_res icgc "
					+ "INNER JOIN cobranca.mtvo_nao_ger_cob_res mngc "
					+ "ON mngc.mngc_id = icgc.mngc_id "
					+ "INNER JOIN FATURAMENTO.conta_historico cnhi "
					+ "ON cnhi.cnta_id = icgc.cnta_id "
					+ "LEFT JOIN CADASTRO.cliente_imovel clim  "
					+ "ON clim.imov_id = icgc.imov_id  AND clim.clim_dtrelacaofim IS NULL  AND clim.crtp_id  = :idClienteRelacaoTipo "
					+ "LEFT JOIN CADASTRO.cliente clie  "
					+ "ON clie.clie_id = clim.clie_id "
					+ "INNER JOIN CADASTRO.imovel imov "
					+ "ON imov.imov_id = icgc.imov_id "
					+ "INNER JOIN CADASTRO.imovel_perfil iper "
					+ "ON imov.iper_id = iper.iper_id "
					+ "INNER JOIN atendimentopublico.ligacao_agua_situacao last "
					+ "ON last.last_id = imov.last_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ligacao_esgoto_situacao lest "
					+ "ON lest.lest_id             = imov.lest_id "
					+ "INNER JOIN CADASTRO.setor_comercial stcm ON stcm.stcm_id = imov.stcm_id "
					+ "INNER JOIN CADASTRO.quadra qdra ON qdra.qdra_id = imov.qdra_id "
					+ "WHERE icgc.cecc_id          = :idComando "
					+ "GROUP BY mngc.mngc_dsmotivo, " + "  icgc.imov_id, "
					+ "  cnhi.cnhi_amreferenciaconta, "
					+ "  clie.clie_nmcliente, " + "  clie.clie_nncpf, "
					+ "  clie.clie_nncnpj, " + "  iper.iper_dsimovelperfil, "
					+ "  last.last_dsligacaoaguasituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao, "
					+ "  imov.loca_id, " + "  stcm.stcm_cdsetorcomercial, "
					+ "  qdra.qdra_nnquadra, " + "  imov.imov_nnlote, "
					+ "  imov_nnsublote " + "ORDER BY icgc.imov_id, "
					+ "  mngc.mngc_dsmotivo, "
					+ "  cnhi.cnhi_amreferenciaconta ASC";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("motivo", Hibernate.STRING)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("cpf", Hibernate.STRING)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("imovelPerfil", Hibernate.STRING)
					.addScalar("aguaSituacao", Hibernate.STRING)
					.addScalar("esgotoSituacao", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("setor", Hibernate.STRING)
					.addScalar("quadra", Hibernate.STRING)
					.addScalar("lote", Hibernate.STRING)
					.addScalar("sublote", Hibernate.STRING)
					.setInteger("idComando", idComando)
					.setShort("idClienteRelacaoTipo",
							ClienteRelacaoTipo.USUARIO.shortValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	private Collection<Object[]> pesquisarImoveisContasNaoGeradasCobrancaPorResultadoTConta(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;

		try {
			String consulta = "SELECT mngc.mngc_dsmotivo   AS motivo, "
					+ "  icgc.imov_id                        AS imovel, "
					+ "  cnta.cnta_amreferenciaconta         AS mesAno, "
					+ "  SUM(COALESCE(CNTA.CNTA_VLAGUA,0) + "
					+ "  COALESCE(CNTA.CNTA_VLESGOTO,0) + "
					+ "  COALESCE(CNTA.CNTA_VLDEBITOS,0) - "
					+ "  COALESCE(CNTA.CNTA_VLCREDITOS,0) - "
					+ "  COALESCE(CNTA.CNTA_VLIMPOSTOS,0)) AS valorConta, "
					+ "  clie.clie_nmcliente               AS nomeCliente, "
					+ "  clie.clie_nncpf                   AS cpf, "
					+ "  clie.clie_nncnpj                  AS cnpj, "
					+ "  iper.iper_dsimovelperfil          AS imovelPerfil, "
					+ "  last.last_dsligacaoaguasituacao   AS aguaSituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao AS esgotoSituacao, "
					+ "  imov.loca_id AS localidade, "
					+ "  stcm.stcm_cdsetorcomercial AS setor, "
					+ "  qdra.qdra_nnquadra AS quadra, "
					+ "  imov.imov_nnlote AS lote, "
					+ "  imov.imov_nnsublote AS sublote "
					+ "FROM COBRANCA.imo_cnta_nao_ger_cob_res icgc "
					+ "INNER JOIN cobranca.mtvo_nao_ger_cob_res mngc "
					+ "ON mngc.mngc_id = icgc.mngc_id "
					+ "INNER JOIN FATURAMENTO.conta cnta "
					+ "ON cnta.cnta_id    = icgc.cnta_id "
					+ "LEFT JOIN CADASTRO.cliente_imovel clim  "
					+ "ON clim.imov_id = icgc.imov_id  AND clim.clim_dtrelacaofim IS NULL  AND clim.crtp_id  = :idClienteRelacaoTipo "
					+ "LEFT JOIN CADASTRO.cliente clie  "
					+ "ON clie.clie_id = clim.clie_id "
					+ "INNER JOIN CADASTRO.imovel imov "
					+ "ON imov.imov_id = icgc.imov_id "
					+ "INNER JOIN CADASTRO.imovel_perfil iper "
					+ "ON imov.iper_id = iper.iper_id "
					+ "INNER JOIN atendimentopublico.ligacao_agua_situacao last "
					+ "ON last.last_id = imov.last_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ligacao_esgoto_situacao lest "
					+ "ON lest.lest_id             = imov.lest_id "
					+ "INNER JOIN CADASTRO.setor_comercial stcm ON stcm.stcm_id = imov.stcm_id "
					+ "INNER JOIN CADASTRO.quadra qdra ON qdra.qdra_id = imov.qdra_id "
					+ "WHERE icgc.cecc_id = :idComando "
					+ "GROUP BY mngc.mngc_dsmotivo, " + "  icgc.imov_id, "
					+ "  cnta.cnta_amreferenciaconta, "
					+ "  clie.clie_nmcliente, " + "  clie.clie_nncpf, "
					+ "  clie.clie_nncnpj, " + "  iper.iper_dsimovelperfil, "
					+ "  last.last_dsligacaoaguasituacao, "
					+ "  lest.lest_dsligacaoesgotosituacao, "
					+ "  imov.loca_id, " + "  stcm.stcm_cdsetorcomercial, "
					+ "  qdra.qdra_nnquadra, " + "  imov.imov_nnlote, "
					+ "  imov_nnsublote " + "ORDER BY icgc.imov_id, "
					+ "  mngc.mngc_dsmotivo, "
					+ "  cnta.cnta_amreferenciaconta ASC";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("motivo", Hibernate.STRING)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("cpf", Hibernate.STRING)
					.addScalar("cnpj", Hibernate.STRING)
					.addScalar("imovelPerfil", Hibernate.STRING)
					.addScalar("aguaSituacao", Hibernate.STRING)
					.addScalar("esgotoSituacao", Hibernate.STRING)
					.addScalar("localidade", Hibernate.STRING)
					.addScalar("setor", Hibernate.STRING)
					.addScalar("quadra", Hibernate.STRING)
					.addScalar("lote", Hibernate.STRING)
					.addScalar("sublote", Hibernate.STRING)
					.setInteger("idComando", idComando)
					.setShort("idClienteRelacaoTipo",
							ClienteRelacaoTipo.USUARIO.shortValue()).list();

		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	public int pesquisarMotivoNaoGeracaoPorDescricao(String descricao, String id)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		int retorno = 0;

		try {

			String sql = " SELECT count(*) FROM MotivoNaoGeracaoCobrancaResultado mngcr WHERE "
					+ " upper(mngcr.descricao) like :descricao ";

			if (id != null) {

				sql = sql + "and mngcr.id <> :codigo";
			}
			Query query = session.createQuery(sql).setString("descricao",
					descricao.toUpperCase());

			if (id != null) {
				query.setInteger("codigo", new Integer(id));
			}

			retorno = (Integer) query.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * @author Rômulo Aurélio
	 * @date 27/04/2012
	 * 
	 *       [SB0002] Verificar Registros ja Inseridos
	 */

	public Collection obterImovelEmComandoNaoFinalizado(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		try {

			String sql = " SELECT distinct ecco.imovel.id FROM EmpresaCobrancaConta ecco "
					+ " INNER JOIN ecco.comandoEmpresaCobrancaConta cecc  "
					+ " WHERE cecc.id = :id and cecc.dataExecucao is null and cecc.dataEncerramento is null ";

			retorno = session.createQuery(sql).setInteger("id", idComando)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * @author Rômulo Aurélio
	 * @date 27/04/2012
	 * 
	 *       [SB0002] Verificar Registros ja Inseridos
	 */
	public void removerContasEmpresaCobrancaConta(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaCobrancaConta ecco WHERE ecco.comandoEmpresaCobrancaConta.id = :idComando";
			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que verifica as contas quitadas associadas a uma Ordem de Serviço
	 * 
	 * @author Raimundo Martins
	 * @date 05/06/2012
	 * 
	 * */
	public Collection<Object[]> verificarContasQuitadasAssociadas(Integer idOs)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			
			String sql = "SELECT DISTINCT ecco.cnta_id AS conta, ecco.ecco_amreferenciaconta AS mesAno "
					+ "FROM cobranca.empresa_cobranca_conta ecco "
					+ "INNER JOIN cobranca.cmd_empr_cobr_conta cecc ON cecc.cecc_id = ecco.cecc_id "
					+ "INNER JOIN arrecadacao.pagamento pgmt on pgmt.cnta_id = ecco.cnta_id AND pgmt.pgst_idatual in(0, 5, 10) " 

					+ "WHERE ecco.orse_id = :idOS "

					+ "AND ( "

					+ "  (cecc.cecc_dtencerramento IS NULL AND " 
					+ "  to_date(TO_CHAR(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= cecc.cecc_dtexecucao) "
			  
					+ "  OR "
			  
					+ "  (cecc.cecc_dtencerramento IS NOT NULL AND " 
					+ "  to_date(TO_CHAR(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') " 
					+ "  BETWEEN cecc.cecc_dtexecucao AND cecc.cecc_dtencerramento) "
		
					+ ") ";

			retorno = session.createSQLQuery(sql)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.setInteger("idOS", idOs).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se uma conta Entrada de Parcelamento foi Paga
	 * 
	 * @author Raimundo Martins, Raphael Rossiter
	 * @date 05/06/2012, 17/12/2013
	 * 
	 * */
	public Integer entradaParcelamentoPaga(Integer idParc, Date dataExecucaoComando, Date dataEncerramentoComando) 
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		
		try {
			
			String 	sql = "SELECT DISTINCT gpag.gpag_id AS gpag "
					+ "FROM FATURAMENTO.guia_pagamento gpag " 
					+ "INNER JOIN arrecadacao.pagamento pgmt on pgmt.gpag_id = gpag.gpag_id AND pgmt.pgst_idatual in(0, 5, 10) " 
					+ "AND pgmt.dbtp_id = :debitoTipo "
					
					+ "WHERE gpag.parc_id = :idParc ";
					
					
			if (dataEncerramentoComando == null){
				
				sql += "AND to_date(TO_CHAR(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') >= :dataExecucaoComando ";
				
				retorno = (Integer) session.createSQLQuery(sql)
						.addScalar("gpag", Hibernate.INTEGER)
						.setInteger("debitoTipo", DebitoTipo.ENTRADA_PARCELAMENTO)
						.setInteger("idParc", idParc)
						.setDate("dataExecucaoComando", dataExecucaoComando)
						.setMaxResults(1).uniqueResult();
			}
			else{
				
				sql += "AND to_date(TO_CHAR(pgmt.pgmt_dtpagamento,'YYYY/MM/DD'),'YYYY/MM/DD') " 
					+ "BETWEEN :dataExecucaoComando AND :dataEncerramentoComando ";
				
				retorno = (Integer) session.createSQLQuery(sql)
						.addScalar("gpag", Hibernate.INTEGER)
						.setInteger("debitoTipo", DebitoTipo.ENTRADA_PARCELAMENTO)
						.setInteger("idParc", idParc)
						.setDate("dataExecucaoComando", dataExecucaoComando)
						.setDate("dataEncerramentoComando", dataEncerramentoComando)
						.setMaxResults(1).uniqueResult();
			}

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que verifica as contas parceladas associadas a uma Ordem de
	 * Serviço
	 * 
	 * @author Raimundo Martins
	 * @date 06/06/2012
	 * 
	 * */
	public Collection<Object[]> verificarContasParceladasAssociadas(Integer idOs)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id           AS conta, "
					+ "  ecco.ecco_amreferenciaconta AS mesAno "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "WHERE ecco.orse_id = :idOs " + "AND (EXISTS "
					+ "  (SELECT cnta.cnta_id "
					+ "  FROM FATURAMENTO.conta cnta "
					+ "  WHERE cnta.cnta_id    = ecco.cnta_id "
					+ "  AND cnta.dcst_idatual = :debitoCreditoSituacao "
					+ "  ) " + "  OR EXISTS " + "  (SELECT cnta.cnta_id "
					+ "  FROM FATURAMENTO.conta_historico cnta "
					+ "  WHERE cnta.cnta_id    = ecco.cnta_id "
					+ "  AND cnta.dcst_idatual = :debitoCreditoSituacao "
					+ "  )) ";

			retorno = session
					.createSQLQuery(sql)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.setInteger("idOs", idOs)
					.setInteger("debitoCreditoSituacao",
							DebitoCreditoSituacao.PARCELADA).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se uma conta parcelada possui entrada parcelamento
	 * 
	 * @author Raimundo Martins
	 * @date 06/06/2012
	 * 
	 * */
	public Collection<Integer> possuiEntrParcelamento(
			Collection<Object[]> contas) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT DISTINCT parc.parc_id AS parc "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN cobranca.parcelamento parc "
					+ "ON parc.imov_id = ecco.imov_id "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit "
					+ "ON pcit.parc_id    = parc.parc_id "
					+ "AND pcit.cnta_id   = ecco.cnta_id "
					+ "WHERE ecco.cnta_id IN( ";
			String sqlAux = "";

			for (Object[] conta : contas) {
				sqlAux += conta[0].toString() + ",";
			}

			sqlAux = sqlAux.substring(0, sqlAux.length() - 1) + ")";
			sql += sqlAux;

			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("parc", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se um imovel possui parcelamento durante a vigência do
	 * contrato
	 * 
	 * @author Raimundo Martins, Mariana Victor
	 * @date 06/06/2012, 05/07/2012
	 * 
	 * */
	public Collection<Integer> pesquisaParcelamentoEfetuadoDuranteVigenciaContrato(
			Integer idOrdemServico) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;
		try {
			String sql = "SELECT DISTINCT parc.parc_id AS parc "
					+ "FROM cobranca.parcelamento parc "
					+ "INNER JOIN COBRANCA.empresa_cobranca_conta ecco "
					+ "ON ecco.imov_id = parc.imov_id "
					+ "INNER JOIN ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "ON orse.orse_id                = ecco.orse_id "
					+ "WHERE orse.orse_id = :idOrdemServico "
					+ "AND pcst_id                    = 1 "
					+ "AND parc.parc_iccobresultado   = 1 "
					+ "AND parc.parc_tmparcelamento  >= orse.orse_tmgeracao "
					+ "AND (orse.orse_tmencerramento IS NULL "
					+ "    OR parc.parc_tmparcelamento   <= orse.orse_tmencerramento)";
			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("parc", Hibernate.INTEGER)
					.setInteger("idOrdemServico", idOrdemServico).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se uma conta ja foi gerada no arquivo texto
	 * 
	 * @author Raimundo Martins
	 * @date 05/06/2012
	 * 
	 * */
	public boolean contaEnviadaArquivoTexto(Integer idConta, Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Object ob;
		boolean retorno = false;
		try {
			String hql = "SELECT hpcr "
					+ "FROM HistoricoPagamentoCobrancaResultado hpcr "
					+ "WHERE hpcr.indicadorEnviado = 1 "
					+ "AND hpcr.conta.id = :idConta AND hpcr.comando.id = :idComando ";
			ob = session.createQuery(hql).setInteger("idConta", idConta)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que verifica as contas parceladas associadas a um Imovél
	 * 
	 * @author Raimundo Martins
	 * @date 08/06/2012
	 * 
	 * */
	public Collection<Object[]> verificarContasParceladasAssociadasImovel(
			Integer idImovel, Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT dbcb.cnta_id AS conta, "
					+ // 0
					"  parc.parc_vlprestacao As valor, "
					+ // 1
					"  dbcb.dbcb_nnprestacaodebito AS numeroParcela,"
					+ // 2
					"  min(dbac.dbac_id) AS debitoACobrar, "
					+ // 3
					"  parc.parc_id AS parcelamento "
					+ // 4
					"FROM FATURAMENTO.debito_a_cobrar dbac "
					+ "INNER JOIN COBRANCA.parcelamento parc "
					+ "ON parc.parc_id = dbac.parc_id "
					+ "INNER JOIN FATURAMENTO.debito_cobrado dbcb "
					+ "ON dbcb.dbac_id    = dbac.dbac_id "
					+ "WHERE parc.imov_id = :idImovel "
					+ "AND parc.parc_id = :idParcelamento " + "AND (EXISTS "
					+ "  (SELECT pgmt.cnta_id "
					+ "  FROM arrecadacao.pagamento pgmt "
					+ "  WHERE pgmt.cnta_id     = dbcb.cnta_id "
					+ "  AND pgmt.pgst_idatual IN(0, 5, 10) " + "  )) "
					+ "GROUP BY dbcb.cnta_id, " + "  parc.parc_vlprestacao, "
					+ "  dbcb.dbcb_nnprestacaodebito," + "  parc.parc_id  ";

			retorno = session.createSQLQuery(sql)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.addScalar("numeroParcela", Hibernate.INTEGER)
					.addScalar("debitoACobrar", Hibernate.INTEGER)
					.addScalar("parcelamento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idParcelamento", idParcelamento).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0214] Efetuar Parcelamento de Débitos
	 * 
	 * Método que verifica se um imóvel de um parcelamento está associado a um
	 * comando de cobrança por resultado ativo
	 * 
	 * @author Raimundo Martins
	 * @date 12/06/2012
	 * */
	public boolean imovelParcelamentoAssociadoComandoCobrancaResultadoAtivo(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Object ob;
		boolean retorno = false;
		try {
			String hql = "SELECT ecco.ecco_id AS ecco "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc ON ecco.cecc_id = cecc.cecc_id "
					+ "WHERE cecc.cecc_dtencerramento is null " + "AND cecc.cecc_dtexecucao is not null "
					+ "AND ecco.imov_id = :idImovel ";
			ob = session.createSQLQuery(hql).addScalar("ecco", Hibernate.INTEGER).setInteger("idImovel", idImovel).setMaxResults(1).uniqueResult();

			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se uma guia ja foi gerada no arquivo texto
	 * 
	 * @author Raimundo Martins
	 * @date 05/06/2012
	 * 
	 * */
	public boolean guiaEnviadaArquivoTexto(Integer idGuia)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Object ob;
		boolean retorno = false;
		try {
			String hql = "SELECT hpcr "
					+ "FROM HistoricoPagamentoCobrancaResultado hpcr "
					+ "WHERE hpcr.indicadorEnviado = 1 "
					+ "AND hpcr.guia.id = :idGuia ";
			ob = session.createQuery(hql).setInteger("idGuia", idGuia)
					.setMaxResults(1).uniqueResult();
			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se um debito a cobrar ja foi gerado no arquivo texto
	 * 
	 * @author Raimundo Martins
	 * @date 05/06/2012
	 * 
	 * */
	public boolean debitoEnviadaArquivoTexto(Integer idDebito,
			Integer numParcela, Integer idConta)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Object ob;
		boolean retorno = false;
		try {
			String hql = "SELECT hpcr "
					+ "FROM HistoricoPagamentoCobrancaResultado hpcr "
					+ "WHERE hpcr.indicadorEnviado = 1 "
					+ "AND ((hpcr.debitoACobrar.id = :idDebito AND hpcr.numeroParcela = :numeroParcela ) OR hpcr.conta.id = :idConta ) ";
			ob = session.createQuery(hql).setInteger("idDebito", idDebito)
					.setInteger("numeroParcela", numParcela)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * Metodo que retorna a data do pagamento de uma conta que possui entrada de
	 * parcelamento
	 * 
	 * @author Raimundo Martins
	 * @data 04/05/2012
	 * */
	public String dataPagamentoEntradaParcelamento(Integer idConta)
			throws ErroRepositorioException {
		String retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String consulta = "SELECT pgmt.pgmt_dtpagamento as dataPagamento "
					+ "FROM cobranca.parcelamento_item pcit "
					+ "inner join FATURAMENTO.guia_pagamento gpag on gpag.parc_id = pcit.parc_id	"
					+ "inner join arrecadacao.pagamento pgmt on pgmt.gpag_id = gpag.gpag_id "
					+ "where gpag.dbtp_id = 33 "
					+ "and pcit.cnta_id = :idConta ";
			retorno = (String) session.createSQLQuery(consulta)
					.addScalar("dataPagamento", Hibernate.STRING)
					.setInteger("idConta", idConta).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 18/05/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaComLimitacaoGeografica(
			Imovel imovel, Short indicadorAcessoRestrito, Integer usuarioLogado)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Object[]> dadosRD;

		try {
			sql = " SELECT distinct(rdir.rdir_id) as idRD,"
					+ " rdir.rdir_nnresolucaodiretoria as numeroRD, "
					+ " rdir.rdir_dtvigenciainicio as dataInicio "
					+ "	FROM  COBRANCA.resolucao_diretoria rdir"
					+ "	inner join COBRANCA.rd_limitacao_geografica rdlg on"
					+ "	              rdir.rdir_id = rdlg.rdir_id"
					+ "	          and rdlg.rdlg_dtvigenciainicio <=  sysdate"
					+ "	          and (rdlg.rdlg_dtvigenciafim is null or rdlg.rdlg_dtvigenciafim >= sysdate)"
					+ "	left join COBRANCA.rd_limitacao_geo_loca rlgl on rdlg.rdlg_id = rlgl.rdlg_id"
					+ "	where rdir.rdir_dtvigenciainicio <= sysdate"
					+ "	and (rdir.rdir_dtvigenciafim is null or rdir.rdir_dtvigenciafim >= sysdate)"
					+ "	and rdir.rdir_icutilizacaolivre = :indicadorUtilizacaoLivre"
					+ "	and (rdlg.greg_id is null or rdlg.greg_id = :gerenciaRegional)"
					+ "	and (rdlg.uneg_id is null or rdlg.uneg_id = :unidadeNegocio)"
					+ "	and (rlgl.loca_id is null or rlgl.loca_id = :localidade)"
					+ "	and (rlgl.stcm_id is null or rlgl.stcm_id = :setorComercial)"
					+ "	and (rlgl.qdra_id is null or rlgl.qdra_id = :quadra)";

			if (indicadorAcessoRestrito.equals(ConstantesSistema.NAO)) {
				sql = sql
						+ " and not exists (select rdru.rdru_id "
						+ " from COBRANCA.rd_restricao_usuario rdru where rdru.rdir_id = rdir.rdir_id) "
						+ "	order by rdir.rdir_dtvigenciainicio";

				dadosRD = (Collection<Object[]>) session
						.createSQLQuery(sql)
						.addScalar("idRD", Hibernate.INTEGER)
						.addScalar("numeroRD", Hibernate.STRING)
						.addScalar("dataInicio", Hibernate.DATE)
						.setInteger(
								"gerenciaRegional",
								imovel.getLocalidade().getGerenciaRegional()
										.getId())
						.setInteger(
								"unidadeNegocio",
								imovel.getLocalidade().getUnidadeNegocio()
										.getId())
						.setInteger("localidade",
								imovel.getLocalidade().getId())
						.setInteger("setorComercial",
								imovel.getSetorComercial().getId())
						.setInteger("quadra", imovel.getQuadra().getId())
						.setShort("indicadorUtilizacaoLivre",
								ConstantesSistema.SIM).list();
			} else {
				sql = sql
						+ " and exists (select rdru.rdru_id "
						+ " from COBRANCA.rd_restricao_usuario rdru where rdru.rdir_id = rdir.rdir_id and rdru.usur_id = :usuarioLogado) "
						+ "	order by rdir.rdir_dtvigenciainicio";

				dadosRD = (Collection<Object[]>) session
						.createSQLQuery(sql)
						.addScalar("idRD", Hibernate.INTEGER)
						.addScalar("numeroRD", Hibernate.STRING)
						.addScalar("dataInicio", Hibernate.DATE)
						.setInteger(
								"gerenciaRegional",
								imovel.getLocalidade().getGerenciaRegional()
										.getId())
						.setInteger(
								"unidadeNegocio",
								imovel.getLocalidade().getUnidadeNegocio()
										.getId())
						.setInteger("localidade",
								imovel.getLocalidade().getId())
						.setInteger("setorComercial",
								imovel.getSetorComercial().getId())
						.setInteger("quadra", imovel.getQuadra().getId())
						.setShort("indicadorUtilizacaoLivre",
								ConstantesSistema.SIM)
						.setInteger("usuarioLogado", usuarioLogado).list();
			}

			if (dadosRD != null && !dadosRD.isEmpty()) {

				retorno = new ArrayList<ResolucaoDiretoria>();
				Iterator iterDadosRD = dadosRD.iterator();
				while (iterDadosRD.hasNext()) {
					Object[] objeto = (Object[]) iterDadosRD.next();
					ResolucaoDiretoria rd = new ResolucaoDiretoria();
					rd.setId((Integer) objeto[0]);
					rd.setNumeroResolucaoDiretoria((String) objeto[1]);
					retorno.add(rd);
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 18/05/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaComLimitacaoGeograficaPermissaoEspecial(
			Imovel imovel, Short indicadorAcessoRestrito, Integer usuarioLogado)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Object[]> dadosRD;

		try {
			sql = " SELECT distinct(rdir.rdir_id) as idRD,"
					+ " rdir.rdir_nnresolucaodiretoria as numeroRD, "
					+ " rdir.rdir_dtvigenciainicio as dataInicio "
					+ "	FROM  COBRANCA.resolucao_diretoria rdir"
					+ "	inner join COBRANCA.rd_limitacao_geografica rdlg on"
					+ "	              rdir.rdir_id = rdlg.rdir_id"
					+ "	          and rdlg.rdlg_dtvigenciainicio <=  sysdate"
					+ "	          and (rdlg.rdlg_dtvigenciafim is null or rdlg.rdlg_dtvigenciafim >= sysdate)"
					+ "	left join COBRANCA.rd_limitacao_geo_loca rlgl on rdlg.rdlg_id = rlgl.rdlg_id"
					+ "	where rdir.rdir_dtvigenciainicio <= sysdate"
					+ "	and (rdir.rdir_dtvigenciafim is null or rdir.rdir_dtvigenciafim >= sysdate)"
					+ "	and (rdlg.greg_id is null or rdlg.greg_id = :gerenciaRegional)"
					+ "	and (rdlg.uneg_id is null or rdlg.uneg_id = :unidadeNegocio)"
					+ "	and (rlgl.loca_id is null or rlgl.loca_id = :localidade)"
					+ "	and (rlgl.stcm_id is null or rlgl.stcm_id = :setorComercial)"
					+ "	and (rlgl.qdra_id is null or rlgl.qdra_id = :quadra)";

			if (indicadorAcessoRestrito.equals(ConstantesSistema.NAO)) {
				sql = sql
						+ " and not exists (select rdru.rdru_id "
						+ " from COBRANCA.rd_restricao_usuario rdru where rdru.rdir_id = rdir.rdir_id) "
						+ "	order by rdir.rdir_dtvigenciainicio";

				dadosRD = (Collection<Object[]>) session
						.createSQLQuery(sql)
						.addScalar("idRD", Hibernate.INTEGER)
						.addScalar("numeroRD", Hibernate.STRING)
						.addScalar("dataInicio", Hibernate.DATE)
						.setInteger(
								"gerenciaRegional",
								imovel.getLocalidade().getGerenciaRegional()
										.getId())
						.setInteger(
								"unidadeNegocio",
								imovel.getLocalidade().getUnidadeNegocio()
										.getId())
						.setInteger("localidade",
								imovel.getLocalidade().getId())
						.setInteger("setorComercial",
								imovel.getSetorComercial().getId())
						.setInteger("quadra", imovel.getQuadra().getId())
						.list();

			} else {
				sql = sql
						+ " and exists (select rdru.rdru_id "
						+ " from COBRANCA.rd_restricao_usuario rdru where rdru.rdir_id = rdir.rdir_id and rdru.usur_id = :usuarioLogado) "
						+ "	order by rdir.rdir_dtvigenciainicio";

				dadosRD = (Collection<Object[]>) session
						.createSQLQuery(sql)
						.addScalar("idRD", Hibernate.INTEGER)
						.addScalar("numeroRD", Hibernate.STRING)
						.addScalar("dataInicio", Hibernate.DATE)
						.setInteger(
								"gerenciaRegional",
								imovel.getLocalidade().getGerenciaRegional()
										.getId())
						.setInteger(
								"unidadeNegocio",
								imovel.getLocalidade().getUnidadeNegocio()
										.getId())
						.setInteger("localidade",
								imovel.getLocalidade().getId())
						.setInteger("setorComercial",
								imovel.getSetorComercial().getId())
						.setInteger("quadra", imovel.getQuadra().getId())
						.setInteger("usuarioLogado", usuarioLogado).list();

			}

			if (dadosRD != null && !dadosRD.isEmpty()) {
				retorno = new ArrayList<ResolucaoDiretoria>();
				Iterator iterDadosRD = dadosRD.iterator();
				while (iterDadosRD.hasNext()) {
					Object[] objeto = (Object[]) iterDadosRD.next();
					ResolucaoDiretoria rd = new ResolucaoDiretoria();
					rd.setId((Integer) objeto[0]);
					rd.setNumeroResolucaoDiretoria((String) objeto[1]);
					retorno.add(rd);
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos
	 * 
	 * @author Vivianne Sousa
	 * @date 22/05/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public RdLimitacaoGeografica pesquisarRdLimitacaoGeografica(Imovel imovel,
			Integer idRD) throws ErroRepositorioException {

		RdLimitacaoGeografica retorno = null;
		Session session = HibernateUtil.getSession();
		String sql = "";
		Collection<Object[]> dadosRdLimitacaoGeografica;

		try {
			sql = " SELECT rdlg.rdlg_id as id,"
					+ "	rdlg.rdlg_dtlimvenccontaparc as dtVencContaParc,"
					+ "	rdlg.rdlg_dtlimvenccontavista as dtVencContaAVista"
					+ "	FROM  COBRANCA.resolucao_diretoria rdir"
					+ "	inner join COBRANCA.rd_limitacao_geografica rdlg on"
					+ "	              rdir.rdir_id = rdlg.rdir_id"
					+ "	          and rdlg.rdlg_dtvigenciainicio <=  sysdate"
					+ "	          and (rdlg.rdlg_dtvigenciafim is null or rdlg.rdlg_dtvigenciafim >= sysdate)"
					+ "	left join COBRANCA.rd_limitacao_geo_loca rlgl on rdlg.rdlg_id = rlgl.rdlg_id"
					+ "	where rdir.rdir_id = :idRD"
					+ "	and (rdlg.greg_id is null or rdlg.greg_id = :gerenciaRegional)"
					+ "	and (rdlg.uneg_id is null or rdlg.uneg_id = :unidadeNegocio)"
					+ "	and (rlgl.loca_id is null or rlgl.loca_id = :localidade)"
					+ "	and (rlgl.stcm_id is null or rlgl.stcm_id = :setorComercial)"
					+ "	and (rlgl.qdra_id is null or rlgl.qdra_id = :quadra)";

			dadosRdLimitacaoGeografica = (Collection<Object[]>) session
					.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("dtVencContaParc", Hibernate.DATE)
					.addScalar("dtVencContaAVista", Hibernate.DATE)
					.setInteger(
							"gerenciaRegional",
							imovel.getLocalidade().getGerenciaRegional()
									.getId())
					.setInteger("unidadeNegocio",
							imovel.getLocalidade().getUnidadeNegocio().getId())
					.setInteger("localidade", imovel.getLocalidade().getId())
					.setInteger("setorComercial",
							imovel.getSetorComercial().getId())
					.setInteger("quadra", imovel.getQuadra().getId())
					.setInteger("idRD", idRD).list();

			if (dadosRdLimitacaoGeografica != null
					&& !dadosRdLimitacaoGeografica.isEmpty()) {
				retorno = new RdLimitacaoGeografica();
				Iterator iterDadosRdLimitacaoGeografica = dadosRdLimitacaoGeografica
						.iterator();
				Object[] object = (Object[]) iterDadosRdLimitacaoGeografica
						.next();
				retorno.setId((Integer) object[0]);
				if (object[1] != null) {
					retorno.setDataLimiteVencimentoContaParcelar((Date) object[1]);
				}
				if (object[2] != null) {
					retorno.setDataLimiteVencimentoContaVista((Date) object[2]);
				}
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0316] Inserir Critério de Cobrança
	 * 
	 * @author Vivianne Sousa
	 * @date 25/05/2012
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaComIndicadorValidoAcaoCobranca(
			Integer idRDSelecionada) throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from ResolucaoDiretoria rd "
					+ "where rd.indicadorValidoAcaoCobranca = :indicadorValidoAcaoCobranca ";

			if (idRDSelecionada != null && !idRDSelecionada.equals("")) {
				consulta = consulta + " or rd.id = :idRDSelecionada "
						+ "order by rd.dataVigenciaInicio ";

				retorno = (Collection) session
						.createQuery(consulta)
						.setShort("indicadorValidoAcaoCobranca",
								ConstantesSistema.SIM)
						.setInteger("idRDSelecionada", idRDSelecionada).list();

			} else {
				consulta = consulta + "order by rd.dataVigenciaInicio ";

				retorno = (Collection) session
						.createQuery(consulta)
						.setShort("indicadorValidoAcaoCobranca",
								ConstantesSistema.SIM).list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 20/04/2012
	 */
	public Collection obterComandosPendentesContasImoveisNaoGerados()
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String sql = " Select cecc_id as id,"
					+ // 0
					" cecc_cdsetorcomercialinicial as codSetorComercialInicial,"
					+ // 1
					" cecc_cdsetorcomercialfinal as codSetorComercialFinal,"
					+ // 2
					" cecc_icresidencial as indicadorResidencial,"
					+ // 3
					" cecc_iccomercial as indicadorComercial,"
					+ // 4
					" cecc_icindustrial as indicadorIndustrial,"
					+ // 5
					" cecc_icpublico as indicadorPublico,"
					+ // 6
					" cecc_nnquadrainicial as quadraInicial,"
					+ // 7
					" cecc_nnquadrafinal as quadraFinal,"
					+ // 8
					" loca_idinicial as locaInicial,"
					+ // 9
					" loca_idfinal as locaFinal,"
					+ // 10
					" imov_id as idImovel,"
					+ // 11
					" clie_id as idCliente,"
					+ // 12
					" uneg_id as idUnidadeNegocio,"
					+ // 13
					" greg_id as idGerenciaRegional,"
					+ // 14
					" iper_id as idPerfilImovel, "
					+ // 15
					" cecc_dtencerramento as dataEncerramento, "
					+ // 16
					" cecc_amreferenciacontainicial as amRefInicial, "
					+ // 17
					" cecc_amreferenciacontafinal as amRefFinal, "
					+ // 18
					" cecc_dtvencimentocontainicial as vencInicial, "
					+ // 19
					" cecc_dtvencimentocontafinal as vencFinal, "
					+ // 20
					" cecc_qtddiasvencimento as qtdDiasVenc, "
					+ // 21
					" cecc_vlminimoconta as valorMinimoConta, "
					+ // 22
					" cecc_vlmaximoconta as valorMaximoConta, "
					+ // 23
					" empr_id as idEmpresa, "
					+ // 24
					" cecc_qtdcontasinicial as qtdContasInicial, "
					+ // 25
					" cecc_qtdcontasfinal as qtdContasFinal, "
					+ // 26
					" cecc_vldebitoinicial as vlDebitoInicial, "
					+ // 27
					" cecc_vldebitofinal as vlDebitoFinal, "
					+ // 28
					" cecc_qtdimoveiscomando as qtdImoveisComando "
					+ // 29
					" from COBRANCA.CMD_EMPR_COBR_CONTA "
					+ " where CECC_ICINCLUSAONAOGERACAO = 2 "
					+ " and cecc_dtencerramento is null ";

			retorno = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER) // 0
					.addScalar("codSetorComercialInicial", Hibernate.INTEGER) // 1
					.addScalar("codSetorComercialFinal", Hibernate.INTEGER) // 2
					.addScalar("indicadorResidencial", Hibernate.INTEGER) // 3
					.addScalar("indicadorComercial", Hibernate.INTEGER) // 4
					.addScalar("indicadorIndustrial", Hibernate.INTEGER) // 5
					.addScalar("indicadorPublico", Hibernate.INTEGER) // 6
					.addScalar("quadraInicial", Hibernate.INTEGER) // 7
					.addScalar("quadraFinal", Hibernate.INTEGER) // 8
					.addScalar("locaInicial", Hibernate.INTEGER) // 9
					.addScalar("locaFinal", Hibernate.INTEGER) // 10
					.addScalar("idImovel", Hibernate.INTEGER) // 11
					.addScalar("idCliente", Hibernate.INTEGER) // 12
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER) // 13
					.addScalar("idGerenciaRegional", Hibernate.INTEGER) // 14
					.addScalar("idPerfilImovel", Hibernate.INTEGER) // 15
					.addScalar("dataEncerramento", Hibernate.DATE) // 16
					.addScalar("amRefInicial", Hibernate.INTEGER) // 17
					.addScalar("amRefFinal", Hibernate.INTEGER) // 18
					.addScalar("vencInicial", Hibernate.DATE) // 19
					.addScalar("vencFinal", Hibernate.DATE) // 20
					.addScalar("qtdDiasVenc", Hibernate.INTEGER) // 21
					.addScalar("valorMinimoConta", Hibernate.BIG_DECIMAL) // 22
					.addScalar("valorMaximoConta", Hibernate.BIG_DECIMAL) // 23
					.addScalar("idEmpresa", Hibernate.INTEGER) // 24
					.addScalar("qtdContasInicial", Hibernate.INTEGER) // 25
					.addScalar("qtdContasFinal", Hibernate.INTEGER) // 26
					.addScalar("vlDebitoInicial", Hibernate.BIG_DECIMAL) // 27
					.addScalar("vlDebitoFinal", Hibernate.BIG_DECIMAL) // 28
					.addScalar("qtdImoveisComando", Hibernate.INTEGER) // 29
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0001] Verificar Motivos de Não Geração
	 * 
	 * @author Hugo Azevedo
	 * @date 27/04/2012
	 */
	public void removerMotivosNaoGeracao(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		try {

			String sql = " delete "
					+ " from ImovelContaNaoGeracaoCobrancaResultado icngcr "
					+ " where icngcr.comandoEmpresaCobrancaConta.id = :idComando";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0004] Selecionar Imóveis Não Gerados
	 * 
	 * @author Hugo Azevedo, Mariana Victor
	 * @date 27/04/2012, 16/09/2013
	 */
	public Collection obterImoveisNaoGeradosComando(Object[] objComando,
			Integer idLocalidade) throws ErroRepositorioException {

		// 2. O sistema deverá selecionar os imóveis
		// de acordo com os parâmetros informados da esfera geográfica

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String sql = "";

		try {

			// =========================================================================
			// Bloco auxiliar que verifica se existe um ou mais registros
			// com o comando passado na tabela COBRANCA.cmd_empr_cobr_conta_uneg
			// =========================================================================
			Collection<Integer> colecaoUnidadeNegocio = null;
			sql = " select distinct uneg_id as idUnidade from "
					+ " COBRANCA.cmd_empr_cobr_conta_uneg "
					+ " where cecc_id = :idComando";

			colecaoUnidadeNegocio = (Collection<Integer>) session
					.createSQLQuery(sql)
					.addScalar("idUnidade", Hibernate.INTEGER)
					.setInteger("idComando", (Integer) objComando[0]).list();

			// ===========================================================================
			// Bloco auxiliar que verifica se existe um ou mais registros
			// com o comando passado na tabela COBRANCA.cmd_empr_cobr_conta_ger
			// =========================================================================
			Collection<Integer> colecaoGerenciaRegional = null;
			sql = " select distinct greg_id as idGerencia from "
					+ " COBRANCA.cmd_empr_cobr_conta_ger "
					+ " where cecc_id = :idComando";

			colecaoGerenciaRegional = (Collection<Integer>) session
					.createSQLQuery(sql)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.setInteger("idComando", (Integer) objComando[0]).list();

			// ===========================================================================
			// Bloco auxiliar que verifica se existe um ou mais registros
			// com o comando passado na tabela COBRANCA.cmd_empr_cobr_conta_stcm
			// =========================================================================
			Collection<Integer> colecaoSetComercial = null;
			sql = " select distinct stcm_id as idSetor from "
					+ " COBRANCA.cmd_empr_cobr_conta_stcm "
					+ " where cecc_id = :idComando";

			colecaoSetComercial = (Collection<Integer>) session
					.createSQLQuery(sql)
					.addScalar("idSetor", Hibernate.INTEGER)
					.setInteger("idComando", (Integer) objComando[0]).list();
			// =========================================================================

			sql = "select distinct imov.imov_id as idImovel from "
					+ " cadastro.imovel imov ";

			// 2.3. Caso uma unidade de negócio tenha sido informada
			// 2.4. Caso contrário, caso várias unidades de negócio tenham sido
			// informadas
			// 2.5. Caso uma gerência regional tenha sido informada
			// 2.6. Caso contrário, caso várias gerências regionais tenham sido
			// informadas
			if (objComando[13] != null
					|| (colecaoUnidadeNegocio != null && !colecaoUnidadeNegocio
							.isEmpty())
					|| objComando[14] != null
					|| (colecaoGerenciaRegional != null && !colecaoGerenciaRegional
							.isEmpty())) {
				sql += " left join cadastro.localidade loc on imov.loca_id = loc.loca_id ";
			}

			// 2.8. Caso o intervalo de setor comercial tenha sido informado
			if (objComando[1] != null && objComando[2] != null) {
				sql += " left join cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id ";
			}

			// 2.10. Caso o intervalo de quadra tenha sido informado
			if (objComando[7] != null && objComando[8] != null) {
				sql += " left join cadastro.quadra qd on qd.qdra_id = imov.qdra_id ";
			}

			sql += " where imov.loca_id = :idLocalidade "
					+ " and imov.imov_id not in (" + "    select ecc.imov_id "
					+ "    from cobranca.empresa_cobranca_conta ecc "
					+ "    where ecc.cecc_id = :idComando" + ") ";

			// 2.1. Caso o imóvel tenha sido informado
			if (objComando[11] != null) {
				sql += "and imov.imov_id = :idImovel";
			}

			// 2.2. Caso o cliente tenha sido informado
			if (objComando[12] != null) {

				sql += "and imov.imov_id in (  "
						+ "  select cnta.imov_id from "
						+ "  FATURAMENTO.conta cnta "
						+ "  inner join cadastro.cliente_conta clieco on clieco.cnta_id = cnta.cnta_id "
						+ "  where clieco.clie_id = :idCliente "
						+ "  and cnta.imov_id = imov.imov_id "
						+ ") and imov.imov_id in ( "
						+ "  select cntah.imov_id from "
						+ "  FATURAMENTO.conta_historico cntah "
						+ "  inner join cadastro.cliente_conta clieco on clieco.cnta_id = cntah.cnta_id "
						+ "  where clieco.clie_id = :idCliente "
						+ "  and cntah.imov_id = imov.imov_id " + ") ";
			}

			// 2.3. Caso uma unidade de negócio tenha sido informada
			if (objComando[13] != null) {
				sql += "and loc.uneg_id = :idUnidadeNegocio ";
			}

			// 2.4. Caso contrário, caso várias unidades de negócio tenham sido
			// informadas
			else if (colecaoUnidadeNegocio != null
					&& !colecaoUnidadeNegocio.isEmpty()) {
				sql += "and loc.uneg_id in( ";

				Iterator iterator = colecaoUnidadeNegocio.iterator();
				while (iterator.hasNext()) {
					Integer idUnidade = (Integer) iterator.next();
					sql = idUnidade + ", ";
				}
				sql = Util.removerUltimosCaracteres(sql, 2);
				sql += " ) ";
			}

			// 2.5. Caso uma gerência regional tenha sido informada
			if (objComando[14] != null) {
				sql += "and loc.greg_id = :idGerenciaRegional ";
			}

			// 2.6. Caso contrário, caso várias gerências regionais tenham sido
			// informadas
			else if (colecaoGerenciaRegional != null
					&& !colecaoGerenciaRegional.isEmpty()) {
				sql += " and loc.greg_id in ( ";

				Iterator iterator = colecaoGerenciaRegional.iterator();
				while (iterator.hasNext()) {
					Integer idGerencia = (Integer) iterator.next();
					sql += idGerencia + ", ";
				}
				sql = Util.removerUltimosCaracteres(sql, 2);
				sql += " ) ";
			}

			// 2.7. Caso o intervalo de localidade tenha sido informado
			if (objComando[9] != null && objComando[10] != null) {
				sql += "and imov.loca_id between :idLocaInicial and :idLocaFinal ";
			}

			// 2.8. Caso o intervalo de setor comercial tenha sido informado
			if (objComando[1] != null && objComando[2] != null) {
				sql += "and stcm.stcm_cdsetorcomercial between :cdStComInicial and :cdStComFinal ";
			}

			// 2.9. Caso contrário, caso vários setores comerciais tenham sido
			// informados
			else if (colecaoSetComercial != null
					&& !colecaoSetComercial.isEmpty()) {
				sql += "and imov.stcm_id in ( ";

				Iterator iterator = colecaoSetComercial.iterator();
				while (iterator.hasNext()) {
					Integer idSetor = (Integer) iterator.next();
					sql += idSetor + ", ";
				}
				sql = Util.removerUltimosCaracteres(sql, 2);
				sql += " ) ";
			}

			// 2.10. Caso o intervalo de quadra tenha sido informado
			if (objComando[7] != null && objComando[8] != null) {
				sql += "and qd.qdra_nnquadra between :nQuadraInicial and :nQuadraFinal ";
			}

			Query q = session.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idComando", (Integer) objComando[0]);

			// 2.1. Caso o imóvel tenha sido informado
			if (objComando[11] != null) {
				q.setInteger("idImovel", (Integer) objComando[11]);
			}

			// 2.2. Caso o cliente tenha sido informado
			if (objComando[12] != null) {
				q.setInteger("idCliente", (Integer) objComando[12]);
			}

			// 2.3. Caso uma unidade de negócio tenha sido informada
			if (objComando[13] != null) {
				q.setInteger("idUnidadeNegocio", (Integer) objComando[13]);
			}

			// 2.5. Caso uma gerência regional tenha sido informada
			if (objComando[14] != null) {
				q.setInteger("idGerenciaRegional", (Integer) objComando[14]);
			}

			// 2.7. Caso o intervalo de localidade tenha sido informado
			if (objComando[9] != null && objComando[10] != null) {
				q.setInteger("idLocaInicial", (Integer) objComando[9]);
				q.setInteger("idLocaFinal", (Integer) objComando[10]);
			}

			// 2.8. Caso o intervalo de setor comercial tenha sido informado
			if (objComando[1] != null && objComando[2] != null) {
				q.setInteger("cdStComInicial", (Integer) objComando[1]);
				q.setInteger("cdStComFinal", (Integer) objComando[2]);
			}

			// 2.10. Caso o intervalo de quadra tenha sido informado
			if (objComando[7] != null && objComando[8] != null) {
				q.setInteger("nQuadraInicial", (Integer) objComando[7]);
				q.setInteger("nQuadraFinal", (Integer) objComando[8]);
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0009] Obter Id do Motivo de Não Geração
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public MotivoNaoGeracaoCobrancaResultado obterMotivoNaoGeracaoCobrancaResultadoConstanteMotivo(
			Integer idConstanteMotivo) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		MotivoNaoGeracaoCobrancaResultado retorno = null;

		try {

			String sql = " SELECT mngcr FROM MotivoNaoGeracaoCobrancaResultado mngcr WHERE "
					+ " mngcr.codigoConstante = :codigoConstante ";

			retorno = (MotivoNaoGeracaoCobrancaResultado) session
					.createQuery(sql)
					.setInteger("codigoConstante", idConstanteMotivo)
					.uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarImovelEmCobranca(Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from cobranca.cmd_empr_cobr_conta cecc "
					+ " inner join COBRANCA.empresa_cobranca_conta ecc on ecc.cecc_id = cecc.cecc_id "
					+ " where ecc.imov_id = :idImovel "
					+ " and cecc.cecc_dtencerramento is null";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 06/06/2012
	 */
	public boolean verificarImovelSituacaoCobranca(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from CADASTRO.imovel_cobranca_situacao iscb "
					+ "   inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id and cbst.cbst_icnaocobranca = 1 "
					+ " where iscb.imov_id = :idImovel and iscb.iscb_dtretiradacobranca is null  "
					+ "   and not exists (select cecb.cbst_id "
					+ "               from cobranca.cmd_empr_cobr_conta_cbst cecb "
					+ "               where cecb.cecc_id = :idComando) ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 06/06/2012
	 */
	public boolean verificarImovelSituacaoEspecialCobranca(Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from cobranca.cobranca_situacao_hist csh "
					+ " where csh.imov_id = :idImovel "
					+ " and csh.cbsh_amcobrancaretirada is null";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarPerfilImovelDiferenteInformados(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from cadastro.imovel imov "
					+ " where imov.imov_id = :idImovel " + " and not exists ("
					+ "   select ceccp.iper_id "
					+ "   from cobranca.cmd_empr_cobr_conta_per ceccp"
					+ "   where ceccp.cecc_id = :idComando "
					+ "   and imov.iper_id = ceccp.iper_id " + ")"
					+ " and exists (" + "   select ceccp.iper_id "
					+ "   from cobranca.cmd_empr_cobr_conta_per ceccp"
					+ "   where ceccp.cecc_id = :idComando " + ")";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarSitLigacaoAguaImovelDiferenteInformados(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from cadastro.imovel imov "
					+ " where imov.imov_id = :idImovel " + " and not exists "
					+ "(" + "   select ceccl.last_id "
					+ "   from cobranca.cmd_empr_cobr_conta_last ceccl"
					+ "   where ceccl.cecc_id = :idComando "
					+ "   and imov.last_id = ceccl.last_id" + ")"
					+ " and exists (" + "   select ceccl.last_id "
					+ "   from cobranca.cmd_empr_cobr_conta_last ceccl"
					+ "   where ceccl.cecc_id = :idComando " + ")";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarContasImovel(Integer idImovel, boolean emRevisao,
			boolean difNorIncRet) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(distinct cnta.cnta_id) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual ";
			if (emRevisao)
				sql += " and cnta.cmrv_id is null ";
			if (difNorIncRet)
				sql += " and cnta.dcst_idatual in (0,1,2) ";
			sql += " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ " 	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 13/06/2012
	 */
	public boolean verificarRefMenorAnoMesArrecadacaoImovel(Integer idImovel)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();

		try {

			String sql = " select count(*) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_amreferenciaconta < :amRefArrecadacao "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual "
					+ " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ "	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			Integer qtd = (Integer) session
					.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("amRefArrecadacao",
							sistemaParametro.getAnoMesArrecadacao())
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarContasRefForaFaixaInformada(Integer idImovel,
			Integer amRefInicial, Integer amRefFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_amreferenciaconta between :refInicial and :refFinal "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual "
					+ " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ "	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("refInicial", amRefInicial)
					.setInteger("refFinal", amRefFinal)
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarContasVencForaFaixaInformada(Integer idImovel,
			Date vencInicial, Date vencFinal) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_dtvencimentoconta between :vencInicial and :vencFinal "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual "
					+ " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ " 	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setDate("vencInicial", vencInicial)
					.setDate("vencFinal", vencFinal)
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarContasForaQtdDiasVencimento(Integer idImovel,
			Integer qtdDiasVenc) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_dtvencimentoconta <= :dataAtual - :qtdDiasVenc ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("qtdDiasVenc", qtdDiasVenc)
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public boolean verificarContasValorForaFaixaInformada(Integer idImovel,
			BigDecimal vlInicial, BigDecimal vlFinal)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "           + coalesce(cnta.cnta_vldebitos,0) "
					+ "			 - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0)) between :vlInicial and :vlFinal "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual "
					+ " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ " 	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " )";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setBigDecimal("vlInicial", vlInicial)
					.setBigDecimal("vlFinal", vlFinal)
					.setDate("dataAtual", new Date()).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0008] Selecionar Contas do Imóvel
	 * 
	 * @author Hugo Azevedo
	 * @date 30/04/2012
	 */
	public Object[] obterTotalContasImovel(Integer idImovel, Object[] objComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Object[] retorno = null;

		SistemaParametro sistemaParametro = RepositorioUtilHBM.getInstancia()
				.pesquisarParametrosDoSistema();

		try {

			// 1. O sistema deverá selecionar as contas do imóvel
			// que não possuem pagamento e de acordo com os parâmetros
			// informados
			String sql = " select count(cnta.cnta_id) as qtd, "
					+ " sum(coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) + coalesce(cnta.cnta_vldebitos,0) "
					+ "			 - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0)) as valorDebitos "
					+ " from faturamento.conta cnta "
					+ " where cnta.imov_id = :idImovel "
					+ " and cnta.cnta_dtvencimentoconta < :dataAtual "
					+ " and cnta.cnta_amreferenciaconta < :amRefArrecadacao "
					+ " and cnta.cmrv_id is null "
					+ " and cnta.dcst_idatual in (0,1,2) "
					+ " and cnta.cnta_id not in ("
					+ " 	select pag.cnta_id "
					+ "	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			// 1.1. Caso tenha sido informada a quantidade de dias de vencimento
			if (objComando[21] != null) {

				// 1.1.1. Caso o indicador para incluir contas fora do
				// vencimento para cobrança corresponda a NÃO
				// o sistema deverá verificar a data de vencimento de todas as
				// contas
				if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca()
						.compareTo(ConstantesSistema.NAO) == 0) {
					sql += " and cnta.cnta_dtvencimentoconta <= :dataAtual - :qtdDiasVencimento ";
				} else {
					sql += " and exists (select cnta_id from faturamento.conta "
							+ "where cnta.cnta_dtvencimentoconta <= :dataAtual - :qtdDiasVencimento) ";
				}

			}

			// 1.2. Caso tenha sido informada o período de referência da conta
			if (objComando[17] != null) {
				sql += " and cnta.cnta_amreferenciaconta between :amRefInicial and :amRefFinal ";
			}

			// 1.3. Caso tenha sido informada o período de vencimento da conta
			if (objComando[19] != null) {
				sql += " and cnta.cnta_dtvencimentoconta between :vencInicial and :vencFinal ";
			}

			// 1.4. Caso tenha sido informada a faixa de valor da conta
			if (objComando[22] != null) {
				sql += " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
						+ "           + coalesce(cnta.cnta_vldebitos,0)"
						+ "			 - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0)) between :vlInicial and :vlFinal ";
			}

			Query q = session
					.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("amRefArrecadacao",
							sistemaParametro.getAnoMesArrecadacao())
					.setDate("dataAtual", new Date());

			// 1.1. Caso tenha sido informada a quantidade de dias de vencimento
			if (objComando[21] != null) {
				q.setInteger("qtdDiasVencimento", (Integer) objComando[21]);
			}

			// 1.2. Caso tenha sido informada o período de referência da conta
			if (objComando[17] != null) {
				q.setInteger("amRefInicial", (Integer) objComando[17]);
				q.setInteger("amRefFinal", (Integer) objComando[18]);
			}

			// 1.3. Caso tenha sido informada o período de vencimento da conta
			if (objComando[19] != null) {
				q.setDate("vencInicial", (Date) objComando[19]);
				q.setDate("vencFinal", (Date) objComando[20]);
			}

			// 1.4. Caso tenha sido informada a faixa de valor da conta
			if (objComando[22] != null) {
				q.setBigDecimal("vlInicial", (BigDecimal) objComando[22]);
				q.setBigDecimal("vlFinal", (BigDecimal) objComando[23]);
			}

			retorno = (Object[]) q.uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 01/05/2012
	 */
	public Integer obterQtdContasMenorFaixa(Integer idEmpresa)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try {

			String sql = " select min(ecf.emcf_nncontasmin) as qtd "
					+ " from cadastro.empr_cobr_faixa ecf "
					+ " inner join cadastro.empr_contrato_cobranca ecc on ecf.emco_id = ecc.emco_id "
					+ " where ecc.empr_id = :idEmpresa";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idEmpresa", idEmpresa).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0006] Selecionar Contas Não Geradas
	 * 
	 * @author Hugo Azevedo
	 * @date 02/05/2012
	 */
	public Collection obterContasNaoGeradasComando(Integer idComando,
			Integer idLocalidade) throws ErroRepositorioException {

		// 1. O sistema deverá selecionar as contas
		// que não possuem pagamento

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String sql = "";

		try {

			sql = "select cnta.cnta_id as idConta,"
					+ // 0
					"cnta.cmrv_id as idMotivoRevisao,"
					+ // 1
					"cnta.dcst_idatual as idSituacaoConta,"
					+ // 2
					"cnta.cnta_amreferenciaconta as amReferencia,"
					+ // 3
					"cnta.cnta_dtvencimentoconta as dtVencimento, "
					+ // 4
					"cnta.imov_id as idImovel, "
					+ // 5
					"(coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "           + coalesce(cnta.cnta_vldebitos,0) "
					+ "			 - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0)) as valorDebitos "
					+ // 6
					"from faturamento.conta cnta "
					+ "  inner join cadastro.imovel imov on imov.imov_id = cnta.imov_id "
					+ "where imov.loca_id = :idLocalidade "
					+ " and :dataAtual >= cnta.cnta_dtvencimentoconta "
					+ "and cnta.cnta_id not in ( "
					+ " 	select pag.cnta_id "
					+ "	from arrecadacao.pagamento pag"
					+ "   where pag.cnta_id = cnta.cnta_id and pag.pgst_idatual is not null"
					+ " ) "
					+ " and cnta.cnta_id not in ("
					+ "		select ecc.cnta_id "
					+ "		from cobranca.empresa_cobranca_conta ecc "
					+ "		where ecc.imov_id = cnta.imov_id "
					+ "		and ecc.cecc_id = :idComando"
					+ ") "
					+ " and cnta.imov_id in ( "
					+ "		  select ecc.imov_id  "
					+ "		  from cobranca.empresa_cobranca_conta ecc  "
					+ "		  where ecc.cecc_id = :idComando "
					+ " ) "
					+ " and (coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) "
					+ "        + coalesce(cnta.cnta_vldebitos,0) "
					+ "        - coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0) ) > 0 ";

			retorno = (Collection) session
					.createSQLQuery(sql)
					.addScalar("idConta", Hibernate.INTEGER)
					// 0
					.addScalar("idMotivoRevisao", Hibernate.INTEGER)
					// 1
					.addScalar("idSituacaoConta", Hibernate.INTEGER)
					// 2
					.addScalar("amReferencia", Hibernate.INTEGER)
					// 3
					.addScalar("dtVencimento", Hibernate.DATE)
					// 4
					.addScalar("idImovel", Hibernate.INTEGER)
					// 5
					.addScalar("valorDebitos", Hibernate.BIG_DECIMAL)
					// 6
					.setInteger("idLocalidade", idLocalidade)
					.setInteger("idComando", idComando)
					.setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0010] Atualizar Comando de Cobrança
	 * 
	 * @author Hugo Azevedo
	 * @date 02/05/2012
	 */
	public ComandoEmpresaCobrancaConta obterComandoEmpresaCobrancaConta(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		ComandoEmpresaCobrancaConta retorno = null;

		try {
			String sql = " select cecc from "
					+ " ComandoEmpresaCobrancaConta cecc "
					+ " left join fetch cecc.empresa empr "
					+ " where cecc.id = :idComando";

			retorno = (ComandoEmpresaCobrancaConta) session.createQuery(sql)
					.setInteger("idComando", idComando).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC 0218] Manter Resolução Diretoria
	 * 
	 * @author Davi Menezes
	 * @date 25/05/2012
	 * 
	 */
	public Collection<RdLimitacaoGeograficaLocalidade> obterRDLimitacaoGeografica(
			String numeroRD) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<RdLimitacaoGeograficaLocalidade> retorno = null;

		try {
			String hql = "Select rdLimitacaoGeograficaLocalidade "
					+ "from  RdLimitacaoGeograficaLocalidade rdLimitacaoGeograficaLocalidade "
					+ "inner join fetch rdLimitacaoGeograficaLocalidade.rdLimitacaoGeografica rdLimitacaoGeografica "
					+ "left  join fetch rdLimitacaoGeograficaLocalidade.localidade localidade "
					+ "left  join fetch rdLimitacaoGeograficaLocalidade.setorComercial setorComercial "
					+ "left  join fetch rdLimitacaoGeograficaLocalidade.quadra quadra "
					+ "left  join fetch rdLimitacaoGeografica.gerenciaRegional gerenciaRegional "
					+ "left  join fetch rdLimitacaoGeografica.unidadeNegocio unidadeNegocio "
					+ "inner join fetch rdLimitacaoGeografica.resolucaoDiretoria resolucaoDiretoria "
					+ "where resolucaoDiretoria.numeroResolucaoDiretoria like :numeroRD ";

			retorno = session.createQuery(hql).setString("numeroRD", numeroRD)
					.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança [SB0018]  Verificar
	 * Registros Já Inseridos
	 * 
	 * Método que remove os motivos de não geração do pagamento daquele ano mes
	 * 
	 * @author Raimundo Martins
	 * @date 24/05/2012
	 * */
	public void removerMotivoNaoGeracaoPagamento(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			String hql = "DELETE PagamentoNaoGeracaoCobrancaResultado pagamentoNaoGeracao "
					+ "WHERE pagamentoNaoGeracao.anoMesReferenciaGeracao = :anoMesReferenciaArrecadacao "
					+ "AND  pagamentoNaoGeracao.indicadorAtualizarPagamentos = :indicadorAtualizaPagamento "
					+ "AND pagamentoNaoGeracao.imovel in("
					+ "select pagamento.imovel.id from Pagamento pagamento "
					+ "where pagamento.localidade.id = :idLocalidade and pagamento.anoMesReferenciaArrecadacao = :anoMesReferenciaArrecadacao )";

			session.createQuery(hql)
					.setInteger("anoMesReferenciaArrecadacao",
							anoMesReferenciaArrecadacao)
					.setShort("indicadorAtualizaPagamento", new Short("1"))
					.setInteger("idLocalidade", idLocalidade).executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1264] Incluir Contas em Cobran?a
	 * 
	 * 2.2. Para cada pagamento de conta efetuado no mês da arrecadação 2.2.1.
	 * Caso o imóvel esteve em cobrança no mês da arrecadação
	 * 
	 * @author Mariana Victor
	 * @date 28/05/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesArrecadacao
	 * @return Collection<Object[]>
	 * @throws ErroRepositorioException
	 */
	public Collection<Object[]> pesquisarContasPagasNaoGeradasIncluirCobranca(
			Integer idLocalidade, Integer anoMesArrecadacao)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {
			String consulta = "select cnta.cnta_id AS conta,  "
					+ "   cnta.imov_id AS imovel, "
					+ "   cnta.cnta_dtvencimentoconta AS dataVencimentoConta, "
					+ "   pgmt.pgmt_dtpagamento AS dataPagamento, "
					+ "   iscb.iscb_dtimplantacaocobranca AS dataImplantacao, "
					+ "   iscb.iscb_dtretiradacobranca AS dataRetirada, "
					+ "   pgmt.pgmt_vlpagamento AS valorPagamento, "
					+ "   pgmt.pgmt_amreferenciapagamento AS anoMesRefPgto, "
					+ "   pgmt.pgmt_amreferenciaarrecadacao AS anoMesArrPgto, "
					+ "	  pgmt.pgmt_tmprocessamento AS dataProcessamento "
					+ " from arrecadacao.pagamento pgmt "
					+ "   inner join faturamento.conta cnta on cnta.cnta_id = pgmt.cnta_id "
					+ "   inner join cadastro.imovel_cobranca_situacao iscb on iscb.imov_id = pgmt.imov_id "
					+ "   inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
					+ " where pgmt.loca_id = :idLocalidade "
					+ "   and pgmt.pgmt_dtpagamento between to_date(:dataInicial,'YYYY-MM-DD') and to_date(:dataFinal,'YYYY-MM-DD') "
					+ "   and pgmt.pgst_idatual in (:pgtoClassificado, :pgtoValorNaoConf, :pgtoAContabilizar) "
					+ "   and cbst.cbst_cdconstante = 1 "
					+ "   and (iscb.iscb_dtretiradacobranca is null "
					+ "         or (iscb_dtretiradacobranca >= "
					+ "             to_date(:dataInicial,'YYYY-MM-DD')) "
					+ "       ) "
					+ "   and not exists (select ecco.cnta_id "
					+ "                   from cobranca.empresa_cobranca_conta ecco "
					+ "                     inner join cobranca.cmd_imovel_cobr_situacao cics on (cics.cecc_id = ecco.cecc_id) "
					+ "                   where ecco.cnta_id = pgmt.cnta_id and cics.iscb_id = iscb.iscb_id "
					+ "                   ) "
					+ "	  and not exists (select pggc.cnta_id"
					+ "					   from cobranca.pagto_nao_ger_cob_res pggc"
					+ "					   where pggc.cnta_id = pgmt.cnta_id) "
					+ " group by cnta.cnta_id, cnta.imov_id, cnta.cnta_dtvencimentoconta,  "
					+ "   pgmt.pgmt_dtpagamento, iscb.iscb_dtimplantacaocobranca, iscb.iscb_dtretiradacobranca, "
					+ "   pgmt.pgmt_vlpagamento, pgmt.pgmt_amreferenciapagamento, pgmt.pgmt_amreferenciaarrecadacao, "
					+ "   pgmt.pgmt_tmprocessamento ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("conta", Hibernate.INTEGER)
					// 0
					.addScalar("imovel", Hibernate.INTEGER)
					// 1
					.addScalar("dataVencimentoConta", Hibernate.DATE)
					// 2
					.addScalar("dataPagamento", Hibernate.DATE)
					// 3
					.addScalar("dataImplantacao", Hibernate.DATE)
					// 4
					.addScalar("dataRetirada", Hibernate.DATE)
					// 5
					.addScalar("valorPagamento", Hibernate.BIG_DECIMAL)
					// 6
					.addScalar("anoMesRefPgto", Hibernate.INTEGER)
					// 7
					.addScalar("anoMesArrPgto", Hibernate.INTEGER)
					// 8
					.addScalar("dataProcessamento", Hibernate.TIMESTAMP)
					// 9
					.setInteger("idLocalidade", idLocalidade)
					.setDate(
							"dataInicial",
							Util.gerarDataInicialApartirAnoMesRefencia(anoMesArrecadacao))
					.setDate(
							"dataFinal",
							Util.gerarDataApartirAnoMesRefencia(anoMesArrecadacao))
					.setInteger("pgtoClassificado",
							PagamentoSituacao.PAGAMENTO_CLASSIFICADO)
					.setInteger("pgtoValorNaoConf",
							PagamentoSituacao.VALOR_NAO_CONFERE)
					.setInteger("pgtoAContabilizar",
							PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

			retorno = query.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1345] Encerrar Automaticamente Comandos de Cobrança por Resultado
	 * 
	 * 1. O sistema deverá selecionar todos os comandos que possuem data final
	 * do ciclo, que ainda não estejam encerrados e que já estejam fora do ciclo
	 * de cobrança
	 * 
	 * @author Mariana Victor
	 * @date 04/06/2012
	 */
	public Collection<Integer> pesquisarIdsComandosFimCiclo()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Integer> retorno = null;

		try {
			String sql = " select cecc_id AS idComando "
					+ " from cobranca.cmd_empr_cobr_conta "
					+ " where cecc_dtencerramento is null "
					+ " and cecc_dtfimciclo < :dataAtual ";

			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("idComando", Hibernate.INTEGER)
					.setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1345] Encerrar Automaticamente Comandos de Cobrança por Resultado
	 * 
	 * @author Mariana Victor
	 * @date 04/06/2012
	 */
	public Integer pesquisarSituacaoCobrancaComando(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer retorno = null;

		try {
			String sql = " select cbst_id AS cobrancaSituacao "
					+ " from cobranca.cmd_empr_cobr_conta "
					+ " where cecc_id = :idComando ";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("cobrancaSituacao", Hibernate.INTEGER)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 3. O sistema deverá verificar todos os comandos de cobrança por
	 * resultados executados
	 * 
	 * @author Raimundo Martins
	 * @throws ErroRepositorioException
	 * @data 26/06/2012
	 * */
	public Collection<Object[]> pesquisarComandosCobrancaExecutados(
			Integer idEmpresa) throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = "SELECT cecc.cecc_id AS idComando, " + "     cecc.cecc_dtexecucao AS dataExecucao, "
					+ "   cecc.cecc_dtencerramento AS dataEncerramento "
					+ "   FROM cobranca.cmd_empr_cobr_conta cecc " + " WHERE cecc.cecc_dtexecucao is not null "
					+ "   AND cecc.cecc_icgeracaotxt = 1 " + "   AND cecc.empr_id = :idEmpresa ";


			retorno = session.createSQLQuery(consulta)
						.addScalar("idComando", Hibernate.INTEGER)
						.addScalar("dataExecucao", Hibernate.DATE)
						.addScalar("dataEncerramento", Hibernate.DATE)
						.setInteger("idEmpresa", idEmpresa).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * 3.1. Para cada comando selecionado, o sistema deverá selecionar os
	 * imóveis das ordens de serviço associadas ao mesmo
	 * 
	 * @author Raimundo Martins
	 * @throws ErroRepositorioException
	 * @data 26/06/2012
	 * */
	public Collection<Object[]> pesquisarOrdensServicoComando(Integer idComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct orse.orse_id AS idOS, ecco.imov_id AS idImovel "
					+ "  FROM ATENDIMENTOPUBLICO.ordem_servico orse "
					+ "    INNER JOIN cobranca.empresa_cobranca_conta ecco ON ecco.orse_id = orse.orse_id "
					+ "  WHERE ecco.cecc_id = :idComando";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idOS", Hibernate.INTEGER)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2012
	 */
	public Collection obterDadosConsultarOSSComandosCobranca(String idComando,
			String[] idsUnidadeNegocio, String[] idsGerenciaRegional,
			String[] idsLocalidade, String situacaoOS,
			String dataGeracaoInicialOS, String dataGeracaoFinalOS,
			String dataEncerramentoInicialOS, String dataEncerramentoFinalOS)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = new ArrayList();

		String condicionais = gerarCondicionaisQueryConsultarOrdemServico(
				idsUnidadeNegocio, idsGerenciaRegional, idsLocalidade,
				situacaoOS, dataGeracaoInicialOS, dataGeracaoFinalOS,
				dataEncerramentoInicialOS, dataEncerramentoFinalOS);

		ComandoEmpresaCobrancaConta cecc = this
				.obterComandoEmpresaCobrancaConta(new Integer(idComando));

		try {

			String sql =

			" SELECT "
					+ " distinct orse.orse_id as idOrdemServico,"
					+ " orse.imov_id as idImovel, "
					+ " greg.greg_nmregional as gerenciaRegional, "
					+ " uneg.uneg_nmunidadenegocio as unidadeNegocio, "
					+ " loca.loca_nmlocalidade as localidade"
					+ " FROM atendimentopublico.ordem_servico orse "
					+ " INNER JOIN cadastro.imovel imov "
					+ " ON imov.imov_id = orse.imov_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " ON loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.gerencia_regional greg "
					+ " ON greg.greg_id = loca.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " ON uneg.uneg_id = loca.uneg_id "
					+ " LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ " WHERE  ("
					+
					// 4.5.1. ORSE_ID da tabela ORDEM_SERVICO com data de
					// geração maior que a data de execução do comando
					// (CECC_DTEXECUCAO da tabela CMD_EMPR_COBR_CONTA com
					// CECC_ID = CECC_ID do comando selecionado
					" (orse.orse_tmgeracao >= :dataExecucaoComando) "
					+ " OR"
					+
					// 4.5.1. UNID_ID = UNID_ID da tabela UNIDADE_ORGANIZACIONAL
					// com EMPR_ID = EMPR_ID da tabela CMD_EMPR_COBR_CONTA
					// com CECC_ID = CECC_ID do comando selecionado existindo na
					// tabela ORDEM_SERVICO_UNIDADE
					" EXISTS "
					+ " 	(SELECT unid.unid_id "
					+ " 		FROM cadastro.unidade_organizacional unid "
					+ " 		INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ " 		ON cecc.empr_id    = unid.empr_id "
					+ " 		inner join atendimentopublico.ordem_servico_unidade osun "
					+ " 		on osun.unid_id = unid.unid_id "
					+ " 		WHERE cecc.cecc_id = :idComando "
					+ " 		and osun.orse_id = orse.orse_id "
					+ " 	)) "
					+
					// 4.5.1. IMOV_ID existindo da tabela EMPRESA_COBRANCA_CONTA
					// com CECC_ID = CECC_ID do comando selecionado
					" and orse.imov_id in ( " + "   select ecc.imov_id "
					+ "   from cobranca.empresa_cobranca_conta ecc "
					+ "   where ecc.cecc_id = :idComando " + " ) "
					+

					condicionais
					+

					" and orse.orse_id not in "
					+ " ( "
					+ "  select distinct orse.orse_id "
					+ "   FROM atendimentopublico.ordem_servico orse "
					+ "   INNER JOIN cadastro.imovel imov "
					+ "  ON imov.imov_id = orse.imov_id "
					+ "   INNER JOIN cobranca.empresa_cobranca_conta ecc "
					+ "  ON orse.orse_id = ecc.orse_id "
					+ "  INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ "   ON ecc.cecc_id = cecc.cecc_id "
					+ "   INNER JOIN cadastro.localidade loca "
					+ "   ON loca.loca_id = imov.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg "
					+ "   ON greg.greg_id = loca.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg "
					+ "  ON uneg.uneg_id = loca.uneg_id "
					+ "   INNER JOIN cadastro.unidade_organizacional unid "
					+ "   ON unid.empr_id = cecc.empr_id "
					+ "   LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ "   WHERE  "
					+ "   ecc.cecc_id = :idComando "
					+

					condicionais
					+

					" ) "
					+

					" union all "
					+

					" SELECT "
					+ " distinct orse.orse_id as idOrdemServico, "
					+ " orse.imov_id as idImovel, "
					+ " greg.greg_nmregional as gerenciaRegional, "
					+ " uneg.uneg_nmunidadenegocio as unidadeNegocio, "
					+ " loca.loca_nmlocalidade as localidade"
					+ " FROM atendimentopublico.ordem_servico orse "
					+ " INNER JOIN cadastro.imovel imov "
					+ " ON imov.imov_id = orse.imov_id "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecc "
					+ " ON orse.orse_id = ecc.orse_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ " ON ecc.cecc_id = cecc.cecc_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " ON loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.gerencia_regional greg "
					+ " ON greg.greg_id = loca.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " ON uneg.uneg_id = loca.uneg_id "
					+ " INNER JOIN cadastro.unidade_organizacional unid "
					+ " ON unid.empr_id = cecc.empr_id "
					+ " LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ " WHERE  " + " ecc.cecc_id = :idComando " +

					condicionais +

					" order by  " + " idImovel ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idOrdemServico", Hibernate.INTEGER)
					.setInteger("idComando", new Integer(idComando))
					.setTimestamp(
							"dataExecucaoComando",
							Util.converteStringParaDateHora(
									cecc.getDataExecucao() + " 00:00:00",
									"yyyy-MM-dd HH:mm:ss"));

			// Gerência Regional
			if (idsGerenciaRegional != null
					&& !idsGerenciaRegional[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			}

			// Localidade
			if (idsLocalidade != null
					&& !idsLocalidade[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsLocalidade", idsLocalidade);
			}

			// Unidade Negócio
			if (idsUnidadeNegocio != null
					&& !idsUnidadeNegocio[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			}

			// 4.2.5. Data da Geração da Ordem de Serviço. (ORSE_TMGERACAO da
			// tabela ORDEM_SERVICO)
			if (dataGeracaoInicialOS != null
					&& !dataGeracaoInicialOS.equals("")
					&& dataGeracaoFinalOS != null
					&& !dataGeracaoFinalOS.equals("")) {
				q.setTimestamp(
						"dataGeracaoOSInicial",
						Util.converteStringParaDateHora(dataGeracaoInicialOS
								+ " 00:00:00"));
				q.setTimestamp(
						"dataGeracaoOSFinal",
						Util.converteStringParaDateHora(dataGeracaoFinalOS
								+ " 23:59:59"));
			}

			// 4.2.6. Data do Encerramento da Ordem de Serviço.
			// (ORSE_TMENCERRAMENTO da tabela ORDEM_SERVICO)
			if (dataEncerramentoInicialOS != null
					&& !dataEncerramentoInicialOS.equals("")
					&& dataEncerramentoFinalOS != null
					&& !dataEncerramentoFinalOS.equals("")) {
				q.setTimestamp("dataEncerramentoOSInicial", Util
						.converteStringParaDateHora(dataEncerramentoInicialOS
								+ " 00:00:00"));
				q.setTimestamp(
						"dataEncerramentoOSFinal",
						Util.converteStringParaDateHora(dataEncerramentoFinalOS
								+ " 23:59:59"));
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2012
	 */
	private String gerarCondicionaisQueryConsultarOrdemServico(
			String[] idsUnidadeNegocio, String[] idsGerenciaRegional,
			String[] idsLocalidade, String situacaoOS,
			String dataGeracaoInicialOS, String dataGeracaoFinalOS,
			String dataEncerramentoInicialOS, String dataEncerramentoFinalOS) {

		String sql = "";

		// Gerência Regional
		if (idsGerenciaRegional != null
				&& !idsGerenciaRegional[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			sql += " and greg.greg_id in (:idsGerenciaRegional) ";
		}

		// Unidade Negócio
		if (idsUnidadeNegocio != null
				&& !idsUnidadeNegocio[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			sql += " and uneg.uneg_id in (:idsUnidadeNegocio) ";
		}

		// Localidade
		if (idsLocalidade != null
				&& !idsLocalidade[0].equals(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			sql += " and loca.loca_id in (:idsLocalidade) ";
		}

		// Situação da OS
		// 4.2.4.1. Pendentes (ORSE_ID da tabela ORDEM_SERVICO com AMEN_ID =
		// nulo e ORSE_CDSITUACAO = 1)
		if (situacaoOS != null && situacaoOS.equals("1")) {
			sql += " and orse.amen_id is null and orse.orse_cdsituacao = 1 ";
		}

		// 4.2.4.2. Encerradas (ORSE_ID da tabela ORDEM_SERVICO com AMEN_ID <>
		// nulo e ORSE_CDSITUACAO = 2)
		else if (situacaoOS != null && situacaoOS.equals("2")) {
			sql += " and orse.amen_id is not null and orse.orse_cdsituacao = 2 ";
		}

		// 4.2.5. Data da Geração da Ordem de Serviço. (ORSE_TMGERACAO da tabela
		// ORDEM_SERVICO)
		if (dataGeracaoInicialOS != null && !dataGeracaoInicialOS.equals("")
				&& dataGeracaoFinalOS != null && !dataGeracaoFinalOS.equals("")) {
			sql += " and orse.orse_tmgeracao between (:dataGeracaoOSInicial) and (:dataGeracaoOSFinal) ";

		}

		// 4.2.6. Data do Encerramento da Ordem de Serviço. (ORSE_TMENCERRAMENTO
		// da tabela ORDEM_SERVICO)
		if (dataEncerramentoInicialOS != null
				&& !dataEncerramentoInicialOS.equals("")
				&& dataEncerramentoFinalOS != null
				&& !dataEncerramentoFinalOS.equals("")) {
			sql += " and orse.orse_tmencerramento between (:dataEncerramentoOSInicial) and (:dataEncerramentoOSFinal) ";
		}

		return sql;

	}

	/**
	 * [UC1169] Movimentar Ordens de Serviço de Cobrança por Resultado
	 * 
	 * @author Hugo Azevedo
	 * @date 11/06/2012
	 */
	public Collection obterDadosConsultarOSSinteticoComandosCobranca(
			String idComando, String[] idsUnidadeNegocio,
			String[] idsGerenciaRegional, String[] idsLocalidade,
			String situacaoOS, String dataGeracaoInicialOS,
			String dataGeracaoFinalOS, String dataEncerramentoInicialOS,
			String dataEncerramentoFinalOS) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection retorno = null;

		String condicionais = gerarCondicionaisQueryConsultarOrdemServico(
				idsUnidadeNegocio, idsGerenciaRegional, idsLocalidade,
				situacaoOS, dataGeracaoInicialOS, dataGeracaoFinalOS,
				dataEncerramentoInicialOS, dataEncerramentoFinalOS);

		ComandoEmpresaCobrancaConta cecc = this
				.obterComandoEmpresaCobrancaConta(new Integer(idComando));

		try {

			String sql =

			" SELECT "
					+ " greg.greg_nmregional  AS gerenciaRegional, "
					+ " uneg.uneg_nmunidadenegocio AS unidadeNegocio, "
					+ " loca.loca_nmlocalidade  AS localidade, "
					+ " unfe.unfe_dsuf as estado, "
					+ " svtp.svtp_dsservicotipo AS servicoTipo, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is null) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "    )) as geradas, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is not null and amen.amen_icexecucao = 1) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "  )) as executadas, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is not null and amen.amen_icexecucao = 2) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "  )) as canceladas, "
					+ " coalesce(sum( "
					+ " (	"
					+ "	select "
					+ "  		 sum(coalesce(cnta_vlagua,0) + coalesce(cnta_vlesgoto,0) + coalesce(cnta_vldebitos,0) - coalesce(cnta_vlcreditos,0) - coalesce(cnta_vlimpostos,0)) + "
					+ "  		 sum(coalesce(cnhi_vlagua,0) + coalesce(cnhi_vlesgoto,0) + coalesce(cnhi_vldebitos,0) - coalesce(cnhi_vlcreditos,0) - coalesce(cnhi_vlimpostos,0)) "
					+ " 	from faturamento.conta_geral cntag  "
					+ " 	left join faturamento.conta cnta on cntag.cnta_id = cnta.cnta_id "
					+ " 	left join faturamento.conta_historico cntah on cntah.cnta_id = cntag.cnta_id "
					+ " 	inner join cobranca.empresa_cobranca_conta ecc on ecc.cnta_id = cntag.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 242 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as enviadosCorte, "
					+ " coalesce(sum( "
					+ " ("
					+ "	select "
					+ "  		 sum(coalesce(cnta_vlagua,0) + coalesce(cnta_vlesgoto,0) + coalesce(cnta_vldebitos,0) - coalesce(cnta_vlcreditos,0) - coalesce(cnta_vlimpostos,0)) + "
					+ "  		 sum(coalesce(cnhi_vlagua,0) + coalesce(cnhi_vlesgoto,0) + coalesce(cnhi_vldebitos,0) - coalesce(cnhi_vlcreditos,0) - coalesce(cnhi_vlimpostos,0)) "
					+ " 	from faturamento.conta_geral cntag  "
					+ " 	left join faturamento.conta cnta on cntag.cnta_id = cnta.cnta_id "
					+ " 	left join faturamento.conta_historico cntah on cntah.cnta_id = cntag.cnta_id "
					+ " 	inner join cobranca.empresa_cobranca_conta ecc on ecc.cnta_id = cntag.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 245 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as enviadosSupressao, "
					+ " coalesce(sum( "
					+ " ("
					+ "	select "
					+ "  		sum(coalesce(pagt.pgmt_vlpagamento,0)) +"
					+ "   	sum(coalesce(pagth.pghi_vlpagamento,0)) "
					+ " 	from cobranca.empresa_cobranca_conta ecc "
					+ " 	left join arrecadacao.pagamento pagt on pagt.cnta_id = ecc.cnta_id "
					+ " 	left join arrecadacao.pagamento_historico pagth on pagth.cnta_id = ecc.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 242 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0)  "
					+ " as pagosCorte, "
					+ " coalesce(sum( "
					+ " ( "
					+ "	select "
					+ "  		sum(coalesce(pagt.pgmt_vlpagamento,0)) +"
					+ "   	sum(coalesce(pagth.pghi_vlpagamento,0)) "
					+ " 	from cobranca.empresa_cobranca_conta ecc "
					+ " 	left join arrecadacao.pagamento pagt on pagt.cnta_id = ecc.cnta_id "
					+ " 	left join arrecadacao.pagamento_historico pagth on pagth.cnta_id = ecc.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 245 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as pagosSupressao "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ "  INNER JOIN atendimentopublico.servico_tipo svtp "
					+ "  ON svtp.svtp_id = orse.svtp_id "
					+ " INNER JOIN cadastro.imovel imov "
					+ " ON imov.imov_id = orse.imov_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " ON loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.gerencia_regional greg "
					+ " ON greg.greg_id = loca.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " ON uneg.uneg_id = loca.uneg_id "
					+ " INNER JOIN cadastro.municipio muni"
					+ " ON loca.muni_idprincipal = muni.muni_id "
					+ " INNER JOIN cadastro.unidade_federacao unfe "
					+ " ON unfe.unfe_id = muni.unfe_id "
					+ " LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ " WHERE  ("
					+
					// 4.5.1. ORSE_ID da tabela ORDEM_SERVICO com data de
					// geração maior que a data de execução do comando
					// (CECC_DTEXECUCAO da tabela CMD_EMPR_COBR_CONTA com
					// CECC_ID = CECC_ID do comando selecionado
					" (orse.orse_tmgeracao >= :dataExecucaoComando) "
					+ " OR"
					+
					// 4.5.1. UNID_ID = UNID_ID da tabela UNIDADE_ORGANIZACIONAL
					// com EMPR_ID = EMPR_ID da tabela CMD_EMPR_COBR_CONTA
					// com CECC_ID = CECC_ID do comando selecionado existindo na
					// tabela ORDEM_SERVICO_UNIDADE
					" EXISTS "
					+ " 	(SELECT unid.unid_id "
					+ " 		FROM cadastro.unidade_organizacional unid "
					+ " 		INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ " 		ON cecc.empr_id    = unid.empr_id "
					+ " 		inner join atendimentopublico.ordem_servico_unidade osun "
					+ " 		on osun.unid_id = unid.unid_id "
					+ " 		WHERE cecc.cecc_id = :idComando "
					+ " 		and osun.orse_id = orse.orse_id "
					+ " 	)) "
					+
					// 4.5.1. IMOV_ID existindo da tabela EMPRESA_COBRANCA_CONTA
					// com CECC_ID = CECC_ID do comando selecionado
					" and orse.imov_id in ( " + "   select ecc.imov_id "
					+ "   from cobranca.empresa_cobranca_conta ecc "
					+ "   where ecc.cecc_id = :idComando " + " ) "
					+

					condicionais
					+

					" and orse.orse_id not in "
					+ " ( "
					+ "  select orse.orse_id "
					+ "   FROM atendimentopublico.ordem_servico orse "
					+ "   INNER JOIN cadastro.imovel imov "
					+ "  ON imov.imov_id = orse.imov_id "
					+ "   INNER JOIN cobranca.empresa_cobranca_conta ecc "
					+ "  ON orse.orse_id = ecc.orse_id "
					+ "  INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ "   ON ecc.cecc_id = cecc.cecc_id "
					+ "   INNER JOIN cadastro.localidade loca "
					+ "   ON loca.loca_id = imov.loca_id "
					+ "   INNER JOIN cadastro.gerencia_regional greg "
					+ "   ON greg.greg_id = loca.greg_id "
					+ "   INNER JOIN cadastro.unidade_negocio uneg "
					+ "  ON uneg.uneg_id = loca.uneg_id "
					+ "   INNER JOIN cadastro.unidade_organizacional unid "
					+ "   ON unid.empr_id = cecc.empr_id "
					+ "   LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ "   WHERE  "
					+ "   ecc.cecc_id = :idComando "
					+

					condicionais
					+

					" ) "
					+ " group by greg.greg_nmregional, "
					+ "  uneg.uneg_nmunidadenegocio, "
					+ "  loca.loca_nmlocalidade,"
					+ "  unfe.unfe_dsuf, "
					+ "  svtp.svtp_dsservicotipo "
					+

					" union all "
					+

					" SELECT  "
					+ " greg.greg_nmregional  AS gerenciaRegional, "
					+ " uneg.uneg_nmunidadenegocio AS unidadeNegocio, "
					+ " loca.loca_nmlocalidade  AS localidade, "
					+ " unfe.unfe_dsuf as estado, "
					+ " svtp.svtp_dsservicotipo AS servicoTipo, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is null) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "    )) as geradas, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is not null and amen.amen_icexecucao = 1) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "  )) as executadas, "
					+ " count(distinct(CASE "
					+ "    WHEN (orse.amen_id is not null and amen.amen_icexecucao = 2) then "
					+ "    	orse.orse_id "
					+ "    else "
					+ "    	null "
					+ "    end "
					+ "  )) as canceladas, "
					+ " coalesce(sum( "
					+ " (	"
					+ "	select "
					+ "  		 sum(coalesce(cnta_vlagua,0) + coalesce(cnta_vlesgoto,0) + coalesce(cnta_vldebitos,0) - coalesce(cnta_vlcreditos,0) - coalesce(cnta_vlimpostos,0)) + "
					+ "  		 sum(coalesce(cnhi_vlagua,0) + coalesce(cnhi_vlesgoto,0) + coalesce(cnhi_vldebitos,0) - coalesce(cnhi_vlcreditos,0) - coalesce(cnhi_vlimpostos,0)) "
					+ " 	from faturamento.conta_geral cntag  "
					+ " 	left join faturamento.conta cnta on cntag.cnta_id = cnta.cnta_id "
					+ " 	left join faturamento.conta_historico cntah on cntah.cnta_id = cntag.cnta_id "
					+ " 	inner join cobranca.empresa_cobranca_conta ecc on ecc.cnta_id = cntag.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 242 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as enviadosCorte, "
					+ " coalesce(sum( "
					+ " ("
					+ "	select "
					+ "  		 sum(coalesce(cnta_vlagua,0) + coalesce(cnta_vlesgoto,0) + coalesce(cnta_vldebitos,0) - coalesce(cnta_vlcreditos,0) - coalesce(cnta_vlimpostos,0)) + "
					+ "  		 sum(coalesce(cnhi_vlagua,0) + coalesce(cnhi_vlesgoto,0) + coalesce(cnhi_vldebitos,0) - coalesce(cnhi_vlcreditos,0) - coalesce(cnhi_vlimpostos,0)) "
					+ " 	from faturamento.conta_geral cntag  "
					+ " 	left join faturamento.conta cnta on cntag.cnta_id = cnta.cnta_id "
					+ " 	left join faturamento.conta_historico cntah on cntah.cnta_id = cntag.cnta_id "
					+ " 	inner join cobranca.empresa_cobranca_conta ecc on ecc.cnta_id = cntag.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 245 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as enviadosSupressao, "
					+ " coalesce(sum( "
					+ " ("
					+ "	select "
					+ "  		sum(coalesce(pagt.pgmt_vlpagamento,0)) +"
					+ "   	sum(coalesce(pagth.pghi_vlpagamento,0)) "
					+ " 	from cobranca.empresa_cobranca_conta ecc "
					+ " 	left join arrecadacao.pagamento pagt on pagt.cnta_id = ecc.cnta_id "
					+ " 	left join arrecadacao.pagamento_historico pagth on pagth.cnta_id = ecc.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 242 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0)  "
					+ " as pagosCorte, "
					+ " coalesce(sum( "
					+ " ( "
					+ "	select "
					+ "  		sum(coalesce(pagt.pgmt_vlpagamento,0)) +"
					+ "   	sum(coalesce(pagth.pghi_vlpagamento,0)) "
					+ " 	from cobranca.empresa_cobranca_conta ecc "
					+ " 	left join arrecadacao.pagamento pagt on pagt.cnta_id = ecc.cnta_id "
					+ " 	left join arrecadacao.pagamento_historico pagth on pagth.cnta_id = ecc.cnta_id "
					+ " 	where "
					+ " 	ecc.imov_id = orse.imov_id "
					+ " 	and svtp.svtp_id = 245 "
					+ " 	and orse.amen_id      IS NOT NULL "
					+ " 	and amen.amen_icexecucao = 1 "
					+ "   and ecc.cecc_id = :idComando "
					+ " )),0) "
					+ " as pagosSupressao "
					+ " FROM atendimentopublico.ordem_servico orse "
					+ " INNER JOIN atendimentopublico.servico_tipo svtp "
					+ " ON svtp.svtp_id = orse.svtp_id "
					+ " INNER JOIN cadastro.imovel imov "
					+ " ON imov.imov_id = orse.imov_id "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecc "
					+ " ON orse.orse_id = ecc.orse_id "
					+ " INNER JOIN cobranca.cmd_empr_cobr_conta cecc "
					+ " ON ecc.cecc_id = cecc.cecc_id "
					+ " INNER JOIN cadastro.localidade loca "
					+ " ON loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.gerencia_regional greg "
					+ " ON greg.greg_id = loca.greg_id "
					+ " INNER JOIN cadastro.unidade_negocio uneg "
					+ " ON uneg.uneg_id = loca.uneg_id "
					+ " INNER JOIN cadastro.municipio muni"
					+ " ON loca.muni_idprincipal = muni.muni_id "
					+ " INNER JOIN cadastro.unidade_federacao unfe "
					+ " ON unfe.unfe_id = muni.unfe_id "
					+ " INNER JOIN cadastro.unidade_organizacional unid "
					+ " ON unid.empr_id = cecc.empr_id "
					+ " LEFT join atendimentopublico.atend_motivo_encmt amen on amen.amen_id = orse.amen_id  "
					+ " WHERE  "
					+ " ecc.cecc_id = :idComando "
					+

					condicionais
					+

					" group by greg.greg_nmregional, "
					+ "  uneg.uneg_nmunidadenegocio, "
					+ "  loca.loca_nmlocalidade,"
					+ "  unfe.unfe_dsuf, "
					+ "  svtp.svtp_dsservicotipo "
					+ " ORDER BY"
					+ " servicoTipo, "
					+ " gerenciaRegional, "
					+ " unidadeNegocio, " + " localidade," + " estado ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					// 0
					.addScalar("unidadeNegocio", Hibernate.STRING)
					// 1
					.addScalar("localidade", Hibernate.STRING)
					// 2
					.addScalar("estado", Hibernate.STRING)
					// 3
					.addScalar("servicoTipo", Hibernate.STRING)
					// 4
					.addScalar("geradas", Hibernate.INTEGER)
					// 5
					.addScalar("executadas", Hibernate.INTEGER)
					// 6
					.addScalar("canceladas", Hibernate.INTEGER)
					// 7
					.addScalar("enviadosCorte", Hibernate.BIG_DECIMAL)
					// 8
					.addScalar("enviadosSupressao", Hibernate.BIG_DECIMAL)
					// 9
					.addScalar("pagosCorte", Hibernate.BIG_DECIMAL)
					// 10
					.addScalar("pagosSupressao", Hibernate.BIG_DECIMAL)
					// 11
					.setInteger("idComando", new Integer(idComando))
					.setTimestamp(
							"dataExecucaoComando",
							Util.converteStringParaDateHora(
									cecc.getDataExecucao() + " 00:00:00",
									"yyyy-MM-dd HH:mm:ss"));

			// Gerência Regional
			if (idsGerenciaRegional != null
					&& !idsGerenciaRegional[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			}

			// Localidade
			if (idsLocalidade != null
					&& !idsLocalidade[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsLocalidade", idsLocalidade);
			}

			// Unidade Negócio
			if (idsUnidadeNegocio != null
					&& !idsUnidadeNegocio[0].equals(""
							+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			}

			// 4.2.5. Data da Geração da Ordem de Serviço. (ORSE_TMGERACAO da
			// tabela ORDEM_SERVICO)
			if (dataGeracaoInicialOS != null
					&& !dataGeracaoInicialOS.equals("")
					&& dataGeracaoFinalOS != null
					&& !dataGeracaoFinalOS.equals("")) {
				q.setTimestamp(
						"dataGeracaoOSInicial",
						Util.converteStringParaDateHora(dataGeracaoInicialOS
								+ " 00:00:00"));
				q.setTimestamp(
						"dataGeracaoOSFinal",
						Util.converteStringParaDateHora(dataGeracaoFinalOS
								+ " 23:59:59"));
			}

			// 4.2.6. Data do Encerramento da Ordem de Serviço.
			// (ORSE_TMENCERRAMENTO da tabela ORDEM_SERVICO)
			if (dataEncerramentoInicialOS != null
					&& !dataEncerramentoInicialOS.equals("")
					&& dataEncerramentoFinalOS != null
					&& !dataEncerramentoFinalOS.equals("")) {
				q.setTimestamp("dataEncerramentoOSInicial", Util
						.converteStringParaDateHora(dataEncerramentoInicialOS
								+ " 00:00:00"));
				q.setTimestamp(
						"dataEncerramentoOSFinal",
						Util.converteStringParaDateHora(dataEncerramentoFinalOS
								+ " 23:59:59"));
			}

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1320] Consultar Motivo de Não Geração Cobrança por Resultado
	 * 
	 * Método que verifica se os motivos de não geração de cobrança por
	 * resultados foram gerados ou não. Retorna true se foi gerado false caso
	 * contrário
	 * 
	 * @author Raimundo Martins
	 * @date 19/06/2012
	 */
	public boolean motivosGerados(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {
			String hql = "SELECT comando FROM ComandoEmpresaCobrancaConta comando "
					+ "WHERE comando.indicadorInclusaoNaoGeracao = 1 "
					+ "AND comando.id = :idComando ";
			Object ob = session.createQuery(hql)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * Metodo que pesquisa um parcelamento pelo ID
	 * 
	 * @author Raimundo Martins
	 * @date 26/06/2012
	 * */
	public Parcelamento pesquisarParcelamento(Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String hql = "SELECT parc FROM Parcelamento parc WHERE parc.id = :idParcelamento ";
			return (Parcelamento) session.createQuery(hql)
					.setInteger("idParcelamento", idParcelamento)
					.setMaxResults(1).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1183] Gerar Arquivo Txt OS Contas Pagas Parceladas
	 * 
	 * Metodo que pesquisa a quantidade de contas em aberto para uma ordem de
	 * serviço
	 * 
	 * @author Raimundo Martins
	 * @date 29/06/2012
	 * */
	public Integer quantidadeContasEmAberto(Integer idOs)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT COUNT(ecco2.cnta_id) AS qtdContas "
					+ " FROM cobranca.empresa_cobranca_conta ecco2 "
					+ " LEFT JOIN arrecadacao.pagamento pgmt "
					+ " ON (pgmt.cnta_id       = ecco2.cnta_id "
					+ " AND PGMT.PGST_IDATUAL IN (0,5,10)) "
					+ " LEFT JOIN arrecadacao.pagamento_historico pghi "
					+ "  ON (pghi.cnta_id = ecco2.cnta_id "
					+ "      and pghi.pgst_idatual IN (0,5,10))"
					+ " LEFT JOIN faturamento.conta cnta "
					+ " ON (cnta.cnta_id           = ecco2.cnta_id) "
					+ " LEFT JOIN faturamento.conta_historico cnhi "
					+ " ON (cnhi.cnta_id = ecco2.cnta_id) "
					+ " WHERE ecco2.orse_id        = :idOs "
					+ " AND ECCO2.ECCO_CDINCLUIDO IS NULL "
					+ " AND pgmt.cnta_id          IS NULL "
					+ " AND pghi.cnta_id IS NULL "
					+ " AND (((cnta.cnta_id IS NULL OR cnta.dcst_idatual <> 5) "
					+ "       and (cnhi.cnta_id is null OR cnhi.dcst_idatual <> 5)) "
					+ " OR NOT EXISTS " + "   (SELECT PARC.IMOV_ID "
					+ "   FROM COBRANCA.PARCELAMENTO PARC "
					+ "   LEFT JOIN FATURAMENTO.GUIA_PAGAMENTO GPAG "
					+ "   ON (GPAG.PARC_ID = PARC.PARC_ID) "
					+ "   LEFT JOIN ARRECADACAO.PAGAMENTO PGMT "
					+ "   ON (PGMT.GPAG_ID   = GPAG.GPAG_ID) "
					+ "   WHERE PARC.IMOV_ID = ECCO2.IMOV_ID "
					+ "   AND ( EXISTS " + "     (SELECT PCIT.CNTA_ID "
					+ "     FROM COBRANCA.PARCELAMENTO_ITEM PCIT "
					+ "     WHERE PCIT.CNTA_ID = ECCO2.CNTA_ID "
					+ "     AND PCIT.PARC_ID   = PARC.PARC_ID " + "     ) ) "
					+ "   AND (PARC.PARC_VLENTRADA IS NULL "
					+ "   OR PARC.PARC_VLENTRADA    = 0 "
					+ "   OR PGMT.PGST_IDATUAL     IN (0,5,10) ) " + "   ) )"
					+ " AND (cnta.cnta_id is null OR cnta.dcst_idatual <> 3) "
					+ " AND (cnhi.cnta_id is null OR cnhi.dcst_idatual <> 3) ";
			return (Integer) session.createSQLQuery(sql)
					.addScalar("qtdContas", Hibernate.INTEGER)
					.setInteger("idOs", idOs).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1320] Consultar Motivo de Não Geração Cobrança por Resultado
	 * 
	 * Atualiza a tabela de cobranca.hist_pag_cobresultado para informar que o
	 * dado foi enviado por email
	 * 
	 * @author Raimundo Martins
	 * @date 19/06/2012
	 */
	public void atualizarHistoricoPagamentoCobrancaResultadoEnviado(
			Integer idHpcr) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE HistoricoPagamentoCobrancaResultado SET hpcr_icenviado = :indicadorEnviado, "
					+ "hpcr_dtenviado = :dataEnviado, hpcr_tmultimaalteracao = :ultimaAlteracao "
					+ "WHERE hpcr_id = :id ";
			session.createQuery(sql).setDate("dataEnviado", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.setShort("indicadorEnviado", new Short("1"))
					.setInteger("id", idHpcr).executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1183] Gerar Arquivo TXT OS Contas Pagas/Parceladas
	 * 
	 * Metódo que diz se um debito a cobrar ja foi gerado no arquivo texto
	 * 
	 * @author Mariana Victor
	 * @date 05/07/2012
	 * */
	public boolean debitoACobrarEnviadoArquivoTexto(Integer idDebitoACobrar)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Integer quantidade = null;
		boolean retorno = false;

		try {
			String consulta = "SELECT count(*) AS quantidade "
					+ " FROM cobranca.hist_pag_cobresultado hpcr "
					+ " WHERE hpcr.hpcr_icenviado = 1 "
					+ "  AND hpcr.dbac_id = :idDebitoACobrar "
					+ "  AND hpcr.hpcr_nnparcela is null ";

			quantidade = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idDebitoACobrar", idDebitoACobrar)
					.setMaxResults(1).uniqueResult();

			if (quantidade != null
					&& quantidade.compareTo(new Integer("0")) > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Método que pesquisa as informações de proporcionalidade por comando
	 * 
	 * @date 20/07/2012
	 * @author Raimundo Martins
	 * */
	public Collection<Object[]> pesquisarInformacoesProporcionalidade(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT emcf.emcf_dsfaixa AS descr, "
					+ "  emcf.emcf_nncontasmin AS contasMin, "
					+ "  emcf.emcf_pcfaixa AS emprFaixa, "
					+ "  cecf.cecf_pcimovelfaixa AS comandFaixa "
					+ "FROM CADASTRO.empr_cobr_faixa emcf "
					+ "INNER JOIN COBRANCA.cmd_empr_cobr_cnta_faixa cecf "
					+ "ON cecf.emcf_id    = emcf.emcf_id "
					+ "WHERE cecf.cecc_id = :idComando";
			return session.createSQLQuery(sql)
					.addScalar("descr", Hibernate.STRING)
					.addScalar("contasMin", Hibernate.INTEGER)
					.addScalar("emprFaixa", Hibernate.BIG_DECIMAL)
					.addScalar("comandFaixa", Hibernate.BIG_DECIMAL)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1167] Consultar Comandos de Cobrança por Empresa
	 * 
	 * Metodo que verifica a quantidade de imoveis por comando
	 * 
	 * @author Raimundo Martins
	 * @date 20/07/2012
	 * */
	public Integer quantidadeImoveisPorComando(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = "SELECT COUNT(distinct ecco.imov_id) as cont FROM cobranca.empresa_cobranca_conta ecco "
					+ " WHERE ecco.cecc_id = :idComando "
					+ " AND ecco.ecco_cdincluido is null";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("cont", Hibernate.INTEGER)
					.setInteger("idComando", idComando).uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 27/07/2012
	 */
	public boolean verificarPercentualProporcionalidadeInformado(
			Integer idComando, Integer idImovel)
			throws ErroRepositorioException {

		Boolean retorno = null;
		Session session = HibernateUtil.getSession();
		Integer quantidade = null;
		try {
			String consulta = " select count(*) as quantidade "
					+ " from cobranca.emp_cob_cnta_prop cecp "
					+ " where cecp.imov_id = :idImovel and cecp.cecc_id = :idComando";

			quantidade = (Integer) session.createSQLQuery(consulta)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idComando", idComando)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();

			if (quantidade != null
					&& quantidade.compareTo(new Integer("0")) > 0)
				retorno = true;
			else
				retorno = false;

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 27/07/2012
	 */
	public Collection obterEmpresaCobrancaFaixaComando(Integer idComando)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String consulta = " select cecf "
					+ " from ComandoEmpresaCobrancaContaFaixa cecf "
					+ " inner join fetch cecf.empresaCobrancaFaixa ecf "
					+ " inner join cecf.comandoEmpresaCobrancaConta cecc "
					+ " where cecc.id = :idComando "
					+ " order by ecf.numeroMinimoContasFaixa ";

			retorno = session.createQuery(consulta)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * ======= [UC0870] - Gerar Movimento de Contas em Cobranca por Empresa
	 * 
	 * Metodo que lista os setores e quantidades de imoveis que já foram para
	 * empresa de cobranca em ordem decrescente, lista os setores que menos
	 * apareceram no comandos de cobranca.
	 * 
	 * A consulta é feita a View setoresQtdeImoveisCobrancaRes
	 * 
	 * @author Rômulo Aurélio
	 * @date 26/07/2012
	 * */
	public Collection<Object[]> recuperarSetoresPorQuantidadeImoveisComandoCobranca()
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT STCM_ID as setor, QTDE as qtde FROM setoresQtdeImoveisCobrancaRes ";

			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("setor", Hibernate.INTEGER)
					.addScalar("qtde", Hibernate.INTEGER).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamento Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @throws ErroRepositorioException
	 * @data 23/07/2012
	 * */
	public Collection<Object[]> pesquisarEmpresasParcelamentosNegociados()
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT distinct cecc.empr_id AS idEmpresa, empr.empr_dsemail AS emailEmpresa "
					+ "  FROM cobranca.cmd_empr_cobr_conta cecc "
					+ "    INNER JOIN cadastro.empresa empr ON empr.empr_id = cecc.empr_id "
					+ "  WHERE cecc.cecc_icgeracaotxt = 1 ";

			retorno = session.createSQLQuery(consulta)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("emailEmpresa", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 23/07/2012
	 * */
	public Collection<Integer> pesquisarImoveisPorComando(Integer idComando)
			throws ErroRepositorioException {
		Collection<Integer> retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String sql = "SELECT DISTINCT ecco.imov_id AS imovel "
					+ "FROM COBRANCA.empresa_cobranca_conta ecco " +
					/*
					 * "INNER JOIN COBRANCA.parcelamento_item pcit  ON pcit.cnta_id = ecco.cnta_id "
					 * +
					 * "INNER JOIN COBRANCA.parcelamento parc ON pcit.parc_id = parc.parc_id "
					 * +
					 * "INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc  ON cecc.cecc_id = ecco.cecc_id "
					 * +
					 * "WHERE ((cecc.cecc_dtencerramento is null AND parc.parc_tmparcelamento >= cecc.cecc_dtexecucao)"
					 * +
					 * "  OR(cecc.cecc_dtencerramento is not null AND parc.parc_tmparcelamento "
					 * +
					 * "BETWEEN cecc.cecc_dtexecucao AND cecc.cecc_dtencerramento))"
					 * + "AND cecc.cecc_id = :idComando ";
					 */
					"WHERE ecco.cecc_id = :idComando ";
			retorno = (Collection<Integer>) session.createSQLQuery(sql)
					.addScalar("imovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 24/07/2012
	 * */
	public Collection<Object[]> pesquisarParcelamentosPorImovel(
			Integer idImovel, Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			String sql = "SELECT DISTINCT parc.parc_id AS parcelamento, "
					+ "(COALESCE(parc.parc_vldebitoatualizado,0) - (COALESCE(parc.parc_vldescontoacrescimos,0) +"
					+ " COALESCE(parc.parc_vldescontoinatividade,0) + COALESCE(parc.parc_vldescontoantiguidade,0)) ) AS valorTotalNegociado, "
					+ "parc.parc_vlentrada AS valorEntrada, "
					+ "parc.parc_nnprestacoes AS numeroPrestacoes, "
					+ "parc.parc_vlprestacao AS valorPrestacao, "
					+ "(COALESCE(parc.parc_vldescontoacrescimos,0) + COALESCE(parc.parc_vldescontoinatividade,0) +"
					+ " COALESCE(parc.parc_vldescontoantiguidade,0)+ COALESCE(parc.parc_vldescontodebtotal,0)) AS valorDoDesconto "
					+ "FROM COBRANCA.parcelamento parc "
					+ "WHERE parc.imov_id              = :idImovel "
					+ "AND parc.parc_icenviotxtemprcob = :constanteNao "
					+ "AND parc.parc_iccobresultado    = :constanteSim "
					+ "AND parc.pcst_id                = :constanteSim "
					+ "AND parc.imov_id IN (SELECT ecco.imov_id"
					+ "					  FROM COBRANCA.parcelamento_item pcit"
					+ "					  INNER JOIN COBRANCA.empresa_cobranca_conta ecco ON pcit.cnta_id = ecco.cnta_id"
					+ "					  INNER JOIN COBRANCA.cmd_empr_cobr_conta cecc  ON cecc.cecc_id = ecco.cecc_id "
					+ "                     WHERE pcit.parc_id = parc.parc_id "
					+ "					  AND cecc.cecc_id = :idComando "
					+ "                     AND ((cecc.cecc_dtencerramento is null AND parc.parc_tmparcelamento >= cecc.cecc_dtexecucao)"
					+ "                     OR(cecc.cecc_dtencerramento is not null AND parc.parc_tmparcelamento "
					+ "                        BETWEEN cecc.cecc_dtexecucao AND cecc.cecc_dtencerramento))) ";

			return session.createSQLQuery(sql)
					.addScalar("parcelamento", Hibernate.INTEGER)
					.addScalar("valorTotalNegociado", Hibernate.BIG_DECIMAL)
					.addScalar("valorEntrada", Hibernate.BIG_DECIMAL)
					.addScalar("numeroPrestacoes", Hibernate.INTEGER)
					.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
					.addScalar("valorDoDesconto", Hibernate.BIG_DECIMAL)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando)
					.setShort("constanteNao", ConstantesSistema.NAO)
					.setShort("constanteSim", ConstantesSistema.SIM).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 24/07/2012
	 * */
	public Collection<Object[]> pesquisarContasPorParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT cnta.cnta_amreferenciaconta AS conta, ("
					+ "(coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) + coalesce(cnta.cnta_vldebitos,0))"
					+ "  - (coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0))) AS valor, "
					+ "cnta.cnta_id AS idConta "
					+ "FROM COBRANCA.parcelamento_item pcit "
					+ "INNER JOIN FATURAMENTO.conta cnta ON cnta.cnta_id = pcit.cnta_id "
					+ "INNER JOIN COBRANCA.parcelamento parc ON parc.parc_id = pcit.parc_id "
					+ "WHERE pcit.parc_id = :idParcelamento "
					+
					// "AND parc_icenviotxtemprcob = :constanteNao " +
					"group by cnta.cnta_amreferenciaconta, ( "
					+ "(coalesce(cnta.cnta_vlagua,0) + coalesce(cnta.cnta_vlesgoto,0) + coalesce(cnta.cnta_vldebitos,0))"
					+ "					  - (coalesce(cnta.cnta_vlcreditos,0) - coalesce(cnta.cnta_vlimpostos,0))), cnta.cnta_id";
			return session.createSQLQuery(sql)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.addScalar("idConta", Hibernate.INTEGER)
					.setInteger("idParcelamento", idParcelamento)
					// .setShort("constanteNao", ConstantesSistema.NAO)
					.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 24/07/2012
	 * */
	public BigDecimal pesquisarValoresDebitoACobrarParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT SUM(dbac.dbac_vldebito) AS valor "
					+ "FROM FATURAMENTO.debito_a_cobrar dbac "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit ON pcit.dbac_id = dbac.dbac_id "
					+ "INNER JOIN COBRANCA.parcelamento parc ON parc.parc_id = pcit.parc_id "
					+ "WHERE pcit.parc_id = :idParcelamento ";
			// "AND parc_icenviotxtemprcob = :constanteNao ";
			retorno = (BigDecimal) session.createSQLQuery(sql)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idParcelamento", idParcelamento)
					// .setShort("constanteNao", ConstantesSistema.NAO)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 24/07/2012
	 * */
	public BigDecimal pesquisarValoresCreditoARealizarParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT SUM(crar.crar_vlcredito) AS valor "
					+ "FROM FATURAMENTO.credito_a_realizar crar "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit ON pcit.crar_id = crar.crar_id "
					+ "INNER JOIN COBRANCA.parcelamento parc ON parc.parc_id = pcit.parc_id "
					+ "WHERE pcit.parc_id = :idParcelamento ";
			// "AND parc_icenviotxtemprcob = :constanteNao ";
			retorno = (BigDecimal) session.createSQLQuery(sql)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idParcelamento", idParcelamento)
					// .setShort("constanteNao", ConstantesSistema.NAO)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 25/07/2012
	 * */
	public BigDecimal pesquisarValoresGuiaPagamentoParcelamento(
			Integer idParcelamento) throws ErroRepositorioException {
		BigDecimal retorno = null;
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT sum(gpag.gpag_vldebito) AS valor "
					+ "FROM FATURAMENTO.guia_pagamento gpag "
					+ "INNER JOIN COBRANCA.parcelamento_item pcit ON pcit.gpag_id = gpag.gpag_id "
					+ "INNER JOIN COBRANCA.parcelamento parc ON parc.parc_id = pcit.parc_id "
					+ "WHERE pcit.parc_id = :idParcelamento ";
			// "AND parc_icenviotxtemprcob = :constanteNao ";
			retorno = (BigDecimal) session.createSQLQuery(sql)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idParcelamento", idParcelamento)
					// .setShort("constanteNao", ConstantesSistema.NAO)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 26/07/2012
	 * */
	public String pesquisarProvavelDiaVencimentoImovel(Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String retorno = null;
		try {
			String sql = "SELECT imov.imov_ddvencimento AS diaVencimento FROM CADASTRO.imovel imov WHERE imov.imov_id = :idImovel";

			retorno = (String) session.createSQLQuery(sql)
					.addScalar("diaVencimento", Hibernate.STRING)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();
			if (retorno != null && !retorno.trim().equals("")) {
				if (retorno.length() == 1)
					return "0" + retorno;
				else
					return retorno;
			} else {
				sql = "SELECT ftgr.ftgr_nndiavencimento  AS diaVencimento "
						+ "FROM FATURAMENTO.faturamento_grupo ftgr "
						+ "INNER JOIN MICROMEDICAO.rota rota ON rota.ftgr_id = ftgr.ftgr_id "
						+ "INNER JOIN CADASTRO.quadra qdra ON qdra.rota_id = rota.rota_id "
						+ "INNER JOIN CADASTRO.imovel imov ON imov.qdra_id = qdra.qdra_id "
						+ "WHERE imov.imov_id = :idImovel ";
				retorno = (String) session.createSQLQuery(sql)
						.addScalar("diaVencimento", Hibernate.STRING)
						.setInteger("idImovel", idImovel).setMaxResults(1)
						.uniqueResult();
				if (retorno.length() == 1)
					return "0" + retorno;
				else
					return retorno;

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 26/07/2012
	 * */
	public void atualizarParcelmentoNegociadoEnviado(Integer idParcelamento)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "UPDATE Parcelamento SET parc_icenviotxtemprcob = 1 WHERE parc_id = :idParcelamento ";
			session.createQuery(sql)
					.setInteger("idParcelamento", idParcelamento)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0870] - Gerar Movimento de Contas em Cobranca por Empresa
	 * 
	 * Metodo que retorna a quantidade de vezes que o imovel informado foi
	 * associado a comandos de cobranca
	 * 
	 * @author Rômulo Aurélio
	 * @date 30/07/2012
	 * */
	public Integer retornarQuantidadeVezesImovelAssociadoComandoCobranca(
			Integer idImovel) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Integer retorno = null;
		try {
			String sql = " select count (distinct ecco.cecc_id) as qtde "
					+ "from COBRANCA.empresa_cobranca_conta ecco "
					+ "where imov_id = :idImovel ";

			retorno = (Integer) session.createSQLQuery(sql)
					.addScalar("qtde", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel).setMaxResults(1)
					.uniqueResult();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0870] - Gerar Movimento de Contas em Cobranca por Empresa
	 * 
	 * Metodo que retorna os dados de empresa cobranca conta proporcionalidade
	 * 
	 * @author Rômulo Aurélio
	 * @date 31/07/2012
	 * */
	public Collection<Object[]> selecionarListaEmpresaCobrancaContaProporcionalidade(
			BigDecimal percentualFaixa, Integer idComando, Integer idImovel)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = " select ecpr.imov_id as idImovel, " // 0
					+ " ecpr.empr_id as idEmpresa,  " // 1
					+ "ecpr.cecc_id as comando,  " // 2
					+ "ecpr.cnta_id as idConta,  " // 3
					+ "ecpr.ecpr_amreferenciaconta as referenciaConta, " // 4
					+ "ecpr.ecpr_vloriginalconta as valorOriginalConta,  " // 5
					+ "ecpr.ecpr_dtenvioconta as dataEnvioConta,  " // 6
					+ "ecpr.ecpr_dtretiradaconta as dataRetiradaConta, " // 7
					+ "ecpr.ecpr_icpagamentovalido as indicadorPagamentoValido, " // 8
					+ "ecpr.ecpr_pcempresaconta as percentualEmpresa,  " // 9
					+ "ecpr.mrcb_id as idMotivoRetirada,  " // 10
					+ "imov.loca_id as idLocalidade " //11
					+ "from COBRANCA.emp_cob_cnta_prop ecpr "
					+ "inner join CADASTRO.IMOVEL imov on imov.imov_id = ecpr.imov_id "
					+ "where ecpr.ecpr_pcempresaconta = :percentualFaixa "
					+ "and cecc_id = :idComando  " + "and imov.imov_id = :imovel  ";

			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("idEmpresa", Hibernate.INTEGER)
					.addScalar("comando", Hibernate.INTEGER)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("referenciaConta", Hibernate.INTEGER)
					.addScalar("valorOriginalConta", Hibernate.BIG_DECIMAL)
					.addScalar("dataEnvioConta", Hibernate.DATE)
					.addScalar("dataRetiradaConta", Hibernate.DATE)
					.addScalar("indicadorPagamentoValido", Hibernate.SHORT)
					.addScalar("percentualEmpresa", Hibernate.BIG_DECIMAL)
					.addScalar("idMotivoRetirada", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setBigDecimal("percentualFaixa", percentualFaixa)
					.setInteger("idComando", idComando)
					.setInteger("imovel", idImovel).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 1352] Gerar TXT Parcelamentos Negociados com Empresas de Cobranca
	 * 
	 * @author Raimundo Martins
	 * @date 30/07/2012
	 * */
	public boolean existeEntradaParcelamento(Integer idParc)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {
			String sql = "select distinct parc.parc_id AS valor "
					+ "from COBRANCA.parcelamento parc "
					+ "inner join COBRANCA.empresa_cobranca_conta ecco on ecco.imov_id = parc.imov_id "
					+ "where parc.parc_vlentrada is not null "
					+ "and parc.parc_vlentrada <> 0 "
					+ "and parc.parc_id = :idParc ";
			Object ob = session.createSQLQuery(sql)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idParc", idParc).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * @author Rômulo Aurélio
	 * @date 27/04/2012
	 * 
	 *       [SB0002] Verificar Registros ja Inseridos
	 */
	public void removerContasEmpresaCobrancaContaProporcionalidade(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "DELETE EmpresaCobrancaContaProporcionalidade ecpr WHERE ecpr.comandoEmpresaCobrancaConta.id = :idComando";
			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exceção para a próxima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessão
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * pesquisa os dados necessário para gerar o relatório
	 * RelatorioRetornoOSFiscalizacao
	 * 
	 * @date 09/07/2012
	 * @author Raimundo Martins
	 * */
	public Collection<Object[]> obterDadosRelatorioRetornoOSFiscalizacao(
			InformarDadosGeracaoResumoAcaoConsultaEventualHelper helper,
			Integer cobrancaAcaoId, Integer idCobrancaAcaoSituacao,
			Integer mesAno, String[] situacoes) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "SELECT greg.greg_id AS idGerencia,"
					+ // 0
					" greg.greg_nmregional AS gerenciaRegional,"
					+ // 1
					" uneg.uneg_id AS idUnidadeNegicio,"
					+ // 2
					" uneg.uneg_nmunidadenegocio AS unidadeNegoc,"
					+ // 3
					" imov.loca_id AS localidade, "
					+ // 4
					" loca.loca_nmlocalidade AS locaDesc,   "
					+ // 5
					" fisu.fzst_id as idSituacaoEncontrada, "
					+ // 6
					" fisu.fzst_dsfiscalizacaosituacao AS situacaoEncontrada, "
					+ // 7
					" os.orse_id AS os,   "
					+ // 8
					" os.imov_id AS imovel, "
					+ // 9
					" iper.iper_dsimovelperfil AS imovelPerfil, "
					+ // 10
					" os.orse_dtfiscalizacaosituacao AS dataRetorno, "
					+ // 11
					" clie.clie_nmcliente AS nomeCliente,  "
					+ // 12
					" cbdo.cbdo_id as idDocCobr, "
					+ // 13
					" cbdo.cbdo_vldocumento as valorTotalDocCobr "
					+ // 14
					"FROM cobranca.cobranca_documento cbdo "
					+ "INNER JOIN atendimentopublico.ordem_servico os ON os.cbdo_id = cbdo.cbdo_id "
					+ "INNER JOIN cadastro.imovel imov ON imov.imov_id = os.imov_id "
					+ "INNER JOIN cadastro.localidade loca on imov.loca_id = loca.loca_id "
					+ "INNER JOIN cadastro.gerencia_regional greg on greg.greg_id = loca.greg_id "
					+ "INNER JOIN cadastro.unidade_negocio uneg on loca.uneg_id=uneg.uneg_id "
					+ "INNER JOIN cadastro.imovel_perfil iper ON imov.iper_id = iper.iper_id "
					+ "INNER JOIN cobranca.cobranca_acao_ativ_cmd cacm ON cacm.cacm_id = cbdo.cacm_id "
					+ "INNER JOIN cobranca.cobranca_acao cbac ON CACM.cbac_id = cbac.cbac_id "
					+ "INNER JOIN cobranca.cobranca_acao_situacao castu ON castu.cast_id = cbdo.cast_id "
					+ "INNER JOIN atendimentopublico.fiscalizacao_situacao fisu ON os.fzst_id = fisu.fzst_id "
					+ "INNER JOIN cadastro.cliente_imovel clim ON clim.imov_id = imov.imov_id AND clim.CRTP_ID = 2 "
					+ "AND clim.CLIM_DTRELACAOFIM IS NULL "
					+ "INNER JOIN cadastro.cliente clie "
					+ "ON clie.clie_id     = clim.clie_id "
					+ "WHERE cacm.cacm_id IN "
					+ "  (SELECT DISTINCT(re.CACM_ID) "
					+ "  FROM cobranca.resumo_cobr_acao_event re "
					+ "  INNER JOIN cobranca.cobranca_acao cbac ON(re.cbac_id = cbac.cbac_id) "
					+ "  INNER JOIN cobranca.cobranca_acao_situacao castu ON(castu.cast_id = re.cast_id) "
					+ "  INNER JOIN CADASTRO.localidade loca on re.loca_id = loca.loca_id "
					+
					// Condicionais
					this.criarCondicionaisDadosRelatorioRetornoOSFiscalizacao(helper)
					+ "  ) "
					+ " AND cbac.cbac_id  = "
					+ CobrancaAcao.INSPECAO_LIGACOES
					+ " AND castu.cast_id = "
					+ CobrancaAcaoSituacao.FISCALIZADA
					+ " AND to_char(os.ORSE_DTFISCALIZACAOSITUACAO,'yyyyMM') = :anoMes ";

			if (situacoes != null && situacoes.length > 0) {
				sql += "AND fisu.fzst_id IN(";
				for (String situ : situacoes) {
					sql += situ + ",";
				}
				sql = Util.removerUltimosCaracteres(sql, 1) + ") ";
			}

			sql += " GROUP BY greg.greg_id, greg.greg_nmregional, uneg.uneg_id, uneg.uneg_nmunidadenegocio, imov.loca_id, loca.loca_nmlocalidade,"
					+ " fisu.fzst_id, fisu.fzst_dsfiscalizacaosituacao, os.orse_id, os.imov_id,"
					+ " iper.iper_dsimovelperfil,os.orse_dtfiscalizacaosituacao,clie.clie_nmcliente, cbdo.cbdo_id, cbdo.cbdo_vldocumento "
					+ " ORDER BY greg.greg_id,uneg.uneg_id, imov.loca_id, fisu.fzst_id, clie.clie_nmcliente ";
			return session.createSQLQuery(sql)
					.addScalar("idGerencia", Hibernate.INTEGER)
					.addScalar("gerenciaRegional", Hibernate.STRING)
					.addScalar("idUnidadeNegicio", Hibernate.INTEGER)
					.addScalar("unidadeNegoc", Hibernate.STRING)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("locaDesc", Hibernate.STRING)
					.addScalar("idSituacaoEncontrada", Hibernate.INTEGER)
					.addScalar("situacaoEncontrada", Hibernate.STRING)
					.addScalar("os", Hibernate.INTEGER)
					.addScalar("imovel", Hibernate.INTEGER)
					.addScalar("imovelPerfil", Hibernate.STRING)
					.addScalar("dataRetorno", Hibernate.DATE)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("idDocCobr", Hibernate.INTEGER)
					.addScalar("valorTotalDocCobr", Hibernate.BIG_DECIMAL)
					.setString("anoMes", mesAno.toString()).list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	private String criarCondicionaisDadosRelatorioRetornoOSFiscalizacao(
			InformarDadosGeracaoResumoAcaoConsultaEventualHelper helper) {
		String retorno = " WHERE ";
		if (helper.getFormatarDataEmissaoInicial() != null
				&& helper.getFormatarDataEmissaoFinal() != null) {
			retorno += " re.RCBE_TMREALIZACAOEMITIR BETWEEN to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(helper
							.getDataInicialEmissao())
					+ "','YYYY-MM-DD') "
					+ "AND to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(helper
							.getDataFinalEmissao()) + "','YYYY-MM-DD') ";
		}
		if (helper.getIdCobrancaAcaoAtividadeComando() != null
				&& !helper.getIdCobrancaAcaoAtividadeComando().toString()
						.equals("")) {
			retorno += " AND re.CACM_ID = "
					+ helper.getIdCobrancaAcaoAtividadeComando();
		}
		if (helper.getEloPolo() != null && helper.getEloPolo().getId() != null) {
			retorno += " and loca.loca_cdelo = " + helper.getEloPolo().getId();
		}
		if (helper.getLocalidade() != null
				&& helper.getLocalidade().getId() != null) {
			retorno += " and loca.loca_id = " + helper.getLocalidade().getId();
		}
		if (helper.getSetorComercial() != null
				&& helper.getSetorComercial().getId() != null) {
			retorno += " and re.stcm_id = "
					+ helper.getSetorComercial().getId();
		}
		if (helper.getQuadra() != null && helper.getQuadra().getId() != null) {
			retorno += " and re.qdra_id = " + helper.getQuadra().getId();
		}
		if (helper.getColecaoCobrancaGrupo() != null
				&& !helper.getColecaoCobrancaGrupo().isEmpty()) {
			Iterator iterator = helper.getColecaoCobrancaGrupo().iterator();
			CobrancaGrupo cobrancaGrupo = null;
			retorno += " and re.cbgr_id in (";
			while (iterator.hasNext()) {
				cobrancaGrupo = (CobrancaGrupo) iterator.next();
				retorno += cobrancaGrupo.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoGerenciaRegional() != null
				&& !helper.getColecaoGerenciaRegional().isEmpty()) {
			Iterator iterator = helper.getColecaoGerenciaRegional().iterator();
			GerenciaRegional gerenciaRegional = null;
			retorno += " and re.greg_id in (";
			while (iterator.hasNext()) {
				gerenciaRegional = (GerenciaRegional) iterator.next();
				retorno += gerenciaRegional.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoUnidadeNegocio() != null
				&& !helper.getColecaoUnidadeNegocio().isEmpty()) {
			Iterator iterator = helper.getColecaoUnidadeNegocio().iterator();
			UnidadeNegocio unidadeNegocio = null;
			retorno += " and re.uneg_id in (";
			while (iterator.hasNext()) {
				unidadeNegocio = (UnidadeNegocio) iterator.next();
				retorno += unidadeNegocio.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoImovelPerfil() != null
				&& !helper.getColecaoImovelPerfil().isEmpty()) {
			Iterator iterator = helper.getColecaoImovelPerfil().iterator();
			ImovelPerfil imovelPerfil = null;
			retorno += " and re.iper_id in (";
			while (iterator.hasNext()) {
				imovelPerfil = (ImovelPerfil) iterator.next();
				retorno += imovelPerfil.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoLigacaoAguaSituacao() != null
				&& !helper.getColecaoLigacaoAguaSituacao().isEmpty()) {
			Iterator iterator = helper.getColecaoLigacaoAguaSituacao()
					.iterator();
			LigacaoAguaSituacao ligacaoAguaSituacao = null;
			retorno += " and re.last_id in (";
			while (iterator.hasNext()) {
				ligacaoAguaSituacao = (LigacaoAguaSituacao) iterator.next();
				retorno += ligacaoAguaSituacao.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoLigacaoEsgotoSituacao() != null
				&& !helper.getColecaoLigacaoEsgotoSituacao().isEmpty()) {
			Iterator iterator = helper.getColecaoLigacaoEsgotoSituacao()
					.iterator();
			LigacaoEsgotoSituacao ligacaoEsgotoSituacao = null;
			retorno += " and re.lest_id in (";
			while (iterator.hasNext()) {
				ligacaoEsgotoSituacao = (LigacaoEsgotoSituacao) iterator.next();
				retorno += ligacaoEsgotoSituacao.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoCategoria() != null
				&& !helper.getColecaoCategoria().isEmpty()) {
			Iterator iterator = helper.getColecaoCategoria().iterator();
			Categoria categoria = null;
			retorno += " and re.catg_id in (";
			while (iterator.hasNext()) {
				categoria = (Categoria) iterator.next();
				retorno += categoria.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoEsferaPoder() != null
				&& !helper.getColecaoEsferaPoder().isEmpty()) {
			Iterator iterator = helper.getColecaoEsferaPoder().iterator();
			EsferaPoder esferaPoder = null;
			retorno += " and re.epod_id in (";
			while (iterator.hasNext()) {
				esferaPoder = (EsferaPoder) iterator.next();
				retorno += esferaPoder.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}
		if (helper.getColecaoEmpresa() != null
				&& !helper.getColecaoEmpresa().isEmpty()) {
			Iterator iterator = helper.getColecaoEmpresa().iterator();
			Empresa empresa = null;
			retorno += " and re.empr_id in (";
			while (iterator.hasNext()) {
				empresa = (Empresa) iterator.next();
				retorno += empresa.getId() + ",";
			}
			retorno = Util.removerUltimosCaracteres(retorno, 1) + ") ";
		}

		return retorno;
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * pesquisa situação de fiscalização das ordens de serviço
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public Collection<String> obterRetornosInformados(Integer idOs)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select fzst.fzst_dsfiscalizacaosituacao as descr "
					+ " from atendimentopublico.ORDEM_SERVICO_FISC_SIT osfs "
					+ " inner join atendimentopublico.fiscalizacao_situacao fzst ON fzst.fzst_id = osfs.fzst_id "
					+ " where orse_id = :idOs ";
			return (Collection<String>) session.createSQLQuery(sql)
					.addScalar("descr", Hibernate.STRING)
					.setInteger("idOs", idOs).list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * pesquisa os debitos gerados das ordens de serviço
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public Collection<Object[]> obterDebitosGerados(Integer idOs)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = "select dbac.dbac_id as debitoACobrar, "
					+ " dbac.dcst_idatual as debitoCreditoSituacao, "
					+ " dbtp.dbtp_dsdebitotipo as debitoTipo,"
					+ " dbac.dbac_vldebito as valor "
					+ "from faturamento.debito_a_cobrar dbac "
					+ "inner join FATURAMENTO.debito_tipo dbtp on dbtp.dbtp_id = dbac.dbtp_id "
					+ "where dbtp.dbtp_id in(select distinct(dbtp_id) from atendimentopublico.FISCALIZ_SIT_SERV_A_COB) "
					+ "and orse_id = :idOs "
					+ "union "
					+ "select dahi.dbac_id as debitoACobrar, "
					+ " dahi.dcst_idatual as debitoCreditoSituacao, "
					+ " dbtp.dbtp_dsdebitotipo as debitoTipo, "
					+ " dahi.dahi_vldebito as valor "
					+ "from faturamento.deb_a_cobrar_hist dahi "
					+ "inner join FATURAMENTO.debito_tipo dbtp on dbtp.dbtp_id = dahi.dbtp_id "
					+ "where dbtp.dbtp_id in(select distinct(dbtp_id) from atendimentopublico.FISCALIZ_SIT_SERV_A_COB) "
					+ "and orse_id = :idOs ";
			return session.createSQLQuery(sql)
					.addScalar("debitoACobrar", Hibernate.INTEGER)
					.addScalar("debitoCreditoSituacao", Hibernate.INTEGER)
					.addScalar("debitoTipo", Hibernate.STRING)
					.addScalar("valor", Hibernate.BIG_DECIMAL)
					.setInteger("idOs", idOs).list();
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * verifica se um debito gerado foi pago
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public boolean isDebitoGeradoPago(Integer idDebitoCobrado)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {
			String sql = " select pgmt_id as pgmt "
					+ " from arrecadacao.pagamento "
					+ " where dbac_id = :dbac " + " union" + " select pghi_id "
					+ " from arrecadacao.pagamento_historico "
					+ " where dbac_id = :dbac ";
			Object ob = session.createSQLQuery(sql)
					.addScalar("pgmt", Hibernate.INTEGER)
					.setInteger("dbac", idDebitoCobrado).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
			return retorno;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * verifica se um debito gerado foi pago em conta
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public boolean isDebitoGeradoPagoEmConta(Integer idDebitoCobrado)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {

			String sql = " select cg.cnta_id as cnta"
					+ " from faturamento.debito_cobrado db"
					+ " inner join faturamento.conta_geral cg on(db.cnta_id = cg.cnta_id)"
					+ " where dbac_id =:dbac"
					+ " and (cg.cnta_id in(select cnta_id"
					+ " from arrecadacao.pagamento p"
					+ " where db.cnta_id = p.cnta_id)"
					+ " or cg.cnta_id in(select cnta_id"
					+ " from arrecadacao.pagamento_historico ph"
					+ " where db.cnta_id = ph.cnta_id))  "
					+ " union "
					+ " select cg.cnta_id as cnta"
					+ " from faturamento.debito_cobrado_historico db "
					+ " inner join faturamento.conta_geral cg on(db.cnta_id = cg.cnta_id)"
					+ " where dbac_id =:dbac "
					+ " and (cg.cnta_id in(select cnta_id "
					+ " from arrecadacao.pagamento p "
					+ " where db.cnta_id = p.cnta_id) "
					+ " or cg.cnta_id in(select cnta_id "
					+ " from arrecadacao.pagamento_historico ph "
					+ " where db.cnta_id = ph.cnta_id))";

			Object ob = session.createSQLQuery(sql)
					.addScalar("cnta", Hibernate.INTEGER)
					.setInteger("dbac", idDebitoCobrado).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
			return retorno;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * [UC0243] - Inserir Comando Ação de Cobrança [SB0007] - Inserir cobranca
	 * acao atividade comando
	 * 
	 * @author Hugo Azevedo
	 * @date 25/09/2012
	 * 
	 */
	public Collection obterImoveisComandoAtividadeImovel(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " select " + " cacm.imov_id as idImovel "
					+ " from cobranca.comando_ativ_imoveis cacm "
					+ " where cacm.cacm_id = :idComando ";

			if (idImovel != null)
				sql += " and cacm.imov_id = :idImovel ";

			Query q = session.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.setInteger("idComando", idComando);

			if (idImovel != null)
				q.setInteger("idImovel", idImovel);

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC0244] - Manter Comando Ação de Cobrança [SB0003] - Excluir Comando de
	 * Atividade Eventual de Ação de Cobrança
	 * 
	 * @author Hugo Azevedo
	 * @date 04/10/2012
	 * 
	 */
	public void removerImoveisComandoAtividadeImovel(Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " delete " + " ComandoAtividadeImoveis cacm "
					+ " where cacm_id = :idComando ";

			Query q = session.createQuery(sql).setInteger("idComando",
					idComando);

			q.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel
	 * 
	 * RM7818 - alterado por Ana Maria - 05/10/2012
	 * */
	public Collection pesquisarCobrancaSituacaoNaoIncluidaCriterio(
			Integer idCriterio) throws ErroRepositorioException {

		Collection retorno = null;

		String consulta;
		Session session = HibernateUtil.getSession();

		try {

			consulta = " select cbst.cbst_id as id, "
					+ " cbst_dscobrancasituacao as descricao"
					+ " from COBRANCA.cobranca_situacao cbst "
					+ " where cbst_id not in( "
					+ " select cbst_id "
					+ " from cobranca.criterio_situacao_cobr cb "
					+ " where cbct_id = :idCriterio and cb.cbst_id = cbst.cbst_id)";

			retorno = session.createSQLQuery(consulta)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idCriterio", idCriterio).list();

		} catch (HibernateException e) {
			// levanta a excecao para a proxima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Método que pesquisa se o comando possui setores associados na tabela
	 * COBRANCA.CMD_EMPR_COBR_CONTA_ACCO
	 * 
	 * @author Rômulo Aurélio
	 * @date 17/10/2011
	 * 
	 * */
	public Collection<CobrancaAcao> pesquisarComandoEmpresaCobrancaContaAcaoCobranca(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<CobrancaAcao> retorno = null;

		try {
			String sql = "SELECT ceca.acaoCobranca "
					+ " FROM ComandoEmpresaCobrancaContaAcaoCobranca ceca  "
					+ " INNER JOIN  ceca.acaoCobranca cobrancaAcao "
					+ " INNER JOIN FETCH cobrancaAcao.servicoTipo "
					+ " INNER JOIN ceca.comandoEmpresaCobrancaConta cecc "
					+ " WHERE cecc.id = :idComando "
					+ "	ORDER BY cobrancaAcao.descricaoCobrancaAcao";
			retorno = session.createQuery(sql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC0251] Gerar Atividade de Ação de Cobrança [SB0004] Verificar Critério
	 * de Cobrança para Imóvel
	 * 
	 * @author Hugo Azevedo
	 * @created 17/10/12
	 * 
	 */
	public Collection obterImoveisSituacaoLigacaoNaoAlteradaDebito(
			Integer idImovel, Date dataInicialFisc, Date dataFinalFisc)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection retorno = null;
		try {

			String sql = " select "
					+ " orse.orse_id as idOS"
					+ " from atendimentopublico.ordem_servico orse "
					+ " where orse.imov_id = :idImovel "
					+ " and orse.orse_tmencerramento is not null "
					+ " and orse.orse_icimovelfiscaldebito = 1 "
					+ " and orse.orse_dtfiscalizacaosituacao between :dataInicialFisc and :dataFinalFisc ";

			Query q = session
					.createSQLQuery(sql)
					.addScalar("idOS", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setTimestamp("dataInicialFisc",
							Util.formatarDataInicial(dataInicialFisc))
					.setTimestamp("dataFinalFisc",
							Util.formatarDataFinal(dataFinalFisc));

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Hugo Azevedo
	 * @date 15/10/2012
	 */
	public boolean verificarDocumentoAcaoCobranca(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as qtd "
					+ " from ATENDIMENTOPUBLICO.ORDEM_SERVICO orse "
					+ " where orse.AMEN_ID is null "
					+ " and orse.imov_id = :idImovel "
					+ " and orse.CBDO_ID is not null "
					+ " and orse.RGAT_ID is null "
					+ " and orse.SVTP_ID in ( "
					+ "   select cbac.svtp_id "
					+ "   from cobranca.cmd_empr_cobr_conta_acco acco "
					+ "   inner join cobranca.cobranca_acao cbac on cbac.cbac_id = acco.cbac_id "
					+ "   where acco.cecc_id = :idComando " + " ) ";

			Integer qtd = (Integer) session.createSQLQuery(sql)
					.addScalar("qtd", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (qtd != null && qtd.intValue() > 0)
				retorno = true;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC0203] - Cosultar Débitos
	 * 
	 * [SB0006] - Exibir Conta de Clientes imovel historico
	 * 
	 * @author Anderson Cabral
	 * @date 05/12/2012
	 * @throws ErroRepositorioException
	 * */
	public Collection<Conta> pesquisarContasClienteImovel(Integer idCliente,
			Integer idImovel) throws ErroRepositorioException {
		Collection<Conta> retorno = null;
		Session session = HibernateUtil.getSession();

		// Selecionar a quantidade de registros conta a partir da tabela
		// CADASTRO.CLIENTE_CONTA
		// com CLIE_ID = id do cliente
		// as contas com CNTA_ID = CNTA_ID da tabela FATURAMENTO.CONTA com
		// IMOV_ID = id do imóvel
		// e DCST_IDATUAL in (0 - Normal, 1 - Incluída ,2 - Retificada)

		try {
			String consulta = " SELECT conta "
					+ " FROM ClienteConta clienteConta "
					+ " INNER JOIN FETCH clienteConta.conta conta "
					+ " WHERE clienteConta.cliente.id = :idCliente "
					+ " AND  conta.imovel.id = :idImovel "
					+ " AND  conta.debitoCreditoSituacaoAtual.id in (0,1,2)";

			retorno = session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0203] - Cosultar Débitos
	 * 
	 * [SB0006] - Exibir Guia de Pagamento de Clientes imovel historico
	 * 
	 * @author Anderson Cabral
	 * @date 05/12/2012
	 * @throws ErroRepositorioException
	 * */
	public Collection<GuiaPagamento> pesquisarGuiasPagamentoClienteImovel(
			Integer idCliente, Integer idImovel)
			throws ErroRepositorioException {
		Collection<GuiaPagamento> retorno = null;
		Session session = HibernateUtil.getSession();

		// O sistema seleciona as guias de pagamentos a partir da tabela
		// FATURAMENTO.GUIA_PAGAMENTO com IMOV_ID = id do imóvel
		// e o DCST_IDATUAL = 0 com GPAG_ID = GPAG_ID da tabela
		// CADASTRO.CLIENTE_GUIA_PAGAMENTO com CLIE_ID = id do cliente

		try {

			String consulta = " SELECT guiaPagamento "
					+ " FROM GuiaPagamento guiaPagamento "
					+ " INNER JOIN ClienteGuiaPagamento clienteGuiaPagamento "
					+ " WHERE guiaPagamento.imovel.id = :idImovel "
					+ " AND guiaPagamento.debitoCreditoSituacaoAtual.id = 0 "
					+ " AND clienteGuiaPagamento.cliente.id = :idCliente ";

			retorno = session.createQuery(consulta)
					.setInteger("idCliente", idCliente)
					.setInteger("idImovel", idImovel).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0218] Manter Resolução Diretoria
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2012
	 * 
	 */
	public Collection<RdRestricaoUsuario> obterRdRestricaoUsuario(
			String numeroRD) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<RdRestricaoUsuario> retorno = null;

		try {
			String hql = "Select rdRestricaoUsuario "
					+ "from  RdRestricaoUsuario rdRestricaoUsuario "
					+ "inner join fetch rdRestricaoUsuario.usuario usuario "
					+ "left  join fetch usuario.unidadeOrganizacional unidadeOrganizacional "
					+ "inner join fetch rdRestricaoUsuario.resolucaoDiretoria resolucaoDiretoria "
					+ "where resolucaoDiretoria.numeroResolucaoDiretoria like :numeroRD ";

			retorno = session.createQuery(hql).setString("numeroRD", numeroRD)
					.list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC 0218] Manter Resolução Diretoria
	 * 
	 * @author Vivianne Sousa
	 * @date 12/11/2012
	 * 
	 */
	public void removerRdRestricaoUsuario(String numeroRD)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();

		try {
			// deleta o RdRestricaoUsuario
			String remover = "delete RdRestricaoUsuario rdRestricaoUsuario "
					+ "where rdRestricaoUsuario.resolucaoDiretoria.id = :numeroRD ";

			session.createQuery(remover)
					.setInteger("numeroRD", new Integer(numeroRD))
					.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0214] Efetuar Parcelamento de D?bitos
	 * 
	 * @author Vivianne Sousa
	 * @date 13/11/2012
	 * 
	 * @return Collection<ResolucaoDiretoria>
	 * @throws ErroRepositorioException
	 */
	public Collection<ResolucaoDiretoria> pesquisarResolucaoDiretoriaMaiorDataVigenciaInicioRestricaoUsuario(
			Integer usuarioLogado) throws ErroRepositorioException {

		Collection retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "select rd "
					+ "from RdRestricaoUsuario rdru "
					+ "inner join rdru.resolucaoDiretoria rd "
					+ "inner join rdru.usuario usuario  "
					+ "where usuario.id = :usuarioLogado and "
					+ " (rd.dataVigenciaFim is null or rd.dataVigenciaFim >= :dataAtual) "
					+ " and not exists (select rdlg.id from RdLimitacaoGeografica rdlg where rdlg.resolucaoDiretoria.id = rd.id)"
					+ "order by rd.dataVigenciaInicio ";

			retorno = (Collection) session.createQuery(consulta)
					.setInteger("usuarioLogado", usuarioLogado)
					.setDate("dataAtual", new Date()).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * verifica se um debito gerado foi parcelado
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public boolean isDebitoGeradoParcelado(Integer idDebitoCobrado)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {

			String sql = " select dbac_id as debito"
					+ " from cobranca.parcelamento_item pcit"
					+ " inner join cobranca.parcelamento parc on(parc.parc_id = pcit.parc_id)"
					+ " where parc.pcst_id in (" + ParcelamentoSituacao.NORMAL
					+ ", " + ParcelamentoSituacao.CONCLUIDO + ")"
					+ " and dbac_id = :dbac";

			Object ob = session.createSQLQuery(sql)
					.addScalar("debito", Hibernate.INTEGER)
					.setInteger("dbac", idDebitoCobrado).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
			return retorno;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que
	 * verifica se um debito gerado foi parcelado em conta
	 * 
	 * @date 10/07/2012
	 * @author Raimundo Martins
	 * */
	public boolean isDebitoGeradoParceladoEmConta(Integer idDebitoCobrado)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;
		try {

			String sql = " select cnta_id as cnta"
					+ " from cobranca.parcelamento_item pi"
					+ " where cnta_id in(select cnta_id"
					+ " from faturamento.debito_cobrado db"
					+ " where dbac_id =:dbac and db.cnta_id = pi.cnta_id)";

			Object ob = session.createSQLQuery(sql)
					.addScalar("cnta", Hibernate.INTEGER)
					.setInteger("dbac", idDebitoCobrado).setMaxResults(1)
					.uniqueResult();
			if (ob != null)
				retorno = true;
			return retorno;
		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que soma
	 * os itens cancelados e parcelados
	 * 
	 * @date 01/08/2012
	 * @author Ana Maria
	 * */
	public Object[] somatorioItensCancParcDocumentoCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = " select sum(somaCancelados) as somaCancelados,"
					+ // 0
					" sum(somaParcelados) as  somaParcelados"
					+ // 1
					" from (select "
					+ " SUM(CASE WHEN  DCST_IDATUAL in(3,6,8) THEN CDIT_VLITEMCOBRADO END) as somaCancelados,"
					+ " SUM(CASE WHEN  DCST_IDATUAL in(5) THEN CDIT_VLITEMCOBRADO END) as somaParcelados"
					+ " from faturamento.CONTA cnta"
					+ " inner join cobranca.cobranca_documento_item CDIT on(CDIT.cnta_id = cnta.cnta_id)"
					+ " where CDIT.cbdo_id = :idCobrancaDocumento and DCST_IDATUAL in(3,5,6,8)"
					+ " union"
					+ " select"
					+ " SUM(CASE WHEN  DCST_IDATUAL in(3,6,8) THEN CDIT_VLITEMCOBRADO END) as somaCancelados,"
					+ " SUM(CASE WHEN  DCST_IDATUAL in(5) THEN CDIT_VLITEMCOBRADO END) as somaParcelados"
					+ " from faturamento.CONTA_HISTORICO cnta"
					+ " inner join cobranca.cobranca_documento_item CDIT on(CDIT.cnta_id = cnta.cnta_id)"
					+ " where CDIT.cbdo_id = :idCobrancaDocumento and DCST_IDATUAL in(3,5,6,8)) temp";

			return (Object[]) session.createSQLQuery(sql)
					.addScalar("somaCancelados", Hibernate.BIG_DECIMAL)
					.addScalar("somaParcelados", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1353] Relatório de Retorno das Ordens de Fiscalização Método que soma
	 * os itens pagos
	 * 
	 * @date 01/08/2012
	 * @author Ana Maria
	 * */
	public BigDecimal somatorioItensPagosDocumentoCobranca(
			Integer idCobrancaDocumento) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		try {
			String sql = " select "
					+ " sum(somaPagos) as somaPagos "
					+ " from (select sum(CDIT_VLITEMCOBRADO)as somaPagos "
					+ " from arrecadacao.pagamento pgmt "
					+ " inner join faturamento.conta_geral cnta on (pgmt.cnta_id = cnta.cnta_id) "
					+ " inner join cobranca.cobranca_documento_item cdit on(cdit.cnta_id = cnta.cnta_id) "
					+ " where CDIT.cbdo_id = :idCobrancaDocumento "
					+ " union "
					+ " select sum(CDIT_VLITEMCOBRADO)as somaPagos "
					+ " from arrecadacao.pagamento_historico pghi "
					+ " inner join faturamento.conta_geral cnta on (pghi.cnta_id = cnta.cnta_id) "
					+ " inner join cobranca.cobranca_documento_item cdit on(cdit.cnta_id = cnta.cnta_id) "
					+ " where CDIT.cbdo_id = :idCobrancaDocumento)";

			return (BigDecimal) session.createSQLQuery(sql)
					.addScalar("somaPagos", Hibernate.BIG_DECIMAL)
					.setInteger("idCobrancaDocumento", idCobrancaDocumento)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * 
	 * Author: Rodrigo Cabral Data: 17/09/2012
	 * 
	 * @throws ErroRepositorioException
	 */
	public Integer obterTotalContasEmDebito(Integer idImovel,
			String anoMesInicialReferenciaDebito,
			String anoMesFinalReferenciaDebito,
			Date anoMesInicialVecimentoDebito,
			Date anoMesFinalVencimentoDebito,
			int indicadorBloqueioContasContratoParcelDebitos)
			throws ErroRepositorioException {

		Integer retorno = null;

		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT count(conta.cnta_id) as totalDebitos "
					+ " FROM faturamento.conta conta "
					+ " LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id "
					+ " WHERE conta.imov_id = :idImovel "
					+ " and conta.dcst_idatual in (:situacaoNormal, :situacaoRetificada, :situacaoIncluida, :situacaoParcelada) "
					+ " and conta.cnta_amreferenciaconta between :inicialReferencia and :finalReferencia "
					+ " and conta.cnta_dtvencimentoconta between :inicialVencimento and :finalVencimento "
					+ " and (coalesce(conta.cnta_vlagua, 0) + coalesce(conta.cnta_vlesgoto, 0) + coalesce(conta.cnta_vldebitos, 0) - coalesce(conta.cnta_vlcreditos, 0) - coalesce(conta.cnta_vlimpostos, 0)) > 0.00 ";

			if (indicadorBloqueioContasContratoParcelDebitos == 1) {
				consulta += " and conta.cnta_id not in (SELECT COUNT(*) AS quantidade from COBRANCA.contrato_parcel_item item "
						+ "inner join COBRANCA.contrato_parcel cpar on cpar.cpar_id = item.cpar_id "
						+ " where item.cnta_id = conta.cnta_id and cpar.pcst_id = "
						+ ParcelamentoSituacao.NORMAL + " ) ";
			}

			retorno = (Integer) session
					.createSQLQuery(consulta)
					.addScalar("totalDebitos", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("situacaoNormal", DebitoCreditoSituacao.NORMAL)
					.setInteger("situacaoRetificada",
							DebitoCreditoSituacao.RETIFICADA)
					.setInteger("situacaoIncluida",
							DebitoCreditoSituacao.INCLUIDA)
					.setInteger("situacaoParcelada",
							DebitoCreditoSituacao.PARCELADA)
					.setInteger("inicialReferencia",
							new Integer(anoMesInicialReferenciaDebito))
					.setInteger("finalReferencia",
							new Integer(anoMesFinalReferenciaDebito))
					.setDate("inicialVencimento", anoMesInicialVecimentoDebito)
					.setDate("finalVencimento", anoMesFinalVencimentoDebito)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] - Gerar Movimento de Contas em Cobranca por Empresa
	 * 
	 * Metodo que retorna os Imoveis para aplicar Proporcionalidade
	 * 
	 * @author Rômulo Aurélio
	 * @date 31/07/2012
	 * */
	public Collection<Object[]> selecionarListaImoveisProporcionalidade(
			BigDecimal percentualFaixa, Integer idComando, Integer numeroIndice)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = " select distinct ecpr.imov_id as idImovel, " // 0
					+ "ecpr.ecpr_nnassociadocomando as qtdeAssociadoComando " // 1
					+ "from COBRANCA.emp_cob_cnta_prop ecpr "
					+ "where ecpr.ecpr_pcempresaconta = :percentualFaixa and cecc_id = :idComando  "
					+ "order by ecpr.ecpr_nnassociadocomando asc ";

			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("qtdeAssociadoComando", Hibernate.INTEGER)
					.setBigDecimal("percentualFaixa", percentualFaixa)
					.setInteger("idComando", idComando).setMaxResults(1000)
					.setFirstResult(numeroIndice).list();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0001]
	 * Apresenta Comandos de Ação de Cobrança do Cronograma
	 * 
	 * @author Hugo Azevedo
	 * @date 29/10/2012
	 * 
	 */
	public Collection<Object[]> obterComandosAcaoCobrancaCronogramaReabrir(
			Collection<Integer> colecaoIdsComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {

			String sql = "  select "
					+ "    caac.caac_id as id, "
					+ // 0
					"	  cbgr.cbgr_dscobrancagrupo as grupoCobranca, "
					+ // 1
					"	  cbcm.cbcm_amreferencia as refCobranca, "
					+ // 2
					"	  cbac.cbac_dscobrancaacao as acaoCobranca, "
					+ // 3
					"	  aux.caac_tmrealizacao as dataEncerramento, "
					+ // 4
					"	  caac.caac_tmcomando as horaEncerramento, "
					+ // 5
					"	  (select  "
					+ "	      coalesce(count(orse.orse_id),0) as qtd "
					+ "	   from  "
					+ "	      atendimentopublico.ordem_servico orse "
					+ "	      inner join cobranca.cobranca_documento cbdo on cbdo.cbdo_id = orse.cbdo_id "
					+ "	   where "
					+ "	      orse.amen_id = 32 "
					+ "	      and cbdo.caac_id = caac.caac_id "
					+ "        and orse.orse_tmencerramento is not null "
					+ "	  ) as qtd "
					+ // 6
					"	from "
					+ "	  cobranca.cobranca_acao_ativ_crg caac "
					+ "	  inner join cobranca.cobranca_acao_cronograma cbcr on caac.cbcr_id = cbcr.cbcr_id "
					+ "	  inner join cobranca.cobranca_grupo_crg_mes cbcm on cbcr.cbcm_id = cbcm.cbcm_id "
					+ "	  inner join cobranca.cobranca_grupo cbgr on cbcm.cbgr_id = cbgr.cbgr_id "
					+ "	  inner join cobranca.cobranca_acao cbac on cbac.cbac_id = cbcr.cbac_id "
					+ "	  inner join (SELECT caac1.cbcr_id, caac1.caac_id, caac1.caac_tmrealizacao  "
					+ "	          FROM COBRANCA.cobranca_acao_ativ_crg caac1  "
					+ "	          WHERE caac1.CBAT_ID     = 3  "
					+ "	          AND caac1.CAAC_TMREALIZACAO IS NOT NULL  "
					+ "	   ) aux on (aux.cbcr_id = cbcr.cbcr_id) ";

			if (colecaoIdsComando != null && colecaoIdsComando.size() > 0) {
				sql += " WHERE caac.caac_id in (:idsComando)";
			}

			sql += " order by cbgr.cbgr_dscobrancagrupo";

			Query query = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER) // 0
					.addScalar("grupoCobranca", Hibernate.STRING) // 1
					.addScalar("refCobranca", Hibernate.INTEGER) // 2
					.addScalar("acaoCobranca", Hibernate.STRING) // 3
					.addScalar("dataEncerramento", Hibernate.DATE) // 4
					.addScalar("horaEncerramento", Hibernate.DATE) // 5
					.addScalar("qtd", Hibernate.INTEGER); // 6

			if (colecaoIdsComando != null && colecaoIdsComando.size() > 0) {
				query.setParameterList("idsComando", colecaoIdsComando);
			}

			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança
	 * 
	 * @author Hugo Azevedo
	 * @date 04/12/2012
	 * 
	 */
	public Collection<Integer> obterComandosAcaoCobrancaCronogramaReabrirEncerrados(
			Integer idComando) throws ErroRepositorioException {

		Collection<Integer> retorno = new ArrayList<Integer>();
		Session session = HibernateUtil.getSession();

		try {

			String sql = " SELECT caac_id as id FROM cobranca.COBRANCA_ACAO_ATIV_CRG WHERE CBAT_ID = 3 AND cbcr_id IN "
					+ "   (SELECT cbcr_id "
					+ "   FROM cobranca.COBRANCA_ACAO_ATIV_CRG caac "
					+ "   WHERE CAAC_ID = :idComando ) ";

			Query query = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER) // 0
					.setInteger("idComando", idComando);

			retorno = (Collection<Integer>) query.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0002]
	 * Apresenta Comandos de Ação de Cobrança Eventuais
	 * 
	 * @author Hugo Azevedo
	 * @date 29/10/2012
	 * 
	 */
	public Collection<Object[]> obterComandosAcaoCobrancaEventualReabrir(
			Collection<Integer> colecaoIdsComando)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {

			String sql = " select "
					+ " 	cacm.cacm_id as id, "
					+ // 0
					" 	cacm.cacm_dstitulo as descComando, "
					+ // 1
					" 	cbac.cbac_dscobrancaacao as acaoCobranca, "
					+ // 2
					" 	cacm.cacm_dtencerramentorealizada as dtEncerramento, "
					+ // 3
					" 	(select  "
					+ " 		coalesce(count(orse.orse_id),0) as qtd "
					+ " 	 from  "
					+ " 		atendimentopublico.ordem_servico orse "
					+ " 		inner join cobranca.cobranca_documento cbdo on cbdo.cbdo_id = orse.cbdo_id "
					+ " 	where "
					+ " 		orse.amen_id = 32 "
					+ " 		and cbdo.cacm_id = cacm.cacm_id "
					+ " 		and orse.orse_tmencerramento is not null "
					+ " 	) as qtd "
					+ // 4
					" from "
					+ " 	cobranca.cobranca_acao_ativ_cmd cacm "
					+ " 	inner join cobranca.cobranca_acao cbac on cbac.cbac_id = cacm.cbac_id ";

			if (colecaoIdsComando != null && colecaoIdsComando.size() > 0) {
				sql += " where cacm.cacm_id in (:idsComando)";
			}

			sql += " order by cacm.cacm_dtencerramentorealizada";

			Query query = session.createSQLQuery(sql)
					.addScalar("id", Hibernate.INTEGER)
					.addScalar("descComando", Hibernate.STRING)
					.addScalar("acaoCobranca", Hibernate.STRING)
					.addScalar("dtEncerramento", Hibernate.DATE)
					.addScalar("qtd", Hibernate.INTEGER);

			if (colecaoIdsComando != null && colecaoIdsComando.size() > 0) {
				query.setParameterList("idsComando", colecaoIdsComando);
			}

			retorno = (Collection<Object[]>) query.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0003]
	 * Reabrir Comandos Cronograma
	 * 
	 * @author Hugo Azevedo
	 * @param colecaoIdsComando
	 * @date 05/11/2012
	 * 
	 */
	public void excluirUnidadesEncerramentoOSDecursoPrazoCronograma(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			Connection jdbcCon = session.connection();

			String sql = " delete from atendimentopublico.ordem_servico_unidade osun where osun.osun_id in ("
					+ " 	select "
					+ "   	osun.osun_id "
					+ " 	from "
					+ "   	atendimentopublico.ordem_servico_unidade osun "
					+ "    	inner join atendimentopublico.ordem_servico orse on orse.orse_id = osun.orse_id "
					+ "    	inner join cobranca.cobranca_documento cbdo on cbdo.cbdo_id = orse.cbdo_id "
					+ " 	where "
					+ "   	osun.attp_id = 3 "
					+ "    	and orse.orse_tmencerramento is not null "
					+ "    	and cbdo.amen_id = 32 "
					+ "    	and cbdo.caac_id = ? " + " )";

			st = jdbcCon.prepareStatement(sql);
			st.setInt(1, idComando.intValue());

			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0003]
	 * Reabrir Comandos Cronograma
	 * 
	 * @author Hugo Azevedo
	 * @param colecaoIdsComando
	 * @date 05/11/2012
	 * 
	 */
	public void reabrirOrdensServiçoDecursoPrazoCronograma(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.atendimentopublico.ordemservico.OrdemServico "
					+ " set "
					+ "		ORSE_CDSITUACAO = 1, "
					+ "		ORSE_TMENCERRAMENTO = null,"
					+ "		ORSE_DSPARECERENCERRAMENTO = null,"
					+ "		AMEN_ID = null "
					+ " where "
					+ "		orse_tmencerramento IS NOT NULL "
					+ "		and cbdo_id in ( "
					+ "			select "
					+ " 				cbdo.id "
					+ "			from "
					+ "   			gcom.cobranca.CobrancaDocumento cbdo "
					+ "			where "
					+ "   			cbdo.motivoEncerramento.id = 32 "
					+ "   			and cbdo.cobrancaAcaoAtividadeCronograma.id = :idComando "
					+ " 		)";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0003]
	 * Reabrir Comandos Cronograma
	 * 
	 * @author Hugo Azevedo
	 * @date 06/11/2012
	 * 
	 */
	public void reabrirDocumentosCobrancaOrdensServicoDecursoPrazoCronograma(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.cobranca.CobrancaDocumento cbdo"
					+ " set "
					+ "		CAST_ID = 1, "
					+ "		AMEN_ID = null "
					+ " where "
					+ "   	cbdo.motivoEncerramento.id = 32 "
					+ "   	and cbdo.cobrancaAcaoAtividadeCronograma.id = :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0003]
	 * Reabrir Comandos Cronograma
	 * 
	 * @author Hugo Azevedo
	 * @date 06/11/2012
	 * 
	 */
	public void reabrirComandoCobrancaDecursoPrazoCronograma(Integer idComando,
			Date novaDataEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.cobranca.CobrancaAcaoAtividadeCronograma caac "
					+ " set "
					+ "		CAAC_DTPREVISTA = :novaDataEncerramento where "
					+ "		caac.id = :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.setDate("novaDataEncerramento", novaDataEncerramento)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0004]
	 * Reabrir Comandos Eventual
	 * 
	 * @author Hugo Azevedo
	 * @param colecaoIdsComando
	 * @date 05/11/2012
	 * 
	 */
	public void excluirUnidadesEncerramentoOSDecursoPrazoEventual(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {
			Connection jdbcCon = session.connection();

			String sql = " delete from atendimentopublico.ordem_servico_unidade osun where osun.osun_id in ("
					+ " 	select "
					+ "   	osun.osun_id "
					+ " 	from "
					+ "   	atendimentopublico.ordem_servico_unidade osun "
					+ "    	inner join atendimentopublico.ordem_servico orse on orse.orse_id = osun.orse_id "
					+ "    	inner join cobranca.cobranca_documento cbdo on cbdo.cbdo_id = orse.cbdo_id "
					+ " 	where "
					+ "   	osun.attp_id = 3 "
					+ "    	and orse.orse_tmencerramento is not null "
					+ "    	and cbdo.amen_id = 32 "
					+ "    	and cbdo.cacm_id = ? " + " )";

			st = jdbcCon.prepareStatement(sql);
			st.setInt(1, idComando.intValue());

			st.executeUpdate();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0004]
	 * Reabrir Comandos Eventual
	 * 
	 * @author Hugo Azevedo
	 * @param colecaoIdsComando
	 * @date 05/11/2012
	 * 
	 */
	public void reabrirOrdensServiçoDecursoPrazoEventual(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.atendimentopublico.ordemservico.OrdemServico "
					+ " set "
					+ "		ORSE_CDSITUACAO = 1, "
					+ "		ORSE_TMENCERRAMENTO = null,"
					+ "		ORSE_DSPARECERENCERRAMENTO = null,"
					+ "		AMEN_ID = null "
					+ " where "
					+ "		orse_tmencerramento IS NOT NULL "
					+ "		and cbdo_id in ( "
					+ "			select "
					+ " 				cbdo.id "
					+ "			from "
					+ "   			gcom.cobranca.CobrancaDocumento cbdo "
					+ "			where "
					+ "   			cbdo.motivoEncerramento.id = 32 "
					+ "   			and cbdo.cobrancaAcaoAtividadeComando.id = :idComando "
					+ " 		)";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0004]
	 * Reabrir Comandos Eventual
	 * 
	 * @author Hugo Azevedo
	 * @date 06/11/2012
	 * 
	 */
	public void reabrirDocumentosCobrancaOrdensServicoDecursoPrazoEventual(Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.cobranca.CobrancaDocumento cbdo"
					+ " set "
					+ "		CAST_ID = 1, "
					+ "		AMEN_ID = null "
					+ " where "
					+ "   	cbdo.motivoEncerramento.id = 32 "
					+ "   	and cbdo.cobrancaAcaoAtividadeComando.id = :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1384] Reabrir Comando de Atividade de Ação de Cobrança [IT0004]
	 * Reabrir Comandos Eventual
	 * 
	 * @author Hugo Azevedo
	 * @date 06/11/2012
	 * 
	 */
	public void reabrirComandoCobrancaDecursoPrazoEventual(Integer idComando,
			Date novaDataEncerramento) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update "
					+ " 		gcom.cobranca.CobrancaAcaoAtividadeComando cacm "
					+ " set "
					+ "		CACM_DTENCERRAMENTOPREVISTA = :novaDataEncerramento, "
					+ "		CACM_DTENCERRAMENTOREALIZADA = null " + "		where "
					+ "		cacm.id = :idComando ";

			session.createQuery(sql).setInteger("idComando", idComando)
					.setDate("novaDataEncerramento", novaDataEncerramento)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0326] Filtrar Comandos de Ação de Cobrança
	 * 
	 * @author Rômulo Aurélio
	 * @date 26/11/2012
	 * 
	 */
	public Collection<Object[]> consultarComandosAtividadeCronograma(
			String periodoReferenciaCobrancaInicial,
			String periodoReferenciaCobrancaFinal, String[] grupoCobranca,
			String[] acaoCobranca, Date periodoEncerramentoComandoInicial,
			Date periodoEncerramentoComandoFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {

			String sql = "  SELECT cobrancaAcaoAtvCrono.caac_id as idComando "
					+ " FROM cobranca.cobranca_acao_ativ_crg cobrancaAcaoAtvCrono "
					+ " INNER JOIN cobranca.cobranca_acao_cronograma cobrancaAcaoCrono ON cobrancaAcaoAtvCrono.cbcr_id=cobrancaAcaoCrono.cbcr_id "
					+ " INNER JOIN cobranca.cobranca_acao cobrancaAcao ON cobrancaAcaoCrono.cbac_id=cobrancaAcao.cbac_id "
					+ " INNER JOIN cobranca.cobranca_grupo_crg_mes cobrancaGrupoCronogramaMes ON cobrancaAcaoCrono.cbcm_id=cobrancaGrupoCronogramaMes.cbcm_id "
					+ " INNER JOIN cobranca.cobranca_grupo cobrancaGrupo ON cobrancaGrupoCronogramaMes.cbgr_id=cobrancaGrupo.cbgr_id "
					+ " INNER JOIN cobranca.cobranca_atividade cobrancaAtividade ON cobrancaAcaoAtvCrono.cbat_id=cobrancaAtividade.cbat_id "
					+ " WHERE cobrancaAcaoAtvCrono.cbat_id = 2 "
					+ " and cobrancaAcaoAtvCrono.cbcr_id in "
					+ " (select caac1.cbcr_id "
					+ " from COBRANCA.cobranca_acao_ativ_crg caac1 "
					+ " where caac1.CBAT_ID = 3 and caac1.CAAC_TMREALIZACAO IS NOT NULL and caac1.cbcr_id = cobrancaAcaoAtvCrono.cbcr_id";

			if (periodoEncerramentoComandoInicial != null
					&& !periodoEncerramentoComandoInicial.equals("")
					&& periodoEncerramentoComandoFinal != null
					&& !periodoEncerramentoComandoFinal.equals("")) {
				sql += " AND (to_date(to_char(caac1.caac_tmrealizacao,'YYYYMMDD'),'YYYYMMDD')  BETWEEN to_date("
						+ Util.formatarDataAAAAMMDD(periodoEncerramentoComandoInicial)
						+ ",'YYYYMMDD') "
						+ "AND to_date("
						+ Util.formatarDataAAAAMMDD(periodoEncerramentoComandoFinal)
						+ ",'YYYYMMDD')) ";
			}

			sql += " ) ";

			if (periodoReferenciaCobrancaInicial != null
					&& !periodoReferenciaCobrancaInicial.equals("")
					&& periodoReferenciaCobrancaFinal != null
					&& !periodoReferenciaCobrancaFinal.equals("")) {
				sql += " AND (cobrancaGrupoCronogramaMes.cbcm_amreferencia BETWEEN "
						+ Util.formatarMesAnoParaAnoMesSemBarra(periodoReferenciaCobrancaInicial)
						+ " AND "
						+ Util.formatarMesAnoParaAnoMesSemBarra(periodoReferenciaCobrancaFinal)
						+ ")";
			}

			if (acaoCobranca != null && acaoCobranca.length > 0
					&& !acaoCobranca[0].trim().equals("-1")
					&& !acaoCobranca[0].trim().equals("")) {

				String acoes = "";

				for (int i = 0; i < acaoCobranca.length; i++) {
					acoes += acaoCobranca[i] + ",";
				}

				acoes = Util.removerUltimosCaracteres(acoes, 1);
				sql += " AND cobrancaAcaoCrono.cbac_id in (" + acoes + " ) ";
			}

			if (grupoCobranca != null && !grupoCobranca.equals("")
					&& !grupoCobranca[0].trim().equals("-1")
					&& !grupoCobranca[0].trim().equals("")) {
				String grupos = "";
				for (int i = 0; i < grupoCobranca.length; i++) {
					grupos += grupoCobranca[i] + ",";
				}

				grupos = Util.removerUltimosCaracteres(grupos, 1);
				sql += "	AND cobrancaGrupoCronogramaMes.cbgr_id in (" + grupos
						+ " ) ";
			}

			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("idComando", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0326] Filtrar Comandos de Ação de Cobrança
	 * 
	 * @author Rômulo Aurélio
	 * @date 26/11/2012
	 * 
	 */
	public Collection<Object[]> consultarComandosAtividadeCronogramaEventual(
			String[] grupoCobranca, String[] acaoCobranca,
			Date periodoEncerramentoComandoInicial,
			Date periodoEncerramentoComandoFinal, String idCriterio,
			Date emissaoInicial, Date emissaoFinal)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = new ArrayList<Object[]>();
		Session session = HibernateUtil.getSession();

		try {

			String sql = "  SELECT cobacaoativcom.cacm_id as idComando "
					+ " from COBRANCA.cobranca_acao_ativ_cmd cobAcaoAtivCom "
					+ " WHERE cobAcaoAtivCom.cacm_dtencerramentorealizada IS NOT NULL ";

			/*
			 * if (idCobrancaAcaoAtividadeComando != null &&
			 * idCobrancaAcaoAtividadeComando.length > 0 &&
			 * !idCobrancaAcaoAtividadeComando[0].trim().equals("-1") &&
			 * !idCobrancaAcaoAtividadeComando[0].trim().equals("")) {
			 * 
			 * String comandos = "";
			 * 
			 * for (int i = 0; i < idCobrancaAcaoAtividadeComando.length; i++) {
			 * comandos = idCobrancaAcaoAtividadeComando[i] + ","; }
			 * 
			 * comandos = Util.removerUltimosCaracteres(comandos, 1); sql +=
			 * " AND cobAcaoAtivCom.cacm_id in (" + comandos + " ) "; }
			 */

			if (acaoCobranca != null && acaoCobranca.length > 0
					&& !acaoCobranca[0].trim().equals("-1")
					&& !acaoCobranca[0].trim().equals("")) {

				String acoes = "";

				for (int i = 0; i < acaoCobranca.length; i++) {
					acoes += acaoCobranca[i] + ",";
				}

				acoes = Util.removerUltimosCaracteres(acoes, 1);
				sql += " AND cobAcaoAtivCom.cbac_id in (" + acoes + " ) ";
			}

			if (periodoEncerramentoComandoInicial != null
					&& !periodoEncerramentoComandoInicial.equals("")
					&& periodoEncerramentoComandoFinal != null
					&& !periodoEncerramentoComandoFinal.equals("")) {
				sql += " AND (to_date(to_char(cobAcaoAtivCom.cacm_dtencerramentorealizada ,'YYYYMMDD'),'YYYYMMDD')  BETWEEN to_date("
						+ Util.formatarDataAAAAMMDD(periodoEncerramentoComandoInicial)
						+ ",'YYYYMMDD') "
						+ "AND to_date("
						+ Util.formatarDataAAAAMMDD(periodoEncerramentoComandoFinal)
						+ ",'YYYYMMDD')) ";
			}

			if (emissaoInicial != null && !emissaoInicial.equals("")
					&& emissaoFinal != null && !emissaoFinal.equals("")) {
				sql += " AND (to_date(to_char(cobAcaoAtivCom.cacm_tmcomando ,'YYYYMMDD'),'YYYYMMDD')  BETWEEN to_date("
						+ Util.formatarDataAAAAMMDD(emissaoInicial)
						+ ",'YYYYMMDD') "
						+ "AND to_date("
						+ Util.formatarDataAAAAMMDD(emissaoFinal)
						+ ",'YYYYMMDD')) ";
			}

			if (grupoCobranca != null && !grupoCobranca.equals("")
					&& !grupoCobranca[0].trim().equals("-1")
					&& !grupoCobranca[0].trim().equals("")) {
				String grupos = "";
				for (int i = 0; i < grupoCobranca.length; i++) {
					grupos += grupoCobranca[i] + ",";
				}

				grupos = Util.removerUltimosCaracteres(grupos, 1);
				sql += "	AND cobAcaoAtivCom.cbgr_id in (" + grupos + " ) ";
			}

			if (idCriterio != null && !idCriterio.equals("")) {
				sql += "	AND cobAcaoAtivCom.cbct_id = " + idCriterio + " ";

			}

			retorno = (Collection<Object[]>) session.createSQLQuery(sql)
					.addScalar("idComando", Hibernate.INTEGER).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1054] Gerar Ordem de Corte
	 * 
	 * @author Hugo Azevedo
	 * @date 22/02/2013
	 * 
	 */
	public Integer pesquisarQtdDebitoAvisoCorteCobAnterior(Integer idImovel,
			Integer id, Date dataEmissaoValidacaoAcaoPrecente,
			Collection<Integer> colecaoIdsContas)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String sql = " SELECT count(distinct(cbdo.cbdo_id)) AS qtdIdCobrancaDocumento "
					+ " FROM cobranca.cobranca_documento cbdo "
					+ " INNER JOIN cobranca.documento_tipo dotp ON dotp.dotp_id = cbdo.dotp_id "
					+ " LEFT JOIN faturamento.documento_nao_entregue done ON done.cbdo_id = cbdo.cbdo_id "
					+ " INNER JOIN COBRANCA.cobranca_documento_item cdit ON cdit.cbdo_id = cbdo.cbdo_id "
					+ " WHERE cbdo.imov_id = :idImovel "
					+ " AND dotp.dotp_id   = :idDocumentoTipo "
					+ " AND (done.dotp_id IS NULL OR done.dotp_id  <> dotp.dotp_id)  "
					+ " AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade "
					+ " AND cdit.cnta_id in (:idsContas) ";

			retorno = (Integer) session
					.createSQLQuery(sql)
					.addScalar("qtdIdCobrancaDocumento", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idDocumentoTipo", id)
					.setDate("dataEmissaoValidade",
							dataEmissaoValidacaoAcaoPrecente)
					.setParameterList("idsContas", colecaoIdsContas)
					.setMaxResults(1).uniqueResult();

			return retorno;

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void inserirEmpresaCobrancaConta(
			EmpresaCobrancaConta empresaCobrancaConta)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String insert;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			insert = "INSERT INTO cobranca.empresa_cobranca_conta ("
					+ "  ecco_id, " + "  empr_id, " + "  cnta_id, "
					+ "  cecc_id, " + "  imov_id, " + "  orse_id, "
					+ "  mrcb_id, " + "  ecco_vloriginalconta, "
					+ "  ecco_pcempresaconta, " + "  ecco_icpagamentovalido, "
					+ "  ecco_tmultimaalteracao, "
					+ "  ecco_amreferenciaconta, " + "  ecco_dtenvioconta, "
					+ "  ecco_dtretiradaconta, loca_id) " + "  VALUES ( "
					+ "  cobranca.seq_empresa_cobranca_conta.nextval, ";

			if (empresaCobrancaConta.getEmpresa() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getContaGeral() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getComandoEmpresaCobrancaConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getImovel() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getOrdemServico() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getMotivoRetirada() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getValorOriginalConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getPercentualEmpresaConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getIndicadorPagamentoValido() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			insert += "sysdate, ?, ";

			if (empresaCobrancaConta.getDataEnvioConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getDataRetiradaConta() != null) {
				insert += "?) ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaConta.getLocalidade() != null) {
				insert += "?) ";
			} else {
				insert += "null) ";
			}
			
			st = con.prepareStatement(insert);

			int i = 1;

			if (empresaCobrancaConta.getEmpresa() != null) {
				st.setInt(i, empresaCobrancaConta.getEmpresa().getId());
				i++;
			}

			if (empresaCobrancaConta.getContaGeral() != null) {
				st.setInt(i, empresaCobrancaConta.getContaGeral().getId());
				i++;
			}

			if (empresaCobrancaConta.getComandoEmpresaCobrancaConta() != null) {
				st.setInt(i, empresaCobrancaConta
						.getComandoEmpresaCobrancaConta().getId());
				i++;
			}

			if (empresaCobrancaConta.getImovel() != null) {
				st.setInt(i, empresaCobrancaConta.getImovel().getId());
				i++;
			}

			if (empresaCobrancaConta.getOrdemServico() != null) {
				st.setInt(i, empresaCobrancaConta.getOrdemServico().getId());
				i++;
			}

			if (empresaCobrancaConta.getMotivoRetirada() != null) {
				st.setInt(i, empresaCobrancaConta.getMotivoRetirada().getId());
				i++;
			}

			if (empresaCobrancaConta.getValorOriginalConta() != null) {
				st.setBigDecimal(i,
						empresaCobrancaConta.getValorOriginalConta());
				i++;
			}

			if (empresaCobrancaConta.getPercentualEmpresaConta() != null) {
				st.setBigDecimal(i,
						empresaCobrancaConta.getPercentualEmpresaConta());
				i++;
			}

			if (empresaCobrancaConta.getIndicadorPagamentoValido() != null) {
				st.setShort(i,
						empresaCobrancaConta.getIndicadorPagamentoValido());
				i++;
			}

			st.setInt(i, empresaCobrancaConta.getAnoMesReferenciaConta());
			i++;

			if (empresaCobrancaConta.getDataEnvioConta() != null) {
				st.setDate(i, Util.getSQLDate(empresaCobrancaConta
						.getDataEnvioConta()));
				i++;
			}

			if (empresaCobrancaConta.getDataRetiradaConta() != null) {
				st.setDate(i, Util.getSQLDate(empresaCobrancaConta
						.getDataRetiradaConta()));
				i++;
			}
			
			if (empresaCobrancaConta.getLocalidade() != null) {
				st.setInt(i, empresaCobrancaConta.getLocalidade().getId());
				i++;
			}
			
			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void inserirEmpresaCobrancaContaProporcionalidade(
			EmpresaCobrancaContaProporcionalidade empresaCobrancaContaProporcionalidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String insert;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			insert = "INSERT INTO cobranca.emp_cob_cnta_prop (" + "  ecpr_id, "
					+ "  empr_id, " + "  cnta_id, " + "  cecc_id, "
					+ "  imov_id, " + "  mrcb_id, " + "  stcm_id, "
					+ "  ecpr_vloriginalconta, " + "  ecpr_pcempresaconta, "
					+ "  ecpr_icpagamentovalido, "
					+ "  ecpr_tmultimaalteracao, "
					+ "  ecpr_amreferenciaconta, " + "  ecpr_dtenvioconta, "
					+ "  ecpr_dtretiradaconta, "
					+ "  ECPR_NNASSOCIADOCOMANDO) " + "  VALUES ( "
					+ "  cobranca.seq_emp_cob_cnta_prop.nextval, ";

			if (empresaCobrancaContaProporcionalidade.getEmpresa() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getContaGeral() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade
					.getComandoEmpresaCobrancaConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getImovel() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getMotivoRetirada() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getSetorComercial() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getValorOriginalConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade
					.getPercentualEmpresaConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade
					.getIndicadorPagamentoValido() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			insert += "sysdate, ?, ";

			if (empresaCobrancaContaProporcionalidade.getDataEnvioConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade.getDataRetiradaConta() != null) {
				insert += "?, ";
			} else {
				insert += "null, ";
			}

			if (empresaCobrancaContaProporcionalidade
					.getQuantidadeVezesAssociadoComandos() != null) {
				insert += "?) ";
			} else {
				insert += "null) ";
			}

			st = con.prepareStatement(insert);

			int i = 1;

			if (empresaCobrancaContaProporcionalidade.getEmpresa() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade.getEmpresa()
						.getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getContaGeral() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade
						.getContaGeral().getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade
					.getComandoEmpresaCobrancaConta() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade
						.getComandoEmpresaCobrancaConta().getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getImovel() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade.getImovel()
						.getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getMotivoRetirada() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade
						.getMotivoRetirada().getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getSetorComercial() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade
						.getSetorComercial().getId());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getValorOriginalConta() != null) {
				st.setBigDecimal(i, empresaCobrancaContaProporcionalidade
						.getValorOriginalConta());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade
					.getPercentualEmpresaConta() != null) {
				st.setBigDecimal(i, empresaCobrancaContaProporcionalidade
						.getPercentualEmpresaConta());
				i++;
			}

			if (empresaCobrancaContaProporcionalidade
					.getIndicadorPagamentoValido() != null) {
				st.setShort(i, empresaCobrancaContaProporcionalidade
						.getIndicadorPagamentoValido());
				i++;
			}

			st.setInt(i, empresaCobrancaContaProporcionalidade
					.getAnoMesReferenciaConta());
			i++;

			if (empresaCobrancaContaProporcionalidade.getDataEnvioConta() != null) {
				st.setDate(i, Util
						.getSQLDate(empresaCobrancaContaProporcionalidade
								.getDataEnvioConta()));
				i++;
			}

			if (empresaCobrancaContaProporcionalidade.getDataRetiradaConta() != null) {
				st.setDate(i, Util
						.getSQLDate(empresaCobrancaContaProporcionalidade
								.getDataRetiradaConta()));
				i++;
			}

			if (empresaCobrancaContaProporcionalidade
					.getQuantidadeVezesAssociadoComandos() != null) {
				st.setInt(i, empresaCobrancaContaProporcionalidade
						.getQuantidadeVezesAssociadoComandos());
				i++;
			}

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void removerComandoEmpresaCobrancaContaImovel(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String delete;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			delete = "DELETE FROM cobranca.cmd_empr_cobr_conta_imov WHERE cecc_id = ?";

			st = con.prepareStatement(delete);
			st.setInt(1, idComando);

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void removerComandoEmpresaCobrancaContaConta(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String delete;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			delete = "DELETE FROM cobranca.cmd_empr_cobr_conta_cnta WHERE cecc_id = ?";

			st = con.prepareStatement(delete);
			st.setInt(1, idComando);

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa as contas associadas ao im?vel
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 */
	public void inserirComandoEmpresaCobrancaContaConta(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			SistemaParametro sistemaParametro,
			ComandoEmpresaCobrancaContaHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String insert = null;
		String estatistica = null;

		Connection con = null;
		PreparedStatement st = null;
		CallableStatement call = null;

		try {

			con = session.connection();

			insert = "INSERT INTO cobranca.cmd_empr_cobr_conta_cnta ";

			insert += "SELECT auxImov.cecc_id as idComando, conta.cnta_id as idConta, (  	coalesce( conta.cnta_vlagua, 0 ) + "
					+ " 	coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) - "
					+ " 	coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) "
					+ " ) as valorConta, 1 as indicadorPagamentoValido, conta.imov_id as idImovel, "
					+ "conta.cnta_amreferenciaconta as referenciaConta, imov.stcm_id as idSetorComercialImovel, coalesce(aux.qtde, 0) as quantidadeComando "
					+ " FROM cobranca.cmd_empr_cobr_conta_imov auxImov "
					+ " INNER JOIN faturamento.conta conta on auxImov.imov_id = conta.imov_id "
					+ " INNER JOIN cadastro.imovel imov on imov.imov_id = conta.imov_id "
					+ " INNER JOIN cadastro.localidade loca on loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id "
					+ " INNER JOIN cadastro.sistema_parametros sp ON 1=1 "
					+ " LEFT OUTER JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id and pagto.pgst_idatual is not null "

					+ " left join ( select ecco.imov_id, count (distinct ecco.cecc_id) as qtde "
					+ " from COBRANCA.empresa_cobranca_conta ecco group by ecco.imov_id) aux on aux.imov_id = imov.imov_id "

					+ " WHERE "
					+ " conta.cnta_amreferenciaconta < sp.parm_amreferenciaarrecadacao "
					+ " and conta.cmrv_id is null and conta.cnta_dtrevisao is null "
					+ " and pagto.pgmt_id is null and conta.dcst_idatual in ("
					+ DebitoCreditoSituacao.INCLUIDA
					+ ", "
					+ DebitoCreditoSituacao.NORMAL
					+ ", "
					+ DebitoCreditoSituacao.RETIFICADA + ") ";

			// QUANTIDADE DE DIAS DE VENCIMENTO
			String dataVencimentoConta = null;

			// INTERVALO REFERÊNCIA DE CONTA SUBQUERY
			Integer referenciaInicialSubquery = null;
			Integer referenciaFinalSubquery = null;

			// INTERVALO VALOR DE CONTA SUBQUERY
			BigDecimal valorMinimoContaSubquery = null;
			BigDecimal valorMaximoContaSubquery = null;

			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {

				dataVencimentoConta = Util.formatarDataComTracoAAAAMMDD(Util
						.subtrairNumeroDiasDeUmaData(new Date(),
								comandoEmpresaCobrancaConta
										.getQtdDiasVencimento()));

				// 2.1.19.1. Caso o indicador para incluir contas fora do
				// vencimento para cobrança corresponda a NÃO
				if (sistemaParametro.getIndicadorIncluirContasForaVenCobranca()
						.compareTo(ConstantesSistema.NAO) == 0) {

					insert = insert
							+ " and conta.cnta_dtvencimentoconta <= to_date(?,'YYYY-MM-DD') ";

				} else {

					insert = insert
							+ " and exists (select distinct cnta2.imov_id "
							+ " 			from faturamento.conta cnta2 "
							+ "				where cnta2.cnta_dtvencimentoconta <= to_date(?,'YYYY-MM-DD') and cnta2.imov_id = conta.imov_id "
							+ " 				and cnta2.cnta_amreferenciaconta < sp.parm_amreferenciaarrecadacao "
							+ " 				and cnta2.cmrv_id is null and cnta2.cnta_dtrevisao is null ";

					insert = insert + " and cnta2.dcst_idatual in ("
							+ DebitoCreditoSituacao.INCLUIDA + ", "
							+ DebitoCreditoSituacao.NORMAL + ", "
							+ DebitoCreditoSituacao.RETIFICADA + ") ";

					if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

						insert = insert
								+ " and cnta2.cnta_amreferenciaconta between ? and ? ";

						referenciaInicialSubquery = comandoEmpresaCobrancaConta
								.getReferenciaContaInicial();
						referenciaFinalSubquery = comandoEmpresaCobrancaConta
								.getReferenciaContaFinal();
					}

					if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

						insert = insert
								+ " and ( coalesce( cnta2.cnta_vlagua, 0 ) + coalesce( cnta2.cnta_vlesgoto, 0 ) + coalesce( cnta2.cnta_vldebitos, 0 ) "
								+ "- coalesce( cnta2.cnta_vlcreditos, 0 ) - coalesce( cnta2.cnta_vlimpostos, 0 ) ) between ? and ? ";

						valorMinimoContaSubquery = comandoEmpresaCobrancaConta
								.getValorMinimoConta();
						valorMaximoContaSubquery = comandoEmpresaCobrancaConta
								.getValorMaximoConta();
					}

					insert = insert + " ) ";
				}
			} else {

				insert = insert
						+ " and conta.cnta_dtvencimentoconta < to_date(?,'YYYY-MM-DD') ";

				dataVencimentoConta = Util
						.formatarDataComTracoAAAAMMDD(new Date());
			}

			// insert = insert +
			// criarCondicionaisPesquisarContasInformarContasEmCobranca(comandoEmpresaCobrancaConta,
			// helper);

			// LOCALIDADE, SETOR COMERCIAL E QUADRA
			Integer idLocalidade = null;
			Integer[] cdsSetorComercial = null;

			Integer idLocalidadeInicial = null;
			Integer idLocalidadeFinal = null;
			Integer cdSetorComercialInicial = null;
			Integer cdSetorComercialFinal = null;
			Integer nnQuadraInicial = null;
			Integer nnQuadraFinal = null;
			if (helper.getColecaoSetoresComponent() != null
					&& !helper.getColecaoSetoresComponent().isEmpty()) {

				SetorComercial set = (SetorComercial) Util
						.retonarObjetoDeColecao(helper
								.getColecaoSetoresComponent());

				insert = insert
						+ " AND loca.loca_id = ? AND stcm.stcm_cdsetorcomercial IN(*) ";

				idLocalidade = set.getLocalidade().getId();

				cdsSetorComercial = new Integer[helper
						.getColecaoSetoresComponent().size()];
				int indexCdsSetorComercial = 0;
				String cdsSetorComercialBindVariable = "";

				for (SetorComercial setor : helper.getColecaoSetoresComponent()) {

					cdsSetorComercial[indexCdsSetorComercial] = setor
							.getCodigo();

					cdsSetorComercialBindVariable = cdsSetorComercialBindVariable
							+ "?, ";

					indexCdsSetorComercial++;
				}

				cdsSetorComercialBindVariable = Util.removerUltimosCaracteres(
						cdsSetorComercialBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				insert = insert.replace("*", cdsSetorComercialBindVariable);
			} else {

				if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {

					insert = insert + " AND loca.loca_id BETWEEN ? AND ? ";

					idLocalidadeInicial = comandoEmpresaCobrancaConta
							.getLocalidadeInicial().getId();
					idLocalidadeFinal = comandoEmpresaCobrancaConta
							.getLocalidadeFinal().getId();
				}

				if (comandoEmpresaCobrancaConta
						.getCodigoSetorComercialInicial() != null) {

					insert = insert
							+ " AND stcm.stcm_cdsetorcomercial BETWEEN ? AND ? ";

					cdSetorComercialInicial = comandoEmpresaCobrancaConta
							.getCodigoSetorComercialInicial();
					cdSetorComercialFinal = comandoEmpresaCobrancaConta
							.getCodigoSetorComercialFinal();
				}

				if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {

					insert = insert
							+ " AND qdra.qdra_nnquadra BETWEEN ? AND ? ";

					nnQuadraInicial = comandoEmpresaCobrancaConta
							.getQuadraInicial().getNumeroQuadra();
					nnQuadraFinal = comandoEmpresaCobrancaConta
							.getQuadraFinal().getNumeroQuadra();
				}
			}

			// INTERVALO REFERÊNCIA DE CONTA
			Integer referenciaInicial = null;
			Integer referenciaFinal = null;
			if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

				insert = insert
						+ " and conta.cnta_amreferenciaconta between ? and ? ";

				referenciaInicial = comandoEmpresaCobrancaConta
						.getReferenciaContaInicial();
				referenciaFinal = comandoEmpresaCobrancaConta
						.getReferenciaContaFinal();
			}

			// INTERVALO ENTRE DATAS DE VENCIMENTO DE CONTA
			String dataVencimentoContaInicial = null;
			String dataVencimentoContaFinal = null;
			if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {

				insert = insert
						+ " and conta.cnta_dtvencimentoconta between to_date(?,'YYYY-MM-DD') and to_date(?,'YYYY-MM-DD') ";

				dataVencimentoContaInicial = Util
						.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
								.getDataVencimentoContaInicial());
				dataVencimentoContaFinal = Util
						.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
								.getDataVencimentoContaFinal());
			}

			// INTERVALO VALOR DE CONTA
			BigDecimal valorMinimoConta = null;
			BigDecimal valorMaximoConta = null;
			if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

				insert = insert
						+ " and ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) "
						+ "- coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) between ? and ? ";

				valorMinimoConta = comandoEmpresaCobrancaConta
						.getValorMinimoConta();
				valorMaximoConta = comandoEmpresaCobrancaConta
						.getValorMaximoConta();
			}

			// COMANDO
			insert = insert + " and auxImov.cecc_id = ? ";

			st = con.prepareStatement(insert);

			int i = 0;

			// QUANTIDADE DE DIAS DE VENCIMENTO
			if (dataVencimentoConta != null) {

				i++;
				st.setString(i, dataVencimentoConta);
			}

			// INTERVALO REFERÊNCIA DE CONTA SUBQUERY
			if (referenciaInicialSubquery != null) {

				i++;
				st.setInt(i, referenciaInicialSubquery);

				i++;
				st.setInt(i, referenciaFinalSubquery);
			}

			// INTERVALO VALOR DE CONTA SUBQUERY
			if (valorMinimoContaSubquery != null) {

				i++;
				st.setBigDecimal(i, valorMinimoContaSubquery);

				i++;
				st.setBigDecimal(i, valorMaximoContaSubquery);
			}

			// LOCALIDADE
			if (idLocalidade != null) {

				i++;
				st.setInt(i, idLocalidade);
			}

			// SETOR COMERCIAL
			if (cdsSetorComercial != null && cdsSetorComercial.length > 0) {

				for (int j = 0; j < cdsSetorComercial.length; j++) {
					i++;
					st.setInt(i, cdsSetorComercial[j]);
				}
			}

			// LOCALIDADE INICIAL E FINAL
			if (idLocalidadeInicial != null) {

				i++;
				st.setInt(i, idLocalidadeInicial);

				i++;
				st.setInt(i, idLocalidadeFinal);
			}

			// SETOR COMERCIAL INICIAL E FINAL
			if (cdSetorComercialInicial != null) {

				i++;
				st.setInt(i, cdSetorComercialInicial);

				i++;
				st.setInt(i, cdSetorComercialFinal);
			}

			// QUADRA INICIAL E FINAL
			if (nnQuadraInicial != null) {

				i++;
				st.setInt(i, nnQuadraInicial);

				i++;
				st.setInt(i, nnQuadraFinal);
			}

			// INTERVALO REFERÊNCIA DE CONTA
			if (referenciaInicial != null) {

				i++;
				st.setInt(i, referenciaInicial);

				i++;
				st.setInt(i, referenciaFinal);
			}

			// INTERVALO ENTRE DATAS DE VENCIMENTO DE CONTA
			if (dataVencimentoContaInicial != null) {

				i++;
				st.setString(i, dataVencimentoContaInicial);

				i++;
				st.setString(i, dataVencimentoContaFinal);
			}

			// INTERVALO VALOR DE CONTA
			if (valorMinimoConta != null) {

				i++;
				st.setBigDecimal(i, valorMinimoConta);

				i++;
				st.setBigDecimal(i, valorMaximoConta);
			}

			// COMANDO
			i++;
			st.setInt(i, comandoEmpresaCobrancaConta.getId());

			st.executeUpdate();
			
			//ATUALIZANDO AS ESTATISTICAS DA TABELA COBRANCA.CMD_EMPR_COBR_CONTA_CNTA
			estatistica = " begin dbms_stats.gather_table_stats(ownname => 'COBRANCA', tabname => 'CMD_EMPR_COBR_CONTA_CNTA', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE AUTO', cascade => TRUE); end; ";

			call = con.prepareCall(estatistica);

			call.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				call.close();
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Pesquisa as contas através da tabela auxiliar
	 * 
	 * @author Raphael Rossiter
	 * @date 15/02/2013
	 */
	public Collection<Object[]> pesquisarComandoEmpresaCobrancaContaConta(
			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta,
			Integer indice, Integer quantidadeRegitros)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object[]> retorno = null;
		String consulta = null;

		try {

			consulta = "SELECT a.cnta_id as idConta, a.cecn_vlconta as valorConta, a.cecn_icpagamentovalido as indicadorPagamentoValido, "
					+ "a.imov_id as idImovel, a.cecn_amreferenciaconta as referenciaConta, a.stcm_id as idSetorComercialImovel, "
					+ "a.cecn_qtdcomando as quantidadeComandos, "
					+ "b.quantidadeContas, "
					+ "imov.loca_id as idLocalidade "
					+ "FROM cobranca.cmd_empr_cobr_conta_cnta a "
					+ "INNER JOIN cadastro.imovel imov on a.imov_id = imov.imov_id "
					+ "INNER JOIN  (SELECT cecc_id, imov_id, count(*) as quantidadeContas "
					+ "FROM cobranca.cmd_empr_cobr_conta_cnta aux "
					+ "GROUP BY cecc_id, imov_id) b on b.imov_id = a.imov_id and b.cecc_id = a.cecc_id "
					+ "WHERE a.cecc_id = :idComando ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("idConta", Hibernate.INTEGER)
					.addScalar("valorConta", Hibernate.BIG_DECIMAL)
					.addScalar("indicadorPagamentoValido", Hibernate.SHORT)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("referenciaConta", Hibernate.INTEGER)
					.addScalar("idSetorComercialImovel", Hibernate.INTEGER)
					.addScalar("quantidadeComandos", Hibernate.INTEGER)
					.addScalar("quantidadeContas", Hibernate.INTEGER)
					.addScalar("idLocalidade", Hibernate.INTEGER)
					.setInteger("idComando",
							comandoEmpresaCobrancaConta.getId())
					.setFirstResult(indice * quantidadeRegitros)
					.setMaxResults(quantidadeRegitros).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa os imóveis das contas
	 * 
	 * @author: Rafael Correa, Mariana Victor, Raimundo Martins
	 * @date: 28/10/2008, 03/05/2011, 13/10/2011
	 */
	/*
	 * public void inserirComandoEmpresaCobrancaContaImovel(
	 * ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper,
	 * boolean percentualInformado, SistemaParametro sistemaParametro, Integer
	 * quantidadeMenorFaixa, String condicionais) throws
	 * ErroRepositorioException {
	 * 
	 * Session session = HibernateUtil.getSession();
	 * 
	 * Collection<Integer> retorno = null; String consulta = null;
	 * 
	 * Connection con = null; PreparedStatement st = null;
	 * 
	 * try {
	 * 
	 * con = session.connection();
	 * 
	 * consulta = "INSERT INTO cobranca.cmd_empr_cobr_conta_imov "
	 * +"SELECT DISTINCT " +
	 * comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta
	 * ().getId() + " as comando, conta.imov_id as idImovel " +
	 * " FROM cadastro.imovel imov " +
	 * " INNER JOIN cadastro.localidade loca on loca.loca_id = imov.loca_id " +
	 * " INNER JOIN cadastro.setor_comercial stcm on stcm.stcm_id = imov.stcm_id "
	 * + " INNER JOIN cadastro.quadra qdra on qdra.qdra_id = imov.qdra_id " +
	 * " INNER JOIN faturamento.conta conta on conta.imov_id = imov.imov_id " +
	 * " INNER JOIN cadastro.sistema_parametros sp on 1=1 " +
	 * " LEFT JOIN arrecadacao.pagamento pagto on pagto.cnta_id = conta.cnta_id and pagto.pgst_idatual is not null "
	 * + " left join ( select DISTINCT EMPRCOBCONTA.IMOV_ID " +
	 * " from COBRANCA.EMPRESA_COBRANCA_CONTA EMPRCOBCONTA " +
	 * " inner join COBRANCA.CMD_EMPR_COBR_CONTA CECC on EMPRCOBCONTA.CECC_ID = CECC.CECC_ID  "
	 * +
	 * " where CECC.CECC_DTENCERRAMENTO is null ) TEMP on TEMP.IMOV_ID = CONTA.IMOV_ID "
	 * ;
	 * 
	 * if (comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().
	 * getCliente() != null) { consulta = consulta +
	 * " INNER JOIN cadastro.cliente_conta clieConta " +
	 * " on clieConta.cnta_id = conta.cnta_id "; }
	 * 
	 * if (!percentualInformado) { consulta = consulta +
	 * " LEFT OUTER JOIN cobranca.cobranca_situacao cbst " +
	 * " ON cbst.cbst_id = imov.cbst_id " +
	 * " LEFT JOIN cobranca.cobranca_situacao_hist cbsh ON cbsh.imov_id = imov.imov_id and cbsh.cbsh_amcobrancaretirada IS NULL"
	 * + " WHERE " + " (imov.cbst_id IS NULL or cbst.cbst_icnaocobranca <> 1) "
	 * +
	 * " AND imov.imov_id NOT IN (SELECT cbsh.imov_id FROM cobranca.cobranca_situacao_hist cbsh WHERE cbsh.imov_id = imov.imov_id and cbsh.cbsh_amcobrancaretirada IS NULL) "
	 * + " AND cbsh.cbsh_id IS NULL AND "; } else {
	 * 
	 * if(sistemaParametro.getNomeAbreviadoEmpresa().equals(SistemaParametro.
	 * EMPRESA_CAEMA)){ consulta = consulta +
	 * " LEFT OUTER JOIN cadastro.imovel_cobranca_situacao ics on ics.imov_id = imov.imov_id "
	 * + " LEFT OUTER JOIN cobranca.cobranca_situacao cbst " +
	 * " ON (cbst.cbst_id = ics.cbst_id) " + " WHERE "; } else{ consulta =
	 * consulta + " WHERE "; } }
	 * 
	 * String idsCategorias = Categoria.RESIDENCIAL + ", " + Categoria.COMERCIAL
	 * + ", " + Categoria.INDUSTRIAL + ", " + Categoria.PUBLICO;
	 * 
	 * ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta =
	 * comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta();
	 * 
	 * if ((comandoEmpresaCobrancaConta.getIndicadorResidencial() != null &&
	 * !comandoEmpresaCobrancaConta .getIndicadorResidencial().equals(
	 * ConstantesSistema.NAO.intValue())) ||
	 * (comandoEmpresaCobrancaConta.getIndicadorComercial() != null &&
	 * !comandoEmpresaCobrancaConta .getIndicadorComercial().equals(
	 * ConstantesSistema.NAO.intValue())) ||
	 * (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null &&
	 * !comandoEmpresaCobrancaConta .getIndicadorIndustrial().equals(
	 * ConstantesSistema.NAO.intValue())) ||
	 * (comandoEmpresaCobrancaConta.getIndicadorPublico() != null &&
	 * !comandoEmpresaCobrancaConta .getIndicadorPublico().equals(
	 * ConstantesSistema.NAO.intValue()))) {
	 * 
	 * idsCategorias = "";
	 * 
	 * if (comandoEmpresaCobrancaConta.getIndicadorResidencial() != null &&
	 * !comandoEmpresaCobrancaConta.getIndicadorResidencial()
	 * .equals(ConstantesSistema.NAO.intValue())) { idsCategorias =
	 * Categoria.RESIDENCIAL + ", "; }
	 * 
	 * if (comandoEmpresaCobrancaConta.getIndicadorComercial() != null &&
	 * !comandoEmpresaCobrancaConta.getIndicadorComercial()
	 * .equals(ConstantesSistema.NAO.intValue())) { idsCategorias =
	 * idsCategorias + Categoria.COMERCIAL + ", "; }
	 * 
	 * if (comandoEmpresaCobrancaConta.getIndicadorIndustrial() != null &&
	 * !comandoEmpresaCobrancaConta.getIndicadorIndustrial()
	 * .equals(ConstantesSistema.NAO.intValue())) { idsCategorias =
	 * idsCategorias + Categoria.INDUSTRIAL + ", "; }
	 * 
	 * if (comandoEmpresaCobrancaConta.getIndicadorPublico() != null &&
	 * !comandoEmpresaCobrancaConta.getIndicadorPublico()
	 * .equals(ConstantesSistema.NAO.intValue())) { idsCategorias =
	 * idsCategorias + Categoria.PUBLICO + ", "; }
	 * 
	 * idsCategorias = Util.removerUltimosCaracteres(idsCategorias, 2); }
	 * 
	 * consulta = consulta + " pagto.pgmt_id is null AND "; consulta = consulta
	 * + " imov.imov_icexclusao <> 1 AND imov.imov_idcategoriaprincipal in (" +
	 * idsCategorias + ") AND " +
	 * "  conta.cnta_amreferenciaconta < sp.parm_amreferenciaarrecadacao AND ";
	 * 
	 * //CONDICIONAIS consulta = consulta + condicionais;
	 * 
	 * //TESTANDO //consulta = consulta + " and conta.imov_id = 28542070 ";
	 * 
	 * if (comandoEmpresaCobrancaContaHelper.getComandoEmpresaCobrancaConta().
	 * getQtdContasInicial() != null) { consulta = consulta +
	 * " group by conta.imov_id "; consulta = consulta +
	 * " HAVING count(DISTINCT conta.cnta_id) between " +
	 * comandoEmpresaCobrancaContaHelper
	 * .getComandoEmpresaCobrancaConta().getQtdContasInicial() + " and " +
	 * comandoEmpresaCobrancaContaHelper
	 * .getComandoEmpresaCobrancaConta().getQtdContasFinal(); } else if
	 * (!percentualInformado && quantidadeMenorFaixa != null){ consulta =
	 * consulta + " group by conta.imov_id "; consulta = consulta +
	 * " HAVING count(DISTINCT conta.cnta_id) >= " + quantidadeMenorFaixa; }
	 * 
	 * if(comandoEmpresaCobrancaContaHelper.getIndicadorTotalDebito()){
	 * if(comandoEmpresaCobrancaContaHelper
	 * .getComandoEmpresaCobrancaConta().getValorMinimoDebito() !=null){
	 * consulta += " and (sum(" + " coalesce( conta.cnta_vlagua, 0 ) + " +
	 * "coalesce( conta.cnta_vlesgoto, 0 ) + " +
	 * "coalesce( conta.cnta_vldebitos, 0 ) - " +
	 * "coalesce( conta.cnta_vlcreditos, 0 ) - " +
	 * "coalesce( conta.cnta_vlimpostos, 0 ) " + ")) between " +
	 * comandoEmpresaCobrancaContaHelper
	 * .getComandoEmpresaCobrancaConta().getValorMinimoDebito() + " and " +
	 * comandoEmpresaCobrancaContaHelper
	 * .getComandoEmpresaCobrancaConta().getValorMaximoDebito();
	 * 
	 * 
	 * } }
	 * 
	 * st = con.prepareStatement(consulta);
	 * 
	 * st.executeUpdate();
	 * 
	 * } catch (HibernateException e) { throw new ErroRepositorioException(e,
	 * "Erro no Hibernate"); } catch (SQLException e) { throw new
	 * ErroRepositorioException(e, "Erro no Insert"); } finally {
	 * HibernateUtil.closeSession(session);
	 * 
	 * try { st.close(); con.close(); } catch (SQLException e) { throw new
	 * ErroRepositorioException(e, "Erro ao fechar conexões"); } } }
	 */

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * inserir colecao de EmpresaCobrancaContaPagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 21/02/2013
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirEmpresaCobrancaContaPagamentos(
			Collection<EmpresaCobrancaContaPagamentos> colecaoParaInserir)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String insert;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			for (EmpresaCobrancaContaPagamentos empresaCobrancaContaPagamentos : colecaoParaInserir) {
				insert = "insert into cobranca.empr_cobr_conta_pagto (";
				insert += "eccp_id, ";
				insert += "ecco_id, ";
				insert += "eccp_ampagamento, ";
				insert += "dbtp_id, ";
				insert += "eccp_vlpagamentomes, ";
				insert += "eccp_tmultimaalteracao, ";
				insert += "eccp_amreferenciapagamento, ";
				insert += "eccp_dtpagamento, ";
				insert += "imov_id, ";
				insert += "arrc_id, ";
				insert += "eccp_ictipopagamento, ";
				insert += "eccp_nnparcelaatual, ";
				insert += "eccp_nntotalparcelas, ";
				insert += "cbdo_id ";
				insert += ") values (";
				insert += "cobranca.seq_empr_cobr_conta_pagto.nextval, ";

				if (empresaCobrancaContaPagamentos.getEmpresaCobrancaConta() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos
						.getAnoMesPagamentoArrecadacao() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getDebitoTipo() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getValorPagamentoMes() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				insert += "sysdate, ";

				if (empresaCobrancaContaPagamentos
						.getAnoMesReferenciaPagamento() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getDataPagamento() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getIdImovel() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getIdArrecadador() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getIndicadorTipoPagamento() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getNumeroParcelaAtual() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getNumeroTotalParcelas() != null) {
					insert += "?, ";
				} else {
					insert += "null, ";
				}

				if (empresaCobrancaContaPagamentos.getCobrancaDocumento() != null) {
					insert += "? ";
				} else {
					insert += "null ";
				}

				insert += ") ";

				st = con.prepareStatement(insert);

				int i = 1;

				if (empresaCobrancaContaPagamentos.getEmpresaCobrancaConta() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getEmpresaCobrancaConta().getId());
					i++;
				}

				if (empresaCobrancaContaPagamentos
						.getAnoMesPagamentoArrecadacao() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getAnoMesPagamentoArrecadacao());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getDebitoTipo() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos.getDebitoTipo()
							.getId());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getValorPagamentoMes() != null) {
					st.setBigDecimal(i, empresaCobrancaContaPagamentos
							.getValorPagamentoMes());
					i++;
				}

				if (empresaCobrancaContaPagamentos
						.getAnoMesReferenciaPagamento() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getAnoMesReferenciaPagamento());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getDataPagamento() != null) {
					st.setDate(i, Util
							.getSQLDate(empresaCobrancaContaPagamentos
									.getDataPagamento()));
					i++;
				}

				if (empresaCobrancaContaPagamentos.getIdImovel() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos.getIdImovel());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getIdArrecadador() != null) {
					st.setInt(i,
							empresaCobrancaContaPagamentos.getIdArrecadador());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getIndicadorTipoPagamento() != null) {
					st.setShort(i, empresaCobrancaContaPagamentos
							.getIndicadorTipoPagamento());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getNumeroParcelaAtual() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getNumeroParcelaAtual());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getNumeroTotalParcelas() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getNumeroTotalParcelas());
					i++;
				}

				if (empresaCobrancaContaPagamentos.getCobrancaDocumento() != null) {
					st.setInt(i, empresaCobrancaContaPagamentos
							.getCobrancaDocumento().getId());
					i++;
				}

				st.executeUpdate();

				// SOLICITADO POR RAFAEL CORREA
				st.close();

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * Pesquisa os imóveis das contas
	 * 
	 * @author: Raphael Rossiter
	 * @date: 22/03/2013
	 */
	public void inserirComandoEmpresaCobrancaContaImovel(
			ComandoEmpresaCobrancaContaHelper comandoEmpresaCobrancaContaHelper,
			boolean percentualInformado, SistemaParametro sistemaParametro,
			Integer quantidadeMenorFaixa) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Integer> retorno = null;
		String segundaGeracao = null;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			ComandoEmpresaCobrancaConta comandoEmpresaCobrancaConta = comandoEmpresaCobrancaContaHelper
					.getComandoEmpresaCobrancaConta();

			segundaGeracao = "INSERT INTO cobranca.cmd_empr_cobr_conta_imov (imov_id, cecc_id) "
					+ "SELECT DISTINCT conta.imov_id AS idImovel, ? AS comando "
					+ " FROM cobranca.cmd_empr_cobr_cnta_imov_p imov "
					+ " INNER JOIN cadastro.localidade loca ON loca.loca_id = imov.loca_id "
					+ " INNER JOIN cadastro.setor_comercial stcm ON stcm.stcm_id = imov.stcm_id "
					+ " INNER JOIN cadastro.quadra qdra ON qdra.qdra_id = imov.qdra_id "
					+ " INNER JOIN faturamento.conta conta ON conta.imov_id = imov.imov_id "
					+ " INNER JOIN cadastro.sistema_parametros sp ON 1=1 "
					+ " LEFT JOIN arrecadacao.pagamento pagto ON pagto.cnta_id = conta.cnta_id AND pagto.pgst_idatual IS NOT NULL "
					+ " LEFT JOIN cobranca.imov_empr_cobr_cecc_aber temp on temp.imov_id = conta.imov_id ";

			// CLIENTE
			if (comandoEmpresaCobrancaConta.getCliente() != null) {

				segundaGeracao = segundaGeracao
						+ " INNER JOIN cadastro.cliente_conta clieConta "
						+ " ON clieConta.cnta_id = conta.cnta_id ";
			}

			// COBRANÇA SITUAÇÃO
			/*
			 * if (!percentualInformado) {
			 * 
			 * segundaGeracao = segundaGeracao +
			 * " LEFT OUTER JOIN cobranca.cobranca_situacao cbst ON cbst.cbst_id = imov.cbst_id "
			 * +
			 * " WHERE (imov.cbst_id IS NULL OR cbst.cbst_icnaocobranca <> 1) AND "
			 * ; } else {
			 */
			segundaGeracao = segundaGeracao + " WHERE ";
			// }

			segundaGeracao = segundaGeracao + " pagto.pgmt_id IS NULL AND ";
			segundaGeracao = segundaGeracao
					+ " conta.cnta_amreferenciaconta < sp.parm_amreferenciaarrecadacao AND ";

			// SITUAÇÃO DE COBRANÇA
			if (!percentualInformado
					&& (comandoEmpresaCobrancaContaHelper
							.getColecaoCobrancaSituacao() == null || comandoEmpresaCobrancaContaHelper
							.getColecaoCobrancaSituacao().isEmpty())) {

				segundaGeracao = segundaGeracao
						+ " NOT EXISTS (SELECT iscb.imov_id FROM CADASTRO.imovel_cobranca_situacao iscb "
						+ " inner join cobranca.cobranca_situacao cbst on cbst.cbst_id = iscb.cbst_id "
						+ " WHERE iscb.imov_id = imov.imov_id and iscb.ISCB_DTRETIRADACOBRANCA IS NULL "
						+ " and cbst.cbst_icnaocobranca = 1 "
						+ " and iscb.CBST_ID <> 20) AND ";
			}

			// CONDICIONAIS
			// consulta = consulta + condicionais;

			// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

			// NAO ENTRA CONTA EM REVISÃO E CONTA QUE JÁ ESTÁ EM OUTRO COMANDO
			segundaGeracao = segundaGeracao + " temp.imov_id IS NULL AND "
					+ "conta.cmrv_id IS NULL AND conta.cnta_dtrevisao IS NULL ";

			// SO ENTRA CONTA: NORMAL, INCLUÍDA OU RETIFICADA
			segundaGeracao = segundaGeracao + " AND conta.dcst_idatual in ( "
					+ DebitoCreditoSituacao.NORMAL + ", "
					+ DebitoCreditoSituacao.INCLUIDA + ", "
					+ DebitoCreditoSituacao.RETIFICADA + " ) ";

			// CASO O CLIENTE TENHA SIDO INFORMADO NO COMANDO
			if (comandoEmpresaCobrancaConta.getCliente() != null) {

				segundaGeracao = segundaGeracao + " AND clieConta.clie_id = ? ";
			}

			// UNIDADE NEGÓCIO
			Integer[] idsUnidadeNegocio = null;

			if (comandoEmpresaCobrancaConta.getUnidadeNegocio() != null) {

				segundaGeracao = segundaGeracao + " AND loca.uneg_id IN(*) ";

				idsUnidadeNegocio = new Integer[1];
				idsUnidadeNegocio[0] = comandoEmpresaCobrancaConta
						.getUnidadeNegocio().getId();
			} else if (comandoEmpresaCobrancaContaHelper
					.getColecaoUnidadeNegocio() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoUnidadeNegocio().isEmpty()) {

				boolean consultaColecaoUnidadeNegocio = true;
				if (comandoEmpresaCobrancaContaHelper
						.getColecaoUnidadeNegocio().size() == 1) {
					Iterator it = comandoEmpresaCobrancaContaHelper
							.getColecaoUnidadeNegocio().iterator();
					while (it.hasNext()) {
						UnidadeNegocio obj = (UnidadeNegocio) it.next();
						if (obj != null && obj.getId() == -1) {
							consultaColecaoUnidadeNegocio = false;
						}
					}
				}

				if (consultaColecaoUnidadeNegocio) {

					segundaGeracao = segundaGeracao
							+ " AND loca.uneg_id IN(*) ";

					idsUnidadeNegocio = new Integer[comandoEmpresaCobrancaContaHelper
							.getColecaoUnidadeNegocio().size()];

					Iterator iterator = comandoEmpresaCobrancaContaHelper
							.getColecaoUnidadeNegocio().iterator();
					UnidadeNegocio unidadeNegocio = null;
					int indexIdsUnidadeNegocio = 0;

					while (iterator.hasNext()) {
						unidadeNegocio = (UnidadeNegocio) iterator.next();

						idsUnidadeNegocio[indexIdsUnidadeNegocio] = unidadeNegocio
								.getId();

						indexIdsUnidadeNegocio++;
					}
				}
			}

			// CARREGANDO OS PARÊMETROS DAS UNIDADES DE NEGÓCIO
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0) {

				String idsUnidadeNegocioBindVariable = "";
				for (int j = 0; j < idsUnidadeNegocio.length; j++) {

					idsUnidadeNegocioBindVariable = idsUnidadeNegocioBindVariable
							+ "?, ";
				}

				idsUnidadeNegocioBindVariable = Util.removerUltimosCaracteres(
						idsUnidadeNegocioBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				segundaGeracao = segundaGeracao.replace("*",
						idsUnidadeNegocioBindVariable);
			}

			// GERÊNCIA REGIONAL
			Integer[] idsGerenciaRegional = null;

			if (comandoEmpresaCobrancaConta.getGerenciaRegional() != null) {

				segundaGeracao = segundaGeracao + " AND loca.greg_id IN(*) ";

				idsGerenciaRegional = new Integer[1];
				idsGerenciaRegional[0] = comandoEmpresaCobrancaConta
						.getGerenciaRegional().getId();
			} else if (comandoEmpresaCobrancaContaHelper
					.getColecaoGerenciaRegional() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoGerenciaRegional().isEmpty()) {

				boolean consultaColecaoGerenciaRegional = true;
				if (comandoEmpresaCobrancaContaHelper
						.getColecaoGerenciaRegional().size() == 1) {
					Iterator it = comandoEmpresaCobrancaContaHelper
							.getColecaoGerenciaRegional().iterator();
					while (it.hasNext()) {
						GerenciaRegional obj = (GerenciaRegional) it.next();
						if (obj != null && obj.getId() == -1) {
							consultaColecaoGerenciaRegional = false;
						}
					}
				}

				if (consultaColecaoGerenciaRegional) {

					segundaGeracao = segundaGeracao
							+ " AND loca.greg_id IN(*) ";

					idsGerenciaRegional = new Integer[comandoEmpresaCobrancaContaHelper
							.getColecaoGerenciaRegional().size()];

					Iterator iterator = comandoEmpresaCobrancaContaHelper
							.getColecaoGerenciaRegional().iterator();
					GerenciaRegional gerenciaRegional = null;
					int indexIdsGerenciaRegional = 0;

					while (iterator.hasNext()) {
						gerenciaRegional = (GerenciaRegional) iterator.next();

						idsGerenciaRegional[indexIdsGerenciaRegional] = gerenciaRegional
								.getId();

						indexIdsGerenciaRegional++;
					}
				}

			}

			// CARREGANDO OS PARÊMETROS DAS GERENCIAS REGIONAIS
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0) {

				String idsGerenciaRegionalBindVariable = "";
				for (int j = 0; j < idsGerenciaRegional.length; j++) {

					idsGerenciaRegionalBindVariable = idsGerenciaRegionalBindVariable
							+ "?, ";
				}

				idsGerenciaRegionalBindVariable = Util
						.removerUltimosCaracteres(
								idsGerenciaRegionalBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				segundaGeracao = segundaGeracao.replace("*",
						idsGerenciaRegionalBindVariable);
			}

			// LOCALIDADE, SETOR COMERCIAL E QUADRA
			Integer idLocalidade = null;
			Integer[] cdsSetorComercial = null;

			Integer idLocalidadeInicial = null;
			Integer idLocalidadeFinal = null;
			Integer cdSetorComercialInicial = null;
			Integer cdSetorComercialFinal = null;
			Integer nnQuadraInicial = null;
			Integer nnQuadraFinal = null;
			if (comandoEmpresaCobrancaContaHelper.getColecaoSetoresComponent() != null
					&& !comandoEmpresaCobrancaContaHelper
							.getColecaoSetoresComponent().isEmpty()) {

				SetorComercial set = (SetorComercial) Util
						.retonarObjetoDeColecao(comandoEmpresaCobrancaContaHelper
								.getColecaoSetoresComponent());

				segundaGeracao = segundaGeracao
						+ " AND loca.loca_id = ? AND stcm.stcm_cdsetorcomercial IN(*) ";

				idLocalidade = set.getLocalidade().getId();

				cdsSetorComercial = new Integer[comandoEmpresaCobrancaContaHelper
						.getColecaoSetoresComponent().size()];
				int indexCdsSetorComercial = 0;
				String cdsSetorComercialBindVariable = "";

				for (SetorComercial setor : comandoEmpresaCobrancaContaHelper
						.getColecaoSetoresComponent()) {

					cdsSetorComercial[indexCdsSetorComercial] = setor
							.getCodigo();

					cdsSetorComercialBindVariable = cdsSetorComercialBindVariable
							+ "?, ";

					indexCdsSetorComercial++;
				}

				cdsSetorComercialBindVariable = Util.removerUltimosCaracteres(
						cdsSetorComercialBindVariable, 2);

				// MODIFICANDO DE ACORDO COM A QUANTIDADE DE PARÂMETROS
				segundaGeracao = segundaGeracao.replace("*",
						cdsSetorComercialBindVariable);
			} else {

				if (comandoEmpresaCobrancaConta.getLocalidadeInicial() != null) {

					segundaGeracao = segundaGeracao
							+ " AND loca.loca_id BETWEEN ? AND ? ";

					idLocalidadeInicial = comandoEmpresaCobrancaConta
							.getLocalidadeInicial().getId();
					idLocalidadeFinal = comandoEmpresaCobrancaConta
							.getLocalidadeFinal().getId();
				}

				if (comandoEmpresaCobrancaConta
						.getCodigoSetorComercialInicial() != null) {

					segundaGeracao = segundaGeracao
							+ " AND stcm.stcm_cdsetorcomercial BETWEEN ? AND ? ";

					cdSetorComercialInicial = comandoEmpresaCobrancaConta
							.getCodigoSetorComercialInicial();
					cdSetorComercialFinal = comandoEmpresaCobrancaConta
							.getCodigoSetorComercialFinal();
				}

				if (comandoEmpresaCobrancaConta.getQuadraInicial() != null) {

					segundaGeracao = segundaGeracao
							+ " AND qdra.qdra_nnquadra BETWEEN ? AND ? ";

					nnQuadraInicial = comandoEmpresaCobrancaConta
							.getQuadraInicial().getNumeroQuadra();
					nnQuadraFinal = comandoEmpresaCobrancaConta
							.getQuadraFinal().getNumeroQuadra();
				}
			}

			// INTERVALO REFERÊNCIA DE CONTA
			Integer referenciaInicial = null;
			Integer referenciaFinal = null;
			if (comandoEmpresaCobrancaConta.getReferenciaContaInicial() != null) {

				segundaGeracao = segundaGeracao
						+ " AND conta.cnta_amreferenciaconta BETWEEN ? AND ? ";

				referenciaInicial = comandoEmpresaCobrancaConta
						.getReferenciaContaInicial();
				referenciaFinal = comandoEmpresaCobrancaConta
						.getReferenciaContaFinal();
			}

			// INTERVALO VENCIMENTO DE CONTA
			String dataVencimentoInicial = null;
			String dataVenciamentoFinal = null;
			if (comandoEmpresaCobrancaConta.getDataVencimentoContaInicial() != null) {

				segundaGeracao = segundaGeracao
						+ " AND conta.cnta_dtvencimentoconta BETWEEN to_date(?,'YYYY-MM-DD') AND to_date(?,'YYYY-MM-DD') ";

				dataVencimentoInicial = Util
						.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
								.getDataVencimentoContaInicial());
				dataVenciamentoFinal = Util
						.formatarDataComTracoAAAAMMDD(comandoEmpresaCobrancaConta
								.getDataVencimentoContaFinal());
			}

			// INDICADOR TOTAL DO DÉBITO
			BigDecimal valorMinimoConta = null;
			BigDecimal valorMaximoConta = null;
			if (!comandoEmpresaCobrancaContaHelper.getIndicadorTotalDebito()) {

				if (comandoEmpresaCobrancaConta.getValorMinimoConta() != null) {

					segundaGeracao = segundaGeracao
							+ " AND ( coalesce( conta.cnta_vlagua, 0 ) + coalesce( conta.cnta_vlesgoto, 0 ) + coalesce( conta.cnta_vldebitos, 0 ) "
							+ "- coalesce( conta.cnta_vlcreditos, 0 ) - coalesce( conta.cnta_vlimpostos, 0 ) ) BETWEEN ? AND ? ";

					valorMinimoConta = comandoEmpresaCobrancaConta
							.getValorMinimoConta();
					valorMaximoConta = comandoEmpresaCobrancaConta
							.getValorMaximoConta();
				}
			}

			// QUANTIDADE DE DIAS DE VENCIMENTO
			String dataVencimentoConta = null;
			if (comandoEmpresaCobrancaConta.getQtdDiasVencimento() != null) {

				Short indicador = sistemaParametro
						.getIndicadorIncluirContasForaVenCobranca();

				// 2.1.19.1. Caso o indicador para incluir contas fora do
				// vencimento para cobran?a corresponda a N?O,
				// o sistema dever? verificar a data de vencimento de todas as
				// contas
				if (indicador.compareTo(ConstantesSistema.NAO) == 0) {

					segundaGeracao = segundaGeracao
							+ " AND conta.cnta_dtvencimentoconta <= to_date(?,'YYYY-MM-DD') ";

					dataVencimentoConta = Util
							.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()));
				} else {

					segundaGeracao = segundaGeracao
							+ " AND EXISTS (select cnta2.cnta_id from faturamento.conta cnta2 "
							+ "where cnta2.cnta_dtvencimentoconta <= to_date(?,'YYYY-MM-DD') and cnta2.imov_id = imov.imov_id) ";

					dataVencimentoConta = Util
							.formatarDataComTracoAAAAMMDD(Util
									.subtrairNumeroDiasDeUmaData(new Date(),
											comandoEmpresaCobrancaConta
													.getQtdDiasVencimento()));
				}
			}

			// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

			segundaGeracao = segundaGeracao + " AND imov.cecc_id = ? ";

			// QUANTIDADE DE CONTAS
			Integer qtdContaInicial = null;
			Integer qtdContaFinal = null;
			if (comandoEmpresaCobrancaContaHelper
					.getComandoEmpresaCobrancaConta().getQtdContasInicial() != null) {

				segundaGeracao = segundaGeracao + " GROUP BY conta.imov_id ";
				segundaGeracao = segundaGeracao
						+ " HAVING count(DISTINCT conta.cnta_id) BETWEEN ? AND ? ";

				qtdContaInicial = comandoEmpresaCobrancaContaHelper
						.getComandoEmpresaCobrancaConta().getQtdContasInicial();
				qtdContaFinal = comandoEmpresaCobrancaContaHelper
						.getComandoEmpresaCobrancaConta().getQtdContasFinal();
			} else if (!percentualInformado && quantidadeMenorFaixa != null) {
				segundaGeracao = segundaGeracao + " GROUP BY conta.imov_id ";
				segundaGeracao = segundaGeracao
						+ " HAVING count(DISTINCT conta.cnta_id) >= ? "; // +
																			// quantidadeMenorFaixa;
			}

			/*
			 * Se o indicador de debito for verdadeiro utiliza a soma dos
			 * debitos para filtrar os dados
			 */
			BigDecimal valorMinimoDebito = null;
			BigDecimal valorMaximoDebito = null;
			if (comandoEmpresaCobrancaContaHelper.getIndicadorTotalDebito()) {

				if (comandoEmpresaCobrancaContaHelper
						.getComandoEmpresaCobrancaConta()
						.getValorMinimoDebito() != null) {
					segundaGeracao += " AND (SUM("
							+ " coalesce( conta.cnta_vlagua, 0 ) + "
							+ "coalesce( conta.cnta_vlesgoto, 0 ) + "
							+ "coalesce( conta.cnta_vldebitos, 0 ) - "
							+ "coalesce( conta.cnta_vlcreditos, 0 ) - "
							+ "coalesce( conta.cnta_vlimpostos, 0 ) "
							+ ")) BETWEEN ? AND ? ";

					valorMinimoDebito = comandoEmpresaCobrancaContaHelper
							.getComandoEmpresaCobrancaConta()
							.getValorMinimoDebito();
					valorMaximoDebito = comandoEmpresaCobrancaContaHelper
							.getComandoEmpresaCobrancaConta()
							.getValorMaximoDebito();
				}
			}

			st = con.prepareStatement(segundaGeracao);
			int i = 1;

			// COMANDO
			st.setInt(i, comandoEmpresaCobrancaConta.getId());

			// CASO O CLIENTE TENHA SIDO INFORMADO NO COMANDO
			if (comandoEmpresaCobrancaConta.getCliente() != null) {

				i++;
				st.setInt(i, comandoEmpresaCobrancaConta.getCliente().getId());
			}

			// UNIDADE NEGÓCIO
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0) {

				for (int j = 0; j < idsUnidadeNegocio.length; j++) {
					i++;
					st.setInt(i, idsUnidadeNegocio[j]);
				}
			}

			// GERÊNCIA REGIONAL
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0) {

				for (int j = 0; j < idsGerenciaRegional.length; j++) {
					i++;
					st.setInt(i, idsGerenciaRegional[j]);
				}
			}

			// LOCALIDADE
			if (idLocalidade != null) {

				i++;
				st.setInt(i, idLocalidade);
			}

			// SETOR COMERCIAL
			if (cdsSetorComercial != null && cdsSetorComercial.length > 0) {

				for (int j = 0; j < cdsSetorComercial.length; j++) {
					i++;
					st.setInt(i, cdsSetorComercial[j]);
				}
			}

			// LOCALIDADE INICIAL E FINAL
			if (idLocalidadeInicial != null) {

				i++;
				st.setInt(i, idLocalidadeInicial);

				i++;
				st.setInt(i, idLocalidadeFinal);
			}

			// SETOR COMERCIAL INICIAL E FINAL
			if (cdSetorComercialInicial != null) {

				i++;
				st.setInt(i, cdSetorComercialInicial);

				i++;
				st.setInt(i, cdSetorComercialFinal);
			}

			// QUADRA INICIAL E FINAL
			if (nnQuadraInicial != null) {

				i++;
				st.setInt(i, nnQuadraInicial);

				i++;
				st.setInt(i, nnQuadraFinal);
			}

			// INTERVALO REFERÊNCIA DE CONTA
			if (referenciaInicial != null) {

				i++;
				st.setInt(i, referenciaInicial);

				i++;
				st.setInt(i, referenciaFinal);
			}

			// INTERVALO VENCIMENTO DE CONTA
			if (dataVencimentoInicial != null) {

				i++;
				st.setString(i, dataVencimentoInicial);

				i++;
				st.setString(i, dataVenciamentoFinal);
			}

			// INDICADOR TOTAL DO DÉBITO
			if (valorMinimoConta != null) {

				i++;
				st.setBigDecimal(i, valorMinimoConta);

				i++;
				st.setBigDecimal(i, valorMaximoConta);
			}

			// QUANTIDADE DE DIAS DE VENCIMENTO
			if (dataVencimentoConta != null) {

				i++;
				st.setString(i, dataVencimentoConta);
			}

			// COMANDO
			i++;
			st.setInt(i, comandoEmpresaCobrancaConta.getId());

			// QUANTIDADE DE CONTAS I
			if (qtdContaInicial != null) {

				i++;
				st.setInt(i, qtdContaInicial);

				i++;
				st.setInt(i, qtdContaFinal);
			}

			// QUANTIDADE DE CONTAS II
			if (qtdContaInicial == null && !percentualInformado
					&& quantidadeMenorFaixa != null) {

				i++;
				st.setInt(i, quantidadeMenorFaixa);
			}

			if (valorMinimoDebito != null) {

				i++;
				st.setBigDecimal(i, valorMinimoDebito);

				i++;
				st.setBigDecimal(i, valorMaximoDebito);
			}

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 26/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void removerComandoEmpresaCobrancaContaImovelParcial(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String delete;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			delete = "DELETE FROM cobranca.cmd_empr_cobr_cnta_imov_p WHERE cecc_id = ?";

			st = con.prepareStatement(delete);
			st.setInt(1, idComando);

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico Atualiza a data da exclus?o com a data
	 * corrente em D?bio Autom?tico
	 * 
	 * @author Rodrigo Cabral
	 * @created 26/03/2013
	 * 
	 */
	public void atualizarDataExclusaoDebitoAutomatico(String idDebitoAutomatico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizaDataExclusao;

		try {
			// Atualiza em d?bito autom?tico a Data Exclus?o com a data corrente
			atualizaDataExclusao = "update gcom.arrecadacao.debitoautomatico.DebitoAutomatico "
					+ "set deba_dtexclusao = :data,deba_tmultimaalteracao = :ultimaAlteracao where deba_id = :idDebitoAutomatico";

			session.createQuery(atualizaDataExclusao)
					.setInteger("idDebitoAutomatico",
							new Integer(idDebitoAutomatico).intValue())
					.setDate("data", new Date())
					.setTimestamp("ultimaAlteracao", new Date())
					.executeUpdate();
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC0200] Inserir D?bito Autom?tico Verificar se o Im?vel j? ? D?bito
	 * Autom?tico
	 * 
	 * @author Rodrigo Cabral
	 * @created 26/03/2013
	 * 
	 */
	public String pesquisarImovelDebitoAutomatico(String idDebitoAutomatico)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idImovel = null;
		Object retorno = null;
		String consulta;

		try {
			// Verifica se j? tem d?bito autom?tico
			consulta = "select imovel.id " + "from DebitoAutomatico deb "
					+ "inner join deb.imovel imovel "
					+ "where deb.id = :idDebitoAutomatico ";

			retorno = session
					.createQuery(consulta)
					.setInteger("idDebitoAutomatico",
							new Integer(idDebitoAutomatico).intValue())
					.setMaxResults(1).uniqueResult();

			if (retorno != null) {
				idImovel = ((Integer) retorno).toString();
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return idImovel;
	}

	/**
	 * [UC1451] Manter Parcelamento Judicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 01/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<Object> pesquisarObterListaParcelamentoJudicial(
			FiltrarManterParcelamentoJudicial filtroManterParcelamentoJudical)
			throws ErroRepositorioException {

		String codigoClienteResponsavel = filtroManterParcelamentoJudical
				.getCodigoClienteResponsavel();
		String codigoClienteUsuario = filtroManterParcelamentoJudical
				.getCodigoClienteUsuario();
		String matriculaImovel = filtroManterParcelamentoJudical
				.getMatriculaImovel();
		String processoJudicial = filtroManterParcelamentoJudical
				.getProcessoJudicial();
		String periodoInicialParcenamento = filtroManterParcelamentoJudical
				.getPeriodoInicialParcelamento();
		String periodoFinalParcelamento = filtroManterParcelamentoJudical
				.getPeriodoFinalParcelamento();
		Integer numeroDaPagina = null;
		Session session = HibernateUtil.getSession();

		Collection<Object> colecaoObterListaParcelamentoJudicial = null;

		try {

			String pesquisar = "select cl.clie_nmcliente as nomeCliente,"
					+ "to_date(to_char(pj.pjud_tmparcelamento ,'YYYY/MM/DD'),'YYYY/MM/DD') as dataParcelamento,"
					+ "pj.pjud_nnprestacoes as numeroParcelas,"
					+ "ps.pcst_dsparcelamentosituacao as situacao,"
					+ "pj.pjud_id as id "
					+ "from "
					+ "COBRANCA.parcelamento_judicial pj "
					+ "inner join CADASTRO.cliente cl on (pj.clie_idresponsavel=cl.clie_id) "
					+ "inner join COBRANCA.parcelamento_situacao ps on (pj.pcst_id=ps.pcst_id) ";

			if (matriculaImovel != null && !matriculaImovel.equals("")) {

				pesquisar += "inner join COBRANCA.parcel_judicial_imov pji on (pj.pjud_id=pji.pjud_id) ";

			}

			if ((codigoClienteResponsavel != null && !codigoClienteResponsavel
					.equals(""))
					|| (codigoClienteUsuario != null && !codigoClienteUsuario
							.equals(""))
					|| (matriculaImovel != null && !matriculaImovel.equals(""))
					|| (processoJudicial != null && !processoJudicial
							.equals(""))
					|| ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals("")))) {

				pesquisar += "where";

			}

			if (codigoClienteResponsavel != null
					&& !codigoClienteResponsavel.equals("")) {

				pesquisar += " pj.clie_idresponsavel="
						+ codigoClienteResponsavel + "";

			}

			if ((codigoClienteResponsavel != null && !codigoClienteResponsavel
					.equals(""))
					&& ((codigoClienteUsuario != null && !codigoClienteUsuario
							.equals(""))
							|| (matriculaImovel != null && !matriculaImovel
									.equals(""))
							|| (processoJudicial != null && !processoJudicial
									.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {

				pesquisar += " and";

			}

			if (codigoClienteUsuario != null
					&& !codigoClienteUsuario.equals("")) {

				pesquisar += " pj.clie_idusuario=" + codigoClienteUsuario + "";

			}

			if ((codigoClienteUsuario != null && !codigoClienteUsuario
					.equals(""))
					&& ((matriculaImovel != null && !matriculaImovel.equals(""))
							|| (processoJudicial != null && !processoJudicial
									.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {
				pesquisar += " and";

			}

			if (matriculaImovel != null && !matriculaImovel.equals("")) {

				pesquisar += " pji.imov_id=" + matriculaImovel + "";

			}

			if (matriculaImovel != null
					&& !matriculaImovel.equals("")
					&& ((processoJudicial != null && !processoJudicial
							.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {
				pesquisar += " and";

			}

			if (processoJudicial != null && !processoJudicial.equals("")) {

				pesquisar += " pj.pjud_nnprocessojudicial='" + processoJudicial
						+ "'";

			}

			if (processoJudicial != null
					&& !processoJudicial.equals("")
					&& ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals("")))) {

				pesquisar += " and";

			}

			if (periodoInicialParcenamento != null
					&& periodoFinalParcelamento != null
					&& !periodoInicialParcenamento.equals("")
					&& !periodoFinalParcelamento.equals("")) {

				pesquisar += " to_date(to_char(pj.pjud_tmparcelamento,'DD/MM/YYYY'),'DD/MM/YYYY') "
						+ "between to_date('"
						+ periodoInicialParcenamento
						+ "','DD/MM/YYYY') and to_date('"
						+ periodoFinalParcelamento + "','DD/MM/YYYY')";

			}

			pesquisar += " group by cl.clie_nmcliente,"
					+ "to_date(to_char(pj.pjud_tmparcelamento ,'YYYY/MM/DD'),'YYYY/MM/DD'),"
					+ "pj.pjud_nnprestacoes,"
					+ "ps.pcst_dsparcelamentosituacao," + "pj.pjud_id";

			if (!filtroManterParcelamentoJudical.getNumeroPaginaPesquisa()
					.equals("-1")) {

				numeroDaPagina = Integer
						.parseInt(filtroManterParcelamentoJudical
								.getNumeroPaginaPesquisa()) - 1;

			} else if (filtroManterParcelamentoJudical
					.getNumeroPaginaPesquisa().equals("-1")) {

				numeroDaPagina = Integer
						.parseInt(filtroManterParcelamentoJudical
								.getNumeroPaginaPesquisa()) + 1;

			}

			colecaoObterListaParcelamentoJudicial = (Collection<Object>) session
					.createSQLQuery(pesquisar)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("dataParcelamento", Hibernate.DATE)
					.addScalar("numeroParcelas", Hibernate.STRING)
					.addScalar("situacao", Hibernate.STRING)
					.addScalar("id", Hibernate.STRING)
					.setFirstResult(10 * numeroDaPagina).setMaxResults(10)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoObterListaParcelamentoJudicial;
	}

	/**
	 * [UC1452] Consultar Dados do Parcelamento Judicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 01/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<Object> pesquisarConsultaParcelamentoJudicial(
			FiltrarManterParcelamentoJudicial filtroManterParcelamentoJudical)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String idParcelamentoJudicial = filtroManterParcelamentoJudical
				.getIdParcelamentoJudicial();

		Collection<Object> colecaoConsultarParcelamentoJudicial = null;

		try {

			String pesquisar = "select"
					+ " pj.pjud_id as idParcelamentoJudicial,"
					+ "cl.clie_id as idCliente,"
					+ "cl.clie_nmcliente as nomeCliente,"
					+ "ps.pcst_dsparcelamentosituacao as situacao,"
					+ "to_date(to_char(pj.pjud_tmparcelamento ,'YYYY/MM/DD'),'YYYY/MM/DD') as dataParcelamento,"
					+ "pj.pjud_nnprocessojudicial as numeroProcesso,"
					+ "pj.pjud_nmadvogado as nomeAdvogado,"
					+ "pj.pjud_vlconta as debitoAtualizadoSoma1 ,"
					+ "pj.pjud_vlacrescimos as debitoAtualizadosSoma2, "
					+ "pj.pjud_vlacordo as valorAcordo,"
					+ "pj.pjud_pcdesconto as desconto,"
					+ "pj.pjud_txjuros as juros,"
					+ "pj.pjud_pcdesconto as percentualDesconto,"
					+ "pj.pjud_vlcustas as custas,"
					+ "pj.pjud_vlhonorario as honorarios,"
					+ "pj.pjud_vlparcelado as valorParcelamento, "
					+ "pj.pjud_vlentrada as valorEntrada "
					+ "from COBRANCA.parcelamento_judicial pj "
					+ "inner join CADASTRO.cliente cl on (pj.clie_idresponsavel=cl.clie_id) "
					+ "inner join COBRANCA.parcelamento_situacao ps on (pj.pcst_id=ps.pcst_id) "
					+ "inner join COBRANCA.parcel_judicial_imov pji on (pji.pjud_id=pj.pjud_id) "
					+ "where ";

			if (idParcelamentoJudicial != null
					&& !idParcelamentoJudicial.equals("")) {

				pesquisar += "pj.pjud_id=" + idParcelamentoJudicial + "";

			}

			pesquisar += " group by"
					+ " pj.pjud_id,"
					+ " cl.clie_id,"
					+ "cl.clie_nmcliente,"
					+ "ps.pcst_dsparcelamentosituacao,"
					+ "to_date(to_char(pj.pjud_tmparcelamento ,'YYYY/MM/DD'),'YYYY/MM/DD'),"
					+ "pj.pjud_nnprocessojudicial," + "pj.pjud_nmadvogado,"
					+ "pj.pjud_vlconta," + "pj.pjud_vlacrescimos,"
					+ "pj.pjud_pcdesconto," + "pj.pjud_vlacordo,"
					+ "pj.pjud_pcdesconto," + "pj.pjud_txjuros,"
					+ "pj.pjud_pcdesconto," + "pj.pjud_vlcustas,"
					+ "pj.pjud_vlhonorario," + "pj.pjud_vlparcelado,"
					+ "pj.pjud_vlentrada";

			colecaoConsultarParcelamentoJudicial = (Collection<Object>) session
					.createSQLQuery(pesquisar)
					.addScalar("idParcelamentoJudicial", Hibernate.STRING)
					.addScalar("idCliente", Hibernate.STRING)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("situacao", Hibernate.STRING)
					.addScalar("dataParcelamento", Hibernate.DATE)
					.addScalar("numeroProcesso", Hibernate.STRING)
					.addScalar("nomeAdvogado", Hibernate.STRING)
					.addScalar("debitoAtualizadoSoma1", Hibernate.BIG_DECIMAL)
					.addScalar("debitoAtualizadosSoma2", Hibernate.BIG_DECIMAL)
					.addScalar("valorAcordo", Hibernate.BIG_DECIMAL)
					.addScalar("desconto", Hibernate.BIG_DECIMAL)
					.addScalar("juros", Hibernate.BIG_DECIMAL)
					.addScalar("percentualDesconto", Hibernate.BIG_DECIMAL)
					.addScalar("custas", Hibernate.BIG_DECIMAL)
					.addScalar("honorarios", Hibernate.BIG_DECIMAL)
					.addScalar("valorParcelamento", Hibernate.BIG_DECIMAL)
					.addScalar("valorEntrada", Hibernate.BIG_DECIMAL).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoConsultarParcelamentoJudicial;
	}

	/**
	 * [UC1452] Consultar Dados do Parcelamento Judicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 01/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public List<EmitirGuiasParcelamentoJudicialHelper> pesquisarEmitirGuiasParcelamentoJudicial(
			String idParcelamentoJudicial, Integer debitoTipo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		List<String> guiaPagamentoIds = null;
		List<EmitirGuiasParcelamentoJudicialHelper> listaRetorno = new ArrayList<EmitirGuiasParcelamentoJudicialHelper>();
		try {

			String pesquisar = "select GP.GPAG_ID as idGuiaPagamento"
					+ " from"
					+ " FATURAMENTO.guia_pagamento gp"
					+ " inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id)"
					+ " where";

			if (idParcelamentoJudicial != null
					&& !idParcelamentoJudicial.equals("")) {

				pesquisar += " gp.pjud_id=" + idParcelamentoJudicial + ""
						+ " and dt.dbtp_id=" + debitoTipo + "";

			}

			pesquisar += " group by" + " GP.GPAG_ID";

			guiaPagamentoIds = (List<String>) session.createSQLQuery(pesquisar)
					.addScalar("idGuiaPagamento", Hibernate.STRING).list();

			for (String idGuiaParcelamentoJudicial : guiaPagamentoIds) {

				EmitirGuiasParcelamentoJudicialHelper helper = new EmitirGuiasParcelamentoJudicialHelper();

				helper.setIdGuiaParcelamentoJudicial((String) idGuiaParcelamentoJudicial
						.toString());
				listaRetorno.add(helper);

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return listaRetorno;

	}

	/**
	 * [UC1453] Emitir Parcelas do Parcelamento Judicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 01/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<Object> pesquisarParcelasParcelamentoJudicial(
			String idParcelamentoJudicial, Integer debitoTipo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object> colecaoParcelas = null;

		try {

			String pesquisar = "select gp.gpag_nnprestacaodebito as numeroPrestacao,"
					+ "gp.gpag_nnprestacaototal as numeroPrestacaoTotal,"
					+ "gp.gpag_dtvencimento as dataVencimento,"
					+ "gp.gpag_vldebito as valorPrestacao,"
					+ "ps.pcst_dsparcelamentosituacao as situacao "
					+ "from COBRANCA.parcelamento_judicial pj "
					+ "inner join FATURAMENTO.guia_pagamento gp on (pj.pjud_id=gp.pjud_id) "
					+ "inner join COBRANCA.parcelamento_situacao ps on (pj.pcst_id=ps.pcst_id) "
					+ "inner join faturamento.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
					+ "where";

			if (idParcelamentoJudicial != null
					&& !idParcelamentoJudicial.equals("")) {

				pesquisar += " pj.pjud_id=" + idParcelamentoJudicial + "";

			}

			if (debitoTipo != null && !debitoTipo.equals("")) {

				pesquisar += " and dt.dbtp_id=" + debitoTipo + "";

			}

			pesquisar += "group by " + "gp.gpag_nnprestacaodebito,"
					+ "gp.gpag_nnprestacaototal," + "gp.gpag_dtvencimento,"
					+ "gp.gpag_vldebito," + "ps.pcst_dsparcelamentosituacao "
					+ "order by gp.gpag_nnprestacaodebito";

			colecaoParcelas = (Collection<Object>) session
					.createSQLQuery(pesquisar)
					.addScalar("numeroPrestacao", Hibernate.STRING)
					.addScalar("numeroPrestacaoTotal", Hibernate.STRING)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("valorPrestacao", Hibernate.BIG_DECIMAL)
					.addScalar("situacao", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoParcelas;
	}

	/**
	 * [UC1453] Emitir Parcelas do Parcelamento Judicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 01/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<EmitirGuiasParcelamentoJudicialHelper> pesquisarEmitirParcelasParcelamentoJudicial(
			String idParcelamentoJudicial, Integer debitoTipo,
			String tipoParcelaEmissao, String intervaloInicialPrestacao,
			String intervaloFinalPrestacao) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		List<String> guiaPagamentoIds = null;
		List<EmitirGuiasParcelamentoJudicialHelper> listaRetorno = new ArrayList<EmitirGuiasParcelamentoJudicialHelper>();

		try {

			String pesquisar = "";

			if (tipoParcelaEmissao.equals("1")
					&& ((intervaloInicialPrestacao == null || intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao == null || intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + "";

			}

			if (tipoParcelaEmissao.equals("1")
					&& ((intervaloInicialPrestacao != null && !intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao != null && !intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + " "
						+ "and gp.gpag_nnprestacaodebito between "
						+ intervaloInicialPrestacao + " and "
						+ intervaloFinalPrestacao + "";

			}

			if (tipoParcelaEmissao.equals("2")
					&& ((intervaloInicialPrestacao == null || intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao == null || intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + " "
						+ "and gp.gpag_dtvencimento < sysdate";

			}

			if (tipoParcelaEmissao.equals("2")
					&& ((intervaloInicialPrestacao != null && !intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao != null && !intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + " "
						+ "and gp.gpag_dtvencimento < sysdate "
						+ "and gp.gpag_nnprestacaodebito between "
						+ intervaloInicialPrestacao + " and "
						+ intervaloFinalPrestacao + "";
			}

			if (tipoParcelaEmissao.equals("3")
					&& ((intervaloInicialPrestacao == null || intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao == null || intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + " "
						+ "and gp.gpag_dtvencimento >= sysdate";

			}

			if (tipoParcelaEmissao.equals("3")
					&& ((intervaloInicialPrestacao != null && !intervaloInicialPrestacao
							.equals("")) && (intervaloFinalPrestacao != null && !intervaloFinalPrestacao
							.equals("")))) {

				pesquisar += "select gp.gpag_id as idGuiaPagamento "
						+ "from FATURAMENTO.guia_pagamento gp "
						+ "inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id) "
						+ "where gp.pjud_id=" + idParcelamentoJudicial + " "
						+ "and dt.dbtp_id=" + debitoTipo + " "
						+ "and gp.gpag_dtvencimento >= sysdate "
						+ "and gp.gpag_nnprestacaodebito between "
						+ intervaloInicialPrestacao + " and "
						+ intervaloFinalPrestacao + "";

			}

			pesquisar += " group by" + " GP.GPAG_ID,"
					+ "gp.gpag_nnprestacaodebito"
					+ " order by gp.gpag_nnprestacaodebito";

			guiaPagamentoIds = (List<String>) session.createSQLQuery(pesquisar)
					.addScalar("idGuiaPagamento", Hibernate.STRING).list();

			if (guiaPagamentoIds.size() > 0) {

				for (String idGuiaParcelamentoJudicial : guiaPagamentoIds) {

					EmitirGuiasParcelamentoJudicialHelper helper = new EmitirGuiasParcelamentoJudicialHelper();

					helper.setIdGuiaParcelamentoJudicial((String) idGuiaParcelamentoJudicial
							.toString());
					listaRetorno.add(helper);

				}

			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return listaRetorno;

	}

	/**
	 * [UC1464] Cancelar Guia Atraso ParcelamentoJudicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 24/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public int tamanhoPesquisarObterListaParcelamentoJudicial(
			FiltrarManterParcelamentoJudicial filtroManterParcelamentoJudical)
			throws ErroRepositorioException {

		String codigoClienteResponsavel = filtroManterParcelamentoJudical
				.getCodigoClienteResponsavel();
		String codigoClienteUsuario = filtroManterParcelamentoJudical
				.getCodigoClienteUsuario();
		String matriculaImovel = filtroManterParcelamentoJudical
				.getMatriculaImovel();
		String processoJudicial = filtroManterParcelamentoJudical
				.getProcessoJudicial();
		String periodoInicialParcenamento = filtroManterParcelamentoJudical
				.getPeriodoInicialParcelamento();
		String periodoFinalParcelamento = filtroManterParcelamentoJudical
				.getPeriodoFinalParcelamento();
		Session session = HibernateUtil.getSession();

		int tamanhoColecaoObterListaParcelamentoJudicial;

		try {

			String pesquisar = "select count(distinct pj.pjud_id) as tamanhoColecao "
					+ "from "
					+ "COBRANCA.parcelamento_judicial pj "
					+ "inner join CADASTRO.cliente cl on (pj.clie_idresponsavel=cl.clie_id) "
					+ "inner join COBRANCA.parcelamento_situacao ps on (pj.pcst_id=ps.pcst_id) ";

			if (matriculaImovel != null && !matriculaImovel.equals("")) {

				pesquisar += "inner join COBRANCA.parcel_judicial_imov pji on (pj.pjud_id=pji.pjud_id) ";

			}

			if ((codigoClienteResponsavel != null && !codigoClienteResponsavel
					.equals(""))
					|| (codigoClienteUsuario != null && !codigoClienteUsuario
							.equals(""))
					|| (matriculaImovel != null && !matriculaImovel.equals(""))
					|| (processoJudicial != null && !processoJudicial
							.equals(""))
					|| ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals("")))) {

				pesquisar += "where";

			}

			if (codigoClienteResponsavel != null
					&& !codigoClienteResponsavel.equals("")) {

				pesquisar += " pj.clie_idresponsavel="
						+ codigoClienteResponsavel + "";

			}

			if ((codigoClienteResponsavel != null && !codigoClienteResponsavel
					.equals(""))
					&& ((codigoClienteUsuario != null && !codigoClienteUsuario
							.equals(""))
							|| (matriculaImovel != null && !matriculaImovel
									.equals(""))
							|| (processoJudicial != null && !processoJudicial
									.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {

				pesquisar += " and";

			}

			if (codigoClienteUsuario != null
					&& !codigoClienteUsuario.equals("")) {

				pesquisar += " pj.clie_idusuario=" + codigoClienteUsuario + "";

			}

			if ((codigoClienteUsuario != null && !codigoClienteUsuario
					.equals(""))
					&& ((matriculaImovel != null && !matriculaImovel.equals(""))
							|| (processoJudicial != null && !processoJudicial
									.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {
				pesquisar += " and";

			}

			if (matriculaImovel != null && !matriculaImovel.equals("")) {

				pesquisar += " pji.imov_id=" + matriculaImovel + "";

			}

			if (matriculaImovel != null
					&& !matriculaImovel.equals("")
					&& ((processoJudicial != null && !processoJudicial
							.equals("")) || ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals(""))))) {
				pesquisar += " and";

			}

			if (processoJudicial != null && !processoJudicial.equals("")) {

				pesquisar += " pj.pjud_nnprocessojudicial='" + processoJudicial
						+ "'";

			}

			if (processoJudicial != null
					&& !processoJudicial.equals("")
					&& ((periodoInicialParcenamento != null && !periodoInicialParcenamento
							.equals("")) && (periodoFinalParcelamento != null && !periodoFinalParcelamento
							.equals("")))) {

				pesquisar += " and";

			}

			if (periodoInicialParcenamento != null
					&& periodoFinalParcelamento != null
					&& !periodoInicialParcenamento.equals("")
					&& !periodoFinalParcelamento.equals("")) {

				pesquisar += " to_date(to_char(pj.pjud_tmparcelamento,'DD/MM/YYYY'),'DD/MM/YYYY') "
						+ "between to_date('"
						+ periodoInicialParcenamento
						+ "','DD/MM/YYYY') and to_date('"
						+ periodoFinalParcelamento + "','DD/MM/YYYY')";

			}

			tamanhoColecaoObterListaParcelamentoJudicial = (Integer) session
					.createSQLQuery(pesquisar)
					.addScalar("tamanhoColecao", Hibernate.INTEGER)
					.uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return tamanhoColecaoObterListaParcelamentoJudicial;
	}

	/**
	 * [UC1464] Cancelar Guia Atraso ParcelamentoJudicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 11/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<EmitirGuiasParcelamentoJudicialHelper> pesquisarContratoConcluidoCanceladoParcelamentoJudicial(
			String idParcelamentoJudicial, String idConcluido,
			String idCancelado) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		List<EmitirGuiasParcelamentoJudicialHelper> listaRetorno = new ArrayList<EmitirGuiasParcelamentoJudicialHelper>();
		List<String> colecaoContratoConcluidoCanceladoParcelamentoJudicial = null;

		try {

			String pesquisar = "select pj.pcst_id as idVerificarSituacaoContrato "
					+ "from cobranca.parcelamento_judicial pj "
					+ "inner join COBRANCA.parcelamento_situacao ps on (pj.pcst_id=ps.pcst_id) "
					+ "where pj.pjud_id="
					+ idParcelamentoJudicial
					+ " "
					+ "and pj.pcst_id in ("
					+ idConcluido
					+ ","
					+ idCancelado
					+ ")";

			pesquisar += " group by" + " pj.pcst_id";

			colecaoContratoConcluidoCanceladoParcelamentoJudicial = (List<String>) session
					.createSQLQuery(pesquisar)
					.addScalar("idVerificarSituacaoContrato", Hibernate.STRING)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		for (String idVerificarSituacaoContrato : colecaoContratoConcluidoCanceladoParcelamentoJudicial) {

			EmitirGuiasParcelamentoJudicialHelper helper = new EmitirGuiasParcelamentoJudicialHelper();

			helper.setVerificaContrato((String) idVerificarSituacaoContrato
					.toString());
			listaRetorno.add(helper);

		}
		return listaRetorno;
	}

	/**
	 * [UC1464] Cancelar Guia Atraso ParcelamentoJudicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 12/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public Collection<Object> pesquisarObterListaParcelamentoJudicialCancelarGuiaAtraso(
			String idParcelamentoJudicial) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		Collection<Object> colecaoObterListaParcelamentoJudicialCancelarGuiaAtraso = null;

		try {

			String pesquisar = "select"
					+ " pj.pjud_nnprocessojudicial as numeroProcesso,"
					+ "pji.imov_id as idImovel,"
					+ "cl.clie_nmcliente as nomeClienteReponsavel,"
					+ "pj.pjud_tmparcelamento as dataParcelamento"
					+ " from COBRANCA.parcelamento_judicial pj "
					+ "inner join CADASTRO.cliente cl on (pj.clie_idresponsavel=cl.clie_id) "
					+ "inner join COBRANCA.parcel_judicial_imov pji on (pji.pjud_id=pj.pjud_id and pji.pjim_icimovelprincipal=1) ";

			pesquisar += "where pj.pjud_id="
					+ idParcelamentoJudicial
					+ ""
					+ " and pj.pjud_id in (select gp.pjud_id from faturamento.GUIA_PAGAMENTO gp"
					+ "                    where gp.dbtp_id ="
					+ DebitoTipo.GUIA_ADICION_ATRASO_PARC_JUD + ""
					+ "                    and gp.pjud_id = pj.pjud_id )";

			pesquisar += " group by" + " pj.pjud_nnprocessojudicial,"
					+ "pji.imov_id," + "cl.clie_nmcliente,"
					+ "pj.pjud_tmparcelamento";

			colecaoObterListaParcelamentoJudicialCancelarGuiaAtraso = (Collection<Object>) session
					.createSQLQuery(pesquisar)
					.addScalar("numeroProcesso", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.STRING)
					.addScalar("nomeClienteReponsavel", Hibernate.STRING)
					.addScalar("dataParcelamento", Hibernate.DATE).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return colecaoObterListaParcelamentoJudicialCancelarGuiaAtraso;
	}

	/**
	 * [UC1464] Cancelar Guia Atraso ParcelamentoJudicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 11/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */

	public Collection<Object> pesquisarGuiasAtraso(
			String idParcelamentoJudicial, Integer debitoTipo)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<Object> colecaoRetorno = null;

		try {
			String pesquisar = "select"
					+ " gp.gpag_id as idGuia,"
					+ "gp.gpag_vldebito as valorDebito,"
					+ "gp.gpag_dtvencimento as dataVencimento,"
					+ "gp.gpag_dsobservacao as observacao"
					+ " from"
					+ " FATURAMENTO.guia_pagamento gp"
					+ " inner join FATURAMENTO.debito_tipo dt on (gp.dbtp_id=dt.dbtp_id)"
					+ " where";

			if ((idParcelamentoJudicial != null && !idParcelamentoJudicial
					.equals(""))
					&& (debitoTipo != null && !debitoTipo.equals(""))) {

				pesquisar += " gp.pjud_id=" + idParcelamentoJudicial + ""
						+ " and gp.dbtp_id=" + debitoTipo + "";
			}

			pesquisar += " and gp.gpag_id not in (select pgmt.gpag_id from arrecadacao.pagamento pgmt"
					+ " where gp.gpag_id = pgmt.gpag_id)";

			pesquisar += " group by" + " gp.gpag_id," + "gp.gpag_vldebito,"
					+ "gp.gpag_dtvencimento," + "gp.gpag_dsobservacao"
					+ " order by gp.gpag_dtvencimento";

			colecaoRetorno = session.createSQLQuery(pesquisar)
					.addScalar("idGuia", Hibernate.STRING)
					.addScalar("valorDebito", Hibernate.BIG_DECIMAL)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("observacao", Hibernate.STRING).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoRetorno;
	}

	/**
	 * [UC1464] Cancelar Guia Atraso ParcelamentoJudicial.
	 * 
	 * @author Jonathan Marcos
	 * @date 11/04/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void cancelarGuiaAtraso(String idsGuiaAtraso)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		int retorno;
		String deletar1 = "delete from ClienteGuiaPagamento clienteGuiaPagamento "
				+ "where clienteGuiaPagamento.guiaPagamento.id = :idGuiaAtraso ";

		Query query1 = session.createQuery(deletar1);
		query1.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno = (Integer) query1.executeUpdate();

		String deletar2 = "delete from GuiaPagamentoCategoria guiaPagamentoCategoria "
				+ "where guiaPagamentoCategoria.guiaPagamento.id = :idGuiaAtraso ";

		Query query2 = session.createQuery(deletar2);
		query2.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno += (Integer) query2.executeUpdate();

		String deletar3 = "delete from GuiaPagamentoItemCategoria guiaPagamentoItemCategoria "
				+ "where guiaPagamentoItemCategoria.guiaPagamentoItem in (select guiaPagamentoItem.id from GuiaPagamentoItem guiaPagamentoItem where guiaPagamentoItem.guiaPagamentoGeral = :idGuiaAtraso  )";

		Query query3 = session.createQuery(deletar3);
		query3.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno += (Integer) query3.executeUpdate();

		String deletar4 = "delete from GuiaPagamentoItem guiaPagamentoItem "
				+ "where guiaPagamentoItem.guiaPagamentoGeral.id = :idGuiaAtraso ";

		Query query4 = session.createQuery(deletar4);
		query4.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno += (Integer) query4.executeUpdate();

		String deletar5 = "delete from GuiaPagamento guiaPagamento "
				+ "where guiaPagamento.id = :idGuiaAtraso ";

		Query query5 = session.createQuery(deletar5);
		query5.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno += (Integer) query5.executeUpdate();

		String deletar6 = "delete from GuiaPagamentoGeral guiaPagamentoGeral "
				+ "where guiaPagamentoGeral.id = :idGuiaAtraso ";

		Query query6 = session.createQuery(deletar6);
		query6.setParameter("idGuiaAtraso", idsGuiaAtraso);
		retorno += (Integer) query6.executeUpdate();

		HibernateUtil.closeSession(session);

	}

	/**
	 * [UC1454] Gerar Guia de Atraso do Parcelamento Judicial
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 19/03/2013
	 */
	public Collection pesquisarParcelamentoJudicial()
			throws ErroRepositorioException {
		Collection<ParcelamentoJudicial> retorno = new ArrayList<ParcelamentoJudicial>();
		Session session = HibernateUtil.getSession();

		String consulta;

		try {

			consulta = " SELECT  pjud AS id "
					+ " FROM  ParcelamentoJudicial pjud "
					+ " WHERE pjud.indicadorPerderDesconto = 1 and pjud.parcelamentoSituacao.id = 1";

			retorno = session.createQuery(consulta).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1454] Gerar Guia de Atraso do Parcelamento Judicial
	 * 
	 * IT0002 - Obter Guias de Parcela com Atraso
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 25/03/2013
	 */
	public Collection<GuiaPagamento> pesquisarGuiaAtrasoParcelamentoJudicial(
			Integer idParcelamentoJudicial) throws ErroRepositorioException {

		Collection<GuiaPagamento> retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT gpag as guia "
					+ " FROM GuiaPagamento gpag "
					+ " WHERE gpag.parcelamentoJudicial.id = :idParcelamentoJudicial "
					+ " AND gpag.debitoTipo.id in ("
					+ DebitoTipo.PARCELAMENTO_JUDICIAL_CONTAS
					+ ","
					+ DebitoTipo.ENTRADA_PARCELAMENTO_JUDICIAL
					+ ")"
					+ " AND gpag.indicadorGerarGuiaAtrasoParcJudicial = 2"
					+ " AND gpag.dataVencimento < to_date('"
					+ Util.formatarDataComTracoAAAAMMDD(new Date())
					+ "','YYYY-MM-DD') "
					+ " AND gpag.id in (SELECT gpai.guiaPagamentoGeral.id "
					+ "                 FROM GuiaPagamentoItem gpai where gpai.guiaPagamentoGeral.id = gpag.id"
					+ "                 AND gpai.creditoTipo.id = "
					+ CreditoTipo.DESCONTO_PARCELAMENTO_JUDICIAL
					+ ")"
					+ " AND gpag.id not in (SELECT gp.id FROM Pagamento pgmt "
					+ "                   INNER JOIN pgmt.guiaPagamento gp where gp.id = gpag.id)";

			retorno = session
					.createQuery(consulta)
					.setInteger("idParcelamentoJudicial",
							idParcelamentoJudicial).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1454] Gerar Guia de Atraso do Parcelamento Judicial
	 * 
	 * IT0003 - Inserir Guia de Atraso PJ 6. Alterar o indicador de geração de
	 * guia de atraso para a guia selecionada
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 02/04/2013
	 */
	public void atualizarIndicadorGuiaAtrasoParcJudicial(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update GuiaPagamento gpag "
					+ " set GPAG_ICGERARGUIAATRASOPARCJUD = 1"
					+ " where gpag.id = :idGuiaPagamento ";

			session.createQuery(sql)
					.setInteger("idGuiaPagamento", idGuiaPagamento)
					.executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC1454] Gerar Guia de Atraso do Parcelamento Judicial
	 * 
	 * IT0003 - Inserir Guia de Atraso PJ
	 * 
	 * @author Ana Maria
	 * @throws ErroRepositorioException
	 * @date 03/04/2013
	 */
	public BigDecimal pesquisarValorGuiaItem(Integer idGuiaPagamento)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		BigDecimal retorno = null;
		String consulta = null;

		try {
			consulta = " SELECT gpai.valorDebito "
					+ " FROM GuiaPagamentoItem gpai  "
					+ " where gpai.guiaPagamentoGeral.id = :idGuiaPagamento "
					+ " AND gpai.creditoTipo.id = "
					+ CreditoTipo.DESCONTO_PARCELAMENTO_JUDICIAL;

			Object resultado = session.createQuery(consulta)
					.setInteger("idGuiaPagamento", idGuiaPagamento.intValue())
					.uniqueResult();

			if (resultado != null) {
				retorno = (BigDecimal) resultado;
			}
		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1461] Emitir Resumo do Parcelamento Judicial
	 * 
	 * IT0001 - Obter Dados do Parcelamento Judicial
	 * 
	 * @author Maxwell Moreira
	 * @throws ErroRepositorioException
	 * @date 12/04/2013
	 */

	public Collection obterParcelamentoJudicial(String idParcelamentoJudicial)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT parju.PJUD_NNPROCESSOJUDICIAL AS numeroProcesso, "
					+ " pajuimo.IMOV_ID as imovelPrincipal, "
					+ " cadcli.CLIE_NMCLIENTE clienteResponsavel, "
					+ " usu.USUR_NMUSUARIO as funcionario, "
					+ " parju.PJUD_NMADVOGADO as advogadoResponsavel, "
					+ " parju.PJUD_NNOAB as numeroOAB, "
					+ " parcsitu.PCST_DSPARCELAMENTOSITUACAO as situacao, "
					+ " parju.PJUD_TMPARCELAMENTO as dataParcelamento, "
					+ " parju.PJUD_VLCONTA + parju.PJUD_VLACRESCIMOS as valorDebitos, "
					+ " parju.PJUD_VLACORDO as valorAcordo, "
					+ " parju.PJUD_VLENTRADA as valorEntrada, "
					+ " parju.PJUD_VLCUSTAS as valorCustas, "
					+ " parju.PJUD_VLHONORARIO as valorHonorario, "
					+ " parju.PJUD_VLACORDO as valorAcordoParcelado, "
					+ " parju.PJUD_PCDESCONTO as percentualDesconto, "
					+ " parju.PJUD_PCCUSTAS as percentualCustas, "
					+ " parju.PJUD_PCHONORARIO as percentualHonorario, "
					+ " parju.PJUD_TXJUROS as taxaJuros, "
					+ " parju.PJUD_NNPRESTACOES as quantidadeParcelas, "
					+ " parju.PJUD_ICPERDERDESCONTO as indicadorDesconto, "
					+ " parju.PJUD_ICVALORCUSTA as indicadorCustas, "
					+ " parju.PJUD_ICVALORHONORARIO as indicadorHonorarios, "
					+ " parju.PJUD_ICPARCELAMENTOCOMJUROS as indicadorJuros, "
					+ " parju.PJUD_ICVALORINFORMAVALORPARC as indicadorInfValParc, "
					+ " parju.PJUD_ICENTRADA as indicadorEntrada "
					+

					" FROM cobranca.parcelamento_judicial parju "
					+

					" INNER JOIN COBRANCA.PARCEL_JUDICIAL_IMOV pajuimo on pajuimo.PJUD_ID = parju.PJUD_ID "
					+ " INNER JOIN CADASTRO.CLIENTE cadcli on cadcli.CLIE_ID = parju.CLIE_IDRESPONSAVEL "
					+ " INNER JOIN SEGURANCA.USUARIO usu on usu.USUR_ID = parju.USUR_ID "
					+ " INNER JOIN COBRANCA.PARCELAMENTO_SITUACAO parcsitu on parcsitu.PCST_ID = parju.PCST_ID "
					+

					" WHERE pajuimo.PJIM_ICIMOVELPRINCIPAL = 1 AND parju.PJUD_ID = :idParcelamentoJudicial ";

			retorno = session
					.createSQLQuery(consulta)

					.addScalar("numeroProcesso", Hibernate.STRING)
					.addScalar("imovelPrincipal", Hibernate.STRING)
					.addScalar("clienteResponsavel", Hibernate.STRING)
					.addScalar("funcionario", Hibernate.STRING)
					.addScalar("advogadoResponsavel", Hibernate.STRING)
					.addScalar("numeroOAB", Hibernate.STRING)
					.addScalar("situacao", Hibernate.STRING)
					.addScalar("dataParcelamento", Hibernate.STRING)
					.addScalar("valorDebitos", Hibernate.STRING)
					.addScalar("valorAcordo", Hibernate.STRING)
					.addScalar("valorEntrada", Hibernate.STRING)
					.addScalar("valorCustas", Hibernate.STRING)
					.addScalar("valorHonorario", Hibernate.STRING)
					.addScalar("valorAcordoParcelado", Hibernate.STRING)
					.addScalar("percentualDesconto", Hibernate.STRING)
					.addScalar("percentualCustas", Hibernate.STRING)
					.addScalar("percentualHonorario", Hibernate.STRING)
					.addScalar("taxaJuros", Hibernate.STRING)
					.addScalar("quantidadeParcelas", Hibernate.STRING)
					.addScalar("indicadorDesconto", Hibernate.STRING)
					.addScalar("indicadorCustas", Hibernate.STRING)
					.addScalar("indicadorHonorarios", Hibernate.STRING)
					.addScalar("indicadorJuros", Hibernate.STRING)
					.addScalar("indicadorInfValParc", Hibernate.STRING)
					.addScalar("indicadorEntrada", Hibernate.STRING)
					.setString("idParcelamentoJudicial", idParcelamentoJudicial)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1461] Emitir Resumo do Parcelamento Judicial
	 * 
	 * IT0002 - Obter Lista de Contas Parceladas
	 * 
	 * @author Maxwell Moreira
	 * @throws ErroRepositorioException
	 * @date 16/04/2013
	 */
	public Collection obterListaDeContasParceladas(String idParcelamentoJudicial)
			throws ErroRepositorioException {

		Collection retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {

			consulta = " SELECT facon.IMOV_ID AS imovel, "
					+ " facon.CNTA_AMREFERENCIACONTA AS anoMesConta, "
					+ " facon.CNTA_DTVENCIMENTOCONTA AS vencimentoConta, "
					+ " parjuitem.PJIT_VLCONTA AS valorConta, "
					+ " parjuitem.PJIT_VLACRESCIMOS AS acrescimoImpontualidade "
					+

					" FROM COBRANCA.PARCEL_JUDICIAL_ITEM parjuitem "
					+

					" INNER JOIN cobranca.parcelamento_judicial parju on parju.PJUD_ID = parjuitem.PJUD_ID "
					+ " INNER JOIN FATURAMENTO.CONTA facon on facon.CNTA_ID = parjuitem.CNTA_ID "
					+

					" WHERE parju.PJUD_ID = :idParcelamentoJudicial "
					+

					" UNION "
					+

					" SELECT faconhi.IMOV_ID AS imovel, "
					+ " faconhi.CNHI_AMREFERENCIACONTA AS anoMesConta, "
					+ " faconhi.CNHI_DTVENCIMENTOCONTA AS vencimentoConta, "
					+ " parjuitem.PJIT_VLCONTA AS valorConta, "
					+ " parjuitem.PJIT_VLACRESCIMOS AS acrescimoImpontualidade "
					+

					" FROM COBRANCA.PARCEL_JUDICIAL_ITEM parjuitem "
					+

					" INNER JOIN cobranca.parcelamento_judicial parju on parju.PJUD_ID = parjuitem.PJUD_ID "
					+ " INNER JOIN FATURAMENTO.CONTA_HISTORICO faconhi on faconhi.CNTA_ID = parjuitem.CNTA_ID "
					+

					" WHERE parju.PJUD_ID = :idParcelamentoJudicial " +

					" ORDER BY imovel ASC, anoMesConta ASC ";

			retorno = session
					.createSQLQuery(consulta)
					.addScalar("imovel", Hibernate.STRING)
					.addScalar("anoMesConta", Hibernate.STRING)
					.addScalar("vencimentoConta", Hibernate.STRING)
					.addScalar("valorConta", Hibernate.STRING)
					.addScalar("acrescimoImpontualidade", Hibernate.STRING)
					.setString("idParcelamentoJudicial", idParcelamentoJudicial)
					.list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1441] Efetuar Parcelamento Judicial [IT0011] Verificar Existência de
	 * Número do Processo Judicial
	 * 
	 * @author Hugo Azevedo
	 * @date 15/04/2013
	 * 
	 */
	public ParcelamentoJudicial pesquisarParcelamentoJudicialPorNumeroProcesso(
			String numeroProcesso) throws ErroRepositorioException {

		ParcelamentoJudicial retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String sql = " select pj " + " from ParcelamentoJudicial pj "
					+ " inner join pj.parcelamentoSituacao ps "
					+ " where pj.numeroProcesso = :numeroProcesso "
					+ " and (ps.id = :sitNormal or ps.id = :sitConcluido)";

			retorno = (ParcelamentoJudicial) session.createQuery(sql)
					.setString("numeroProcesso", numeroProcesso)
					.setInteger("sitNormal", ParcelamentoSituacao.NORMAL)
					.setInteger("sitConcluido", ParcelamentoSituacao.CONCLUIDO)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * 
	 * [UC1463] Cancelar Parcelamento Judicial [IT0001] Obter Dados do
	 * Parcelamento Judicial
	 * 
	 * @author Hugo Azevedo
	 * @date 16/03/2013
	 */
	public ParcelamentoJudicialImovel obterParcelamentoJudicialImovel(
			Integer idParcelamento) throws ErroRepositorioException {
		ParcelamentoJudicialImovel retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String sql = " select pji "
					+ " from ParcelamentoJudicialImovel pji "
					+ " inner join fetch pji.parcelamentoJudicial pj"
					+ " inner join fetch pji.imovel imov"
					+ " inner join fetch pj.clienteResponsavel clie"
					+ " where pj.id = :id ";

			retorno = (ParcelamentoJudicialImovel) session.createQuery(sql)
					.setInteger("id", idParcelamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * [UC1463] Cancelar Parcelamento Judicial [IT0002] Obter Lista de Motivos
	 * de Cancelamento
	 * 
	 * @author Hugo Azevedo
	 * @date 16/03/2013
	 */
	public Collection<ParcelamentoMotivoDesfazer> obterListaMotivosCancelamento()
			throws ErroRepositorioException {

		Collection<ParcelamentoMotivoDesfazer> retorno = null;
		Session session = HibernateUtil.getSession();

		try {
			String sql = " select pmf "
					+ " from ParcelamentoMotivoDesfazer pmf"
					+ " where pmf.indicadorUso = :indicadorAtivo "
					+ " order by pmf.descricaoParcelamentoMotivoDesfazer";

			retorno = (Collection<ParcelamentoMotivoDesfazer>) session
					.createQuery(sql)
					.setShort("indicadorAtivo", ConstantesSistema.SIM).list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1465] Gerar Relatório das Parcelas em Atraso do Parcelamento Judicial
	 * 
	 * [IT0001] Pesquisar Parcelas em Atraso. [IT0002] Obter Dados das Parcelas
	 * Em Atraso.
	 * 
	 * @author Mariana Victor
	 * @date 23/04/2013
	 */
	public Collection<Object[]> pesquisarParcelasEmAtrasoParcelamentoJudicial(
			FiltrarRelatorioParcelasEmAtrasoParcelamentoJudicialHelper helper)
			throws ErroRepositorioException {

		Collection<Object[]> retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String consulta = " select pjud.pjud_id AS idParcelamento, "
					+ "   clie.clie_id AS idCliente, "
					+ "   clie.clie_nmcliente AS nomeCliente, "
					+ "   pjim.imov_id AS idImovel, "
					+ "   pjud.pjud_nnprocessojudicial AS numeroProcesso, "
					+ "   gpag.gpag_nnprestacaodebito AS numeroPrestacao, "
					+ "   gpag.gpag_dtvencimento AS dataVencimento, "
					+ "   gpag.gpag_vldebito AS valorGuia, "
					+ "   (:dataAtual - gpag.gpag_dtvencimento) AS quantidadeDiasAtraso "
					+ " from faturamento.guia_pagamento gpag "
					+ "   inner join cobranca.parcelamento_judicial pjud on pjud.pjud_id = gpag.pjud_id "
					+ "   inner join cobranca.parcel_judicial_imov pjim on pjim.pjud_id = pjud.pjud_id and pjim.pjim_icimovelprincipal = 1 "
					+ "   inner join cadastro.cliente clie on clie.clie_id = pjud.clie_idresponsavel "
					+ " where gpag.dbtp_id = :idDebitoTipo "
					+ "   and gpag.gpag_dtvencimento < :dataAtual "
					+ "   and gpag.gpag_id not in (select pgmt.gpag_id from arrecadacao.pagamento pgmt where pgmt.gpag_id is not null) ";

			if (helper.getIdClienteResponsavel() != null
					&& helper.getIdClienteResponsavel().compareTo(
							new Integer("0")) > 0) {
				consulta = consulta
						+ " and pjud.clie_idresponsavel = :idClienteResponsavel ";
			}

			if (helper.getIdImovelPrincipal() != null
					&& helper.getIdImovelPrincipal()
							.compareTo(new Integer("0")) > 0) {
				consulta = consulta + " and pjim.imov_id = :idImovelPrincipal ";
			}

			if (helper.getNumeroProcessoJudicial() != null
					&& !helper.getNumeroProcessoJudicial().trim().equals("")) {
				consulta = consulta
						+ " and pjud.pjud_nnprocessojudicial = :numeroProcesso ";
			}

			if (helper.getQuantidadeDiasAtraso() != null
					&& helper.getQuantidadeDiasAtraso().compareTo(
							new Integer("0")) > 0) {
				consulta = consulta
						+ " and (:dataAtual - gpag.gpag_dtvencimento) <= :quantidadeDias ";
			}

			if (helper.getDataParcelamentoInicial() != null
					&& helper.getDataParcelamentoFinal() != null) {
				consulta = consulta
						+ " and pjud.pjud_tmparcelamento between :dataInicial and :dataFinal ";
			}

			consulta = consulta
					+ " order by pjud.pjud_id, clie.clie_nmcliente, pjim.imov_id, pjud.pjud_nnprocessojudicial, "
					+ "   gpag.gpag_nnprestacaodebito, gpag.gpag_dtvencimento, gpag.gpag_vldebito ";

			Query query = session
					.createSQLQuery(consulta)
					.addScalar("idParcelamento", Hibernate.INTEGER)
					.addScalar("idCliente", Hibernate.INTEGER)
					.addScalar("nomeCliente", Hibernate.STRING)
					.addScalar("idImovel", Hibernate.INTEGER)
					.addScalar("numeroProcesso", Hibernate.STRING)
					.addScalar("numeroPrestacao", Hibernate.INTEGER)
					.addScalar("dataVencimento", Hibernate.DATE)
					.addScalar("valorGuia", Hibernate.BIG_DECIMAL)
					.addScalar("quantidadeDiasAtraso", Hibernate.INTEGER)
					.setInteger("idDebitoTipo",
							DebitoTipo.PARCELAMENTO_JUDICIAL_CONTAS)
					.setDate("dataAtual", new Date());

			if (helper.getIdClienteResponsavel() != null
					&& helper.getIdClienteResponsavel().compareTo(
							new Integer("0")) > 0) {

				query.setInteger("idClienteResponsavel",
						helper.getIdClienteResponsavel());
			}

			if (helper.getIdImovelPrincipal() != null
					&& helper.getIdImovelPrincipal()
							.compareTo(new Integer("0")) > 0) {

				query.setInteger("idImovelPrincipal",
						helper.getIdImovelPrincipal());
			}

			if (helper.getNumeroProcessoJudicial() != null
					&& !helper.getNumeroProcessoJudicial().trim().equals("")) {

				query.setString("numeroProcesso",
						helper.getNumeroProcessoJudicial());
			}

			if (helper.getQuantidadeDiasAtraso() != null
					&& helper.getQuantidadeDiasAtraso().compareTo(
							new Integer("0")) > 0) {

				query.setInteger("quantidadeDias",
						helper.getQuantidadeDiasAtraso());
			}

			if (helper.getDataParcelamentoInicial() != null
					&& helper.getDataParcelamentoFinal() != null) {

				query.setTimestamp(
						"dataInicial",
						Util.formatarDataInicial(helper
								.getDataParcelamentoInicial())).setTimestamp(
						"dataFinal",
						Util.formatarDataFinal(helper
								.getDataParcelamentoFinal()));
			}

			retorno = query.list();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1452] Consultar Dados do Parcelamento Judicial. [IT0003] Obter PDF do
	 * Parcelamento Judicial.
	 * 
	 * @author Ana Maria
	 * @date 03/05/2013
	 */
	public ParcelamentoJudicial obterParcelamentoJudicial(Integer idParcelamento)
			throws ErroRepositorioException {
		ParcelamentoJudicial retorno = null;
		Session session = HibernateUtil.getSession();

		try {

			String sql = " select pj " + " from ParcelamentoJudicial pj "
					+ " where pj.id = :id ";

			retorno = (ParcelamentoJudicial) session.createQuery(sql)
					.setInteger("id", idParcelamento).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			// levanta a exce??o para a pr?xima camada
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobran?a por Empresa
	 * 
	 * @author: Raphael Rossiter
	 * @date: 04/07/2013
	 */
	public void inserirImovelEmpresaCobrancaComandoAberto()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String primeiraGeracao = null;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			primeiraGeracao = "INSERT INTO cobranca.imov_empr_cobr_cecc_aber (imov_id) "
					+ "SELECT DISTINCT emprcobconta.imov_id "
					+ "FROM cobranca.empresa_cobranca_conta emprcobconta "
					+ "INNER JOIN cobranca.cmd_empr_cobr_conta cecc on emprcobconta.cecc_id = cecc.cecc_id "
					+ "WHERE cecc.cecc_dtencerramento IS NULL ";

			st = con.prepareStatement(primeiraGeracao);
			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * [UC0870] GerarMovimentoContasEmCobrancaPorEmpresa
	 * 
	 * @author Raphael Rossiter
	 * @date 26/02/2013
	 * 
	 * @throws ErroRepositorioException
	 */
	public void removerImovelEmpresaCobrancaComandoAberto()
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String delete;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			delete = "TRUNCATE TABLE cobranca.imov_empr_cobr_cecc_aber ";

			st = con.prepareStatement(delete);
			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Insert");
		} finally {
			HibernateUtil.closeSession(session);

			try {
				st.close();
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}
	}

	/**
	 * 
	 * Método que verifica se o documento ja foi utilizado para devolução
	 * 
	 * @author Rodrigo Cabral
	 * @date 26/08/2013
	 */
	public Integer verificarDocumentoUtilizadoParaDevolucao(
			Integer idDocumento, Short documentoTipo, Integer idRA)
			throws ErroRepositorioException {

		Integer retorno = null;
		Session session = HibernateUtil.getSession();
		String consulta;

		try {
			consulta = " SELECT rgat_id AS id " // 0
					+ "  FROM atendimentopublico.ra_devolucao_valores "
					+ "  WHERE radv_cdtipodevolucao = 3 and ";

			if (documentoTipo.equals(new Short("1"))) {
				consulta = consulta + " cnta_id = " + idDocumento;
			} else if (documentoTipo.equals(new Short("7"))) {
				consulta = consulta + " gpag_id = " + idDocumento;
			} else if (documentoTipo.equals(new Short("6"))) {
				consulta = consulta + " dbac_id = " + idDocumento;
			}

			if (idRA != null)
				consulta += " and rgat_id <> :idRA";

			Query q = session.createSQLQuery(consulta).addScalar("id",
					Hibernate.INTEGER);

			if (idRA != null)
				q.setInteger("idRA", idRA);

			retorno = (Integer) q.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa [SB0010] Atualizar Comando de Cobrança
	 * 
	 * @author Mariana Victor
	 * @date 13/09/2013
	 */
	public void atualizarComandoEmpresaCobrancaConta(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		try {

			String sql = " update ComandoEmpresaCobrancaConta cecc "
					+ " set cecc_icinclusaonaogeracao = :indicador, cecc_tmultimaalteracao = :dataAtual "
					+ " where cecc.id = :idComando";

			session.createQuery(sql)
					.setShort("indicador", ConstantesSistema.SIM)
					.setTimestamp("dataAtual", new Date())
					.setInteger("idComando", idComando).executeUpdate();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * [UC0867] Atualizar Pagamentos das Contas em Cobrança
	 * 
	 * inserir colecao de EmpresaCobrancaContaPagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 21/02/2013
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public void inserirImovelContaNaoGeracaoCobrancaResultado(
			Integer idComando, Integer idMotivo, Integer idImovel,
			Integer idConta) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		String insert;

		Connection con = null;
		PreparedStatement st = null;

		try {

			con = session.connection();

			insert = "insert into cobranca.imo_cnta_nao_ger_cob_res ("
					+ "icgc_id, " + "cecc_id, " + "mngc_id, " + "imov_id, "
					+ "icgc_tmultimaalteracao, " + "icgc_dtnaogeracao, "
					+ "cnta_id " + ") values ("
					+ "cobranca.seq_imo_cnta_nao_ger_cob_res.nextval, "
					+ " ?, ?, ?, sysdate, ?, ";

			if (idConta != null) {
				insert += "? ";
			} else {
				insert += "null ";
			}

			insert += ") ";

			st = con.prepareStatement(insert);

			int i = 1;

			st.setInt(i, idComando);
			i++;

			st.setInt(i, idMotivo);
			i++;

			st.setInt(i, idImovel);
			i++;

			st.setDate(i, Util.getSQLDate(new Date()));
			i++;

			if (idConta != null) {
				st.setInt(i, idConta);
				i++;
			}

			st.executeUpdate();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st) {
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e,
							"Erro ao fechar conexões");
				}
			}
			HibernateUtil.closeSession(session);

			try {
				con.close();
			} catch (SQLException e) {
				throw new ErroRepositorioException(e, "Erro ao fechar conexões");
			}
		}

	}

	/**
	 * [UC0214] - Efetuar Parcelamento de Débitos [SB0014] - Verificar desconto
	 * para pagamento parcelado considerando o percentual da entrada.
	 * 
	 * @author Vivianne Sousa
	 * @date 02/08/2013
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ParcelaEntradaDesconto obterParcelaEntradaDesconto(
			Integer idParcelamentoQuantidadeReparcelamento,
			BigDecimal percentualEntrada) throws ErroRepositorioException {

		ParcelaEntradaDesconto retorno;
		Session session = HibernateUtil.getSession();
		String consulta = "";

		try {

			consulta = "SELECT parcelaEntradaDesconto "
					+ "FROM ParcelaEntradaDesconto parcelaEntradaDesconto "
					+ "WHERE parcelaEntradaDesconto.parcelamentoQuantidadeReparcelamento.id = :idParcelamentoQuantidadeReparcelamento "
					+ "AND parcelaEntradaDesconto.percentualEntrada >= :percentualEntrada "
					+ "ORDER BY parcelaEntradaDesconto.percentualEntrada ";

			retorno = (ParcelaEntradaDesconto) session
					.createQuery(consulta)
					.setInteger("idParcelamentoQuantidadeReparcelamento",
							idParcelamentoQuantidadeReparcelamento)
					.setBigDecimal("percentualEntrada", percentualEntrada)
					.setMaxResults(1).uniqueResult();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * 
	 * Busca as contas associadas ao comando de cobrança do imóvel da ordem de
	 * serviço que estão canceladas
	 * 
	 * @author Hugo Azevedo
	 * @date 12/09/2013
	 */
	public Collection<Object[]> verificarContasCanceladasAssociadas(Integer idOS)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = null;
		try {
			String sql = "SELECT ecco.cnta_id AS conta, ecco.ecco_amreferenciaconta AS mesAno "
					+ " FROM cobranca.empresa_cobranca_conta ecco "
					+ " INNER JOIN faturamento.conta cnta on cnta.cnta_id = ecco.cnta_id "
					+ " WHERE ecco.orse_id = :idOS "
					+ " AND cnta.dcst_idatual = 3 ";

			retorno = session.createSQLQuery(sql)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("mesAno", Hibernate.INTEGER)
					.setInteger("idOS", idOS).list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * 
	 * Busca a faixa de atraso do débito
	 * 
	 * @author Hugo Azevedo
	 * @date 12/09/2013
	 */
	public String obterFaixaAtrasoDebito(Integer idImovel, Integer idComando)
			throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		String retorno = null;
		try {
			String sql = " SELECT emcf.emcf_dsfaixa as dsfaixa "
					+ " FROM cadastro.empr_cobr_faixa emcf "
					+ " INNER JOIN cadastro.empr_contrato_cobranca emco "
					+ " ON emco.emco_id = emcf.emco_id "
					+ " INNER JOIN cobranca.empresa_cobranca_conta ecc "
					+ " ON ecc.empr_id                = emco.empr_id "
					+ " WHERE ecc.ecco_pcempresaconta = emcf.emcf_pcfaixa "
					+ " AND ecc.imov_id               = :idImovel "
					+ " AND ecc.cecc_id               = :idComando ";

			retorno = (String) session.createSQLQuery(sql)
					.addScalar("dsfaixa", Hibernate.STRING)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).setMaxResults(1)
					.uniqueResult();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0870] Gerar Movimento de Contas em Cobrança por Empresa
	 * 
	 * Método que pesquisa se o comando possui setores associados na tabela
	 * COBRANCA.CMD_EMPR_COBR_CONTA_CBST
	 * 
	 * @author Mariana Victor
	 * @date 11/10/2013
	 * 
	 * */
	public Collection<CobrancaSituacao> pesquisarComandoEmpresaCobrancaContaCobrancaSituacao(
			Integer idComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<CobrancaSituacao> retorno = null;

		try {

			String sql = "SELECT cecb.cobrancaSituacao "
					+ " FROM ComandoEmpresaCobrancaContaCobrancaSituacao cecb  "
					+ " INNER JOIN cecb.cobrancaSituacao cobrancaSituacao "
					+ " INNER JOIN cecb.comandoEmpresaCobrancaConta cecc "
					+ " WHERE cecc.id = :idComando "
					+ "	ORDER BY cobrancaSituacao.descricao ";

			retorno = session.createQuery(sql)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * [UC1321] Gerar Motivos Não Geração de Contas e Imóveis em Cobrança por
	 * Empresa
	 * 
	 * @author Mariana Victor
	 * @date 11/10/2013
	 */
	public boolean verificarImovelSituacaoCobrancaSelecionada(Integer idImovel,
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		boolean retorno = false;

		try {

			String sql = " select count(*) as quantidade "
					+ " from cadastro.imovel imov  "
					+ " where imov.imov_id = :idImovel "
					+ "  and not exists (select iscb.iscb_id "
					+ "               from cadastro.imovel_cobranca_situacao iscb "
					+ "                 inner join cobranca.cmd_empr_cobr_conta_cbst cecb on cecb.cbst_id = iscb.cbst_id "
					+ "               where cecb.cecc_id = :idComando "
					+ "                 and iscb.imov_id = imov.imov_id "
					+ "                 and iscb.iscb_dtretiradacobranca is null) "
					+ "  and exists (select cecb.cbst_id "
					+ "               from cobranca.cmd_empr_cobr_conta_cbst cecb "
					+ "               where cecb.cecc_id = :idComando) ";

			Integer quantidade = (Integer) session.createSQLQuery(sql)
					.addScalar("quantidade", Hibernate.INTEGER)
					.setInteger("idImovel", idImovel)
					.setInteger("idComando", idComando).uniqueResult();

			if (quantidade != null && quantidade.intValue() > 0) {
				retorno = true;
			}

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * PE2013089438 - Incluir Código de Barras no Documento Ordem de Corte
	 * [UC1054] - Gerar Ordem de Corte
	 * 
	 * @author Diogo Luiz
	 * @date 02/12/2013
	 * @param OrdemServico
	 */
	public Collection gerarDocumentoCobranca(OrdemServico ordemServico, Date dataEmissaoValidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Imovel imovel = ordemServico.getImovel();
		Collection retorno = null;

		try {
			String consulta = " select "
					+ " im.loca_id as localidade, " // 00
					+ " im.qdra_id as quadra, " // 01
					+ " st.stcm_cdsetorcomercial as setorComercial, " // 02
					+ " qd.qdra_nnquadra as numeroQuadra, " // 03
					+ " sum(coalesce(cnt.cnta_vlimpostos,0)) as valorImposto, " // 04
					+ " sum(coalesce(cnt.cnta_vlagua + cnt.cnta_vlesgoto + cnt.cnta_vldebitos -  "
					+ "     cnt.cnta_vlcreditos - cnt.cnta_vlimpostos,0)) as somatorioValorDocumento, " // 05
					+ " im.iper_id as imovelPerfil " // 06
					+ " from faturamento.conta cnt "
					+ " inner join cadastro.imovel im on im.imov_id = :imov_id "
					+ " inner join cadastro.setor_comercial st on st.stcm_id = im.stcm_id "
					+ " inner join cadastro.quadra qd on qd.qdra_id = im.qdra_id "
					+ " where cnt.imov_id = :imov_id and cnt.dcst_idatual in (0,1,2) "
					+ " 							 and cnt.cnta_id not in (select pg.cnta_id "
					+ " 							                		 from arrecadacao.pagamento pg "
					+ " 													 where pg.cnta_id = cnt.cnta_id) "
					
					+ " and cnt.cnta_id in( SELECT cdit.cnta_id "
					+ " FROM cobranca.cobranca_documento cbdo "
					+ " INNER JOIN cobranca.documento_tipo dotp ON dotp.dotp_id = cbdo.dotp_id "
					+ " LEFT JOIN faturamento.documento_nao_entregue done ON done.cbdo_id = cbdo.cbdo_id "
					+ " INNER JOIN COBRANCA.cobranca_documento_item cdit ON cdit.cbdo_id = cbdo.cbdo_id "
					+ " WHERE cbdo.imov_id = im.imov_id "
					+ " AND dotp.dotp_id   = :idDocumentoTipo "
					+ " AND (done.dotp_id IS NULL OR done.dotp_id  <> dotp.dotp_id) "
					+ " AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade) "
					
					+ " group by im.loca_id, im.qdra_id, st.stcm_cdsetorcomercial, qd.qdra_nnquadra, im.iper_id ";

			retorno = (Collection) session
					.createSQLQuery(consulta)
					.addScalar("localidade", Hibernate.INTEGER)
					.addScalar("quadra", Hibernate.INTEGER)
					.addScalar("setorComercial", Hibernate.INTEGER)
					.addScalar("numeroQuadra", Hibernate.STRING)
					.addScalar("valorImposto", Hibernate.BIG_DECIMAL)
					.addScalar("somatorioValorDocumento", Hibernate.BIG_DECIMAL)
					.addScalar("imovelPerfil", Hibernate.INTEGER)
					.setInteger("imov_id", imovel.getId())
					.setInteger("idDocumentoTipo", DocumentoTipo.AVISO_CORTE)
					.setDate("dataEmissaoValidade", dataEmissaoValidade)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	/**
	 * [UC0325] Consultar Comandos de Ação de Cobrança
	 * 
	 * Cancela os Documentos de Cobrancas Gerados do Cronograma ou Eventual
	 * 
	 * @author Raphael Rossiter
	 * @date 30/12/2013
	 * 
	 * */
	public Collection<Integer> pesquisarIdsDocumentosCobranca(Integer idCobrancaAcaoAtividadeCronograma, Integer idCobrancaAcaoAtividadeComando)
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		Collection <Integer> retorno = null;
		
		try {
			
			String sql = "SELECT cbdo.id " 
					+ " FROM CobrancaDocumento cbdo ";
			
			if (idCobrancaAcaoAtividadeCronograma != null){
				
				sql += "INNER JOIN cbdo.cobrancaAcaoAtividadeCronograma caac "
					+ " WHERE caac.id = :idComando "
					+ "	ORDER BY cbdo.id ";
				
				retorno = session.createQuery(sql).setInteger("idComando", idCobrancaAcaoAtividadeCronograma).list();
			}
			else{
				
				sql += "INNER JOIN cbdo.cobrancaAcaoAtividadeComando cacm "
					+ " WHERE cacm.id = :idComando "
					+ "	ORDER BY cbdo.id ";
				
				retorno = session.createQuery(sql).setInteger("idComando", idCobrancaAcaoAtividadeComando).list();
			}
			
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}
	
	/**
	 * 
	 * @author Flavio Ferreira
	 * @date 18/12/2013
	 * 
	 */
	public Collection pesquisarListaDeSetoresComercialParaComandoCobrancaEventual(
			Integer idComando) throws ErroRepositorioException {
		Session sessao = HibernateUtil.getSession();
		Collection retorno = null;
		String consulta = null;

		try {
			consulta = " select distinct cdSetor.stcm_cdsetorcomercial as codigoSetor, cdSetor.stcm_nmsetorcomercial as descricao from cadastro.setor_comercial cdSetor "
					+ " inner join cobranca.cob_acao_atv_cmd_stcm cbAcao on cbAcao.stcm_id = cdSetor.stcm_id "
					+ " where cbAcao.cacm_id = :idComando";

			retorno = sessao.createSQLQuery(consulta)
					.addScalar("codigoSetor", Hibernate.INTEGER)
					.addScalar("descricao", Hibernate.STRING)
					.setInteger("idComando", idComando).list();

		} catch (HibernateException ex) {
			throw new ErroRepositorioException(ex, "Erro Hibernate");
		} finally {
			HibernateUtil.closeSession(sessao);
		}

		return retorno;
	}

	/**
	 * PE2013089438 - Incluir Código de Barras no Documento Ordem de Corte
	 * [UC1054] - Gerar Ordem de Corte
	 * 
	 * @author Diogo Luiz
	 * @date 02/12/2013
	 * @param OrdemServico
	 */
	public Collection gerarItemDocumentoCobranca(OrdemServico ordemServico, Date dataEmissaoValidade)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Imovel imovel = ordemServico.getImovel();
		Collection retorno = null;

		try {
			String consulta = " select "
					+ " cnt.cnta_id AS conta, " // 00
					+ " SUM(coalesce(cnt.cnta_vlagua + cnt.cnta_vlesgoto + cnt.cnta_vldebitos  "
					+ "      - cnt.cnta_vlcreditos - cnt.cnta_vlimpostos,0)) AS somatorioValorDocumento " // 01
					+ " FROM faturamento.conta cnt "
					+ " inner join cadastro.imovel im on im.imov_id = :imov_id "
					+ " where cnt.imov_id = :imov_id and cnt.dcst_idatual in (0,1,2) "
					+ " 							 and cnt.cnta_id not in(SELECT pg.cnta_id "
					+ " 							                		from arrecadacao.pagamento pg "
					+ "  													 where pg.cnta_id = cnt.cnta_id) "
					
					+ " and cnt.cnta_id in( SELECT cdit.cnta_id "
					+ " FROM cobranca.cobranca_documento cbdo "
					+ " INNER JOIN cobranca.documento_tipo dotp ON dotp.dotp_id = cbdo.dotp_id "
					+ " LEFT JOIN faturamento.documento_nao_entregue done ON done.cbdo_id = cbdo.cbdo_id "
					+ " INNER JOIN COBRANCA.cobranca_documento_item cdit ON cdit.cbdo_id = cbdo.cbdo_id "
					+ " WHERE cbdo.imov_id = im.imov_id "
					+ " AND dotp.dotp_id   = :idDocumentoTipo "
					+ " AND (done.dotp_id IS NULL OR done.dotp_id  <> dotp.dotp_id) "
					+ " AND cbdo.cbdo_tmemissao >= :dataEmissaoValidade) "

					+ " group by cnt.cnta_id ";

			retorno = (Collection) session
					.createSQLQuery(consulta)
					.addScalar("conta", Hibernate.INTEGER)
					.addScalar("somatorioValorDocumento", Hibernate.BIG_DECIMAL)
					.setInteger("imov_id", imovel.getId())
					.setInteger("idDocumentoTipo", DocumentoTipo.AVISO_CORTE)
					.setDate("dataEmissaoValidade", dataEmissaoValidade)
					.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;
	}

	
	
	/**
	 * 
	 * Filtrar os Comandos de Ação de Cobrança tipo comando Eventual
	 * 
	 * [UC0326] - Filtrar Comandos de Ação de Cobrança
	 * 
	 * @author Rafael Pinto
	 * @date 20/12/2013
	 * 
	 */
	public Collection<CobrancaAcaoAtividadeComando> pesquisarCobrancaAcaoAtividadeComando(
			FiltrarComandosAcaoCobrancaEventualHelper helper)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<CobrancaAcaoAtividadeComando> retorno = null;
		Map parametros = new HashMap();
		Query query = null;

		String[] grupoCobranca = helper.getGrupoCobranca();
		String[] acaoCobranca = helper.getAcaoCobranca();
		String[] atividadeCobranca = helper.getAtividadeCobranca();
		String[] idCobrancaAcaoAtividadeComando = helper
				.getIdCobrancaAcaoAtividadeComando();

		String anoMesPeriodoReferenciaContasInicial = helper
				.getAnoMesPeriodoReferenciaContasInicial();
		String anoMesPeriodoReferenciaContasFinal = helper
				.getAnoMesPeriodoReferenciaContasFinal();
		Date dataPeriodoComandoInicial = helper.getDataPeriodoComandoInicial();
		Date dataPeriodoComandoFinal = helper.getDataPeriodoComandoFinal();
		Date dataPeriodoRealizacaoComandoInicial = helper
				.getDataPeriodoRealizacaoComandoInicial();
		Date dataPeriodoRealizacaoComandoFinal = helper
				.getDataPeriodoRealizacaoComandoFinal();
		Date dataPeriodoVencimentoContasInicial = helper
				.getDataPeriodoVencimentoContasInicial();
		Date dataPeriodoVencimentoContasFinal = helper
				.getDataPeriodoVencimentoContasFinal();
		BigDecimal intervaloValorDocumentosInicial = helper
				.getIntervaloValorDocumentosInicial();
		BigDecimal intervaloValorDocumentosFinal = helper
				.getIntervaloValorDocumentosFinal();
		String intervaloQuantidadeDocumentosInicial = helper
				.getIntervaloQuantidadeDocumentosInicial();
		String intervaloQuantidadeDocumentosFinal = helper
				.getIntervaloQuantidadeDocumentosFinal();
		String intervaloQuantidadeItensDocumentosInicial = helper
				.getIntervaloQuantidadeItensDocumentosInicial();
		String intervaloQuantidadeItensDocumentosFinal = helper
				.getIntervaloQuantidadeItensDocumentosFinal();
		String situacaoComando = helper.getSituacaoComando();
		Integer indicadorCriterio = helper.getIndicadorCriterio();
		String idGerenciaRegional = helper.getIdGerenciaRegional();
		String idLocalidadeInicial = helper.getIdLocalidadeInicial();
		String idLocalidadeFinal = helper.getIdLocalidadeFinal();
		String codigoSetorComercialInicial = helper
				.getCodigoSetorComercialInicial();
		String codigoSetorComercialFinal = helper
				.getCodigoSetorComercialFinal();
		String idRotaInicial = helper.getIdRotaInicial();
		String idRotaFinal = helper.getIdRotaFinal();
		String idCliente = helper.getIdCliente();
		String idClienteRelacaoTipo = helper.getIdClienteRelacaoTipo();
		String criterioCobranca = helper.getCriterioCobranca();
		String unidadeNegocio = helper.getUnidadeNegocio();

		Date dataEmissaoInicial = helper.getDataEmissaoInicial();
		Date dataEmissaoFinal = helper.getDataEmissaoFinal();
		String consumoMedioInicial = helper.getConsumoMedioInicial();
		String consumoMedioFinal = helper.getConsumoMedioFinal();
		String tipoConsumo = helper.getTipoConsumo();
		Date periodoInicialFiscalizacao = helper
				.getPeriodoInicialFiscalizacao();
		Date periodoFinalFiscalizacao = helper.getPeriodoFinalFiscalizacao();

		String numeroQuadraInicial = helper.getNumeroQuadraInicial();
		String numeroQuadraFinal = helper.getNumeroQuadraFinal();

		String quantidadeDiasVencimento = helper.getQuantidadeDiasVencimento();
		String ligacaoAlteradaDebito = helper.getLigacaoAlteradaDebito();

		String[] idsLocalidadeApartirGerenciaRegional = helper
				.getIdsLocalidadeApartirGerenciaRegional();
		String[] idsSetoresApartirLocalidadeUnica = helper
				.getIdsSetoresApartirLocalidadeUnica();
		String localidadeUnica = helper.getLocalidadeUnica();

		try {

			String sql = "SELECT cobrancaAcaoAtividadeComando "
					+ " FROM CobrancaAcaoAtividadeComando cobrancaAcaoAtividadeComando  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.gerenciaRegional gerenciaRegional  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.localidade localidade  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.localidadeInicial localidadeInicial  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.localidadeFinal localidadeFinal  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.rotaInicial rotaInicial  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.rotaFinal rotaFinal  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cliente cliente  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.clienteRelacaoTipo clienteRelacaoTipo  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaCriterio cobrancaCriterio  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaGrupo cobrancaGrupo  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaAcao cobrancaAcao  "
					+ " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaAtividade cobrancaAtividade  "
					// +
					// " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaAcaoAtividadeComandoSetorComercial cobrancaSetor "
					// +
					// " LEFT JOIN FETCH cobrancaAcaoAtividadeComando.cobrancaAcaoAtividadeComandoLocalidade cobrancaLocalidade "

					+ " WHERE 1 = 1 ";

			if (idsSetoresApartirLocalidadeUnica != null
					&& idsSetoresApartirLocalidadeUnica.length > 0) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.id in (select setor.cobrancaAcaoAtividadeComando.id from CobrancaAcaoAtividadeComandoSetorComercial setor where setor.setorComercial.id in (:idsSetoresApartirLocalidadeUnica)) ";

				parametros.put("idsSetoresApartirLocalidadeUnica",
						idsSetoresApartirLocalidadeUnica);
			}

			if (idsLocalidadeApartirGerenciaRegional != null
					&& idsLocalidadeApartirGerenciaRegional.length > 0) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.id in (select loca.cobrancaAcaoAtividadeComando.id from CobrancaAcaoAtividadeComandoLocalidade loca where loca.localidade.id in (:idsLocalidadeApartirGerenciaRegional)) ";

				parametros.put("idsLocalidadeApartirGerenciaRegional",
						idsLocalidadeApartirGerenciaRegional);
			}

			if (grupoCobranca != null && grupoCobranca.length > 0) {
				sql = sql + " AND cobrancaGrupo.id in (:cobrancaGrupo) ";

				parametros.put("cobrancaGrupo", grupoCobranca);
			}

			if (acaoCobranca != null && acaoCobranca.length > 0) {
				sql = sql + " AND cobrancaAcao.id in (:acaoCobranca) ";

				parametros.put("acaoCobranca", acaoCobranca);
			}

			if (atividadeCobranca != null && atividadeCobranca.length > 0) {
				sql = sql
						+ " AND cobrancaAtividade.id in (:atividadeCobranca) ";

				parametros.put("atividadeCobranca", atividadeCobranca);
			}

			if (idCobrancaAcaoAtividadeComando != null
					&& idCobrancaAcaoAtividadeComando.length > 0) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.id in (:idCobrancaAcaoAtividadeComando) ";

				parametros.put("idCobrancaAcaoAtividadeComando",
						idCobrancaAcaoAtividadeComando);
			}

			if (localidadeUnica != null && !localidadeUnica.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.localidade.id = :localidadeUnica ";

				parametros.put("localidadeUnica", localidadeUnica);
			}

			if (anoMesPeriodoReferenciaContasInicial != null
					&& !anoMesPeriodoReferenciaContasInicial.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.anoMesReferenciaContaInicial = :anoMesReferenciaContaInicial ";

				parametros.put("anoMesReferenciaContaInicial",
						anoMesPeriodoReferenciaContasInicial);
			}

			if (anoMesPeriodoReferenciaContasFinal != null
					&& !anoMesPeriodoReferenciaContasFinal.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.anoMesReferenciaContaFinal = :anoMesReferenciaContaFinal ";

				parametros.put("anoMesReferenciaContaFinal",
						anoMesPeriodoReferenciaContasFinal);
			}

			if (dataPeriodoComandoInicial != null
					&& dataPeriodoComandoFinal != null) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.comando between :dataPeriodoComandoInicial and :dataPeriodoComandoFinal ";

				parametros.put("dataPeriodoComandoInicial",
						dataPeriodoComandoInicial);
				parametros.put("dataPeriodoComandoFinal",
						dataPeriodoComandoFinal);
			}

			if (dataPeriodoRealizacaoComandoInicial != null
					&& dataPeriodoRealizacaoComandoFinal != null) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.realizacao between :dataPeriodoRealizacaoComandoInicial and :dataPeriodoRealizacaoComandoFinal ";

				parametros.put("dataPeriodoRealizacaoComandoInicial",
						dataPeriodoRealizacaoComandoInicial);
				parametros.put("dataPeriodoRealizacaoComandoFinal",
						dataPeriodoRealizacaoComandoFinal);
			}

			if (dataPeriodoVencimentoContasInicial != null) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.dataVencimentoContaInicial = :dataPeriodoVencimentoContasInicial ";

				parametros.put("dataPeriodoVencimentoContasInicial",
						dataPeriodoVencimentoContasInicial);
			}

			if (dataPeriodoVencimentoContasFinal != null) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.dataVencimentoContaFinal = :dataPeriodoVencimentoContasFinal";

				parametros.put("dataPeriodoVencimentoContasFinal",
						dataPeriodoVencimentoContasFinal);
			}

			if (intervaloValorDocumentosInicial != null
					&& intervaloValorDocumentosFinal != null) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.valorDocumentos >= :intervaloValorDocumentosInicial ";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.valorDocumentos <= :intervaloValorDocumentosFinal ";

				parametros.put("intervaloValorDocumentosInicial",
						intervaloValorDocumentosInicial);
				parametros.put("intervaloValorDocumentosFinal",
						intervaloValorDocumentosFinal);
			}

			if (intervaloQuantidadeDocumentosInicial != null
					&& !intervaloQuantidadeDocumentosInicial.equals("")
					&& intervaloQuantidadeDocumentosFinal != null
					&& !intervaloQuantidadeDocumentosFinal.equals("")) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.quantidadeDocumentos >= :intervaloValorDocumentosInicial";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.quantidadeDocumentos <= :intervaloValorDocumentosFinal ";

				parametros.put("intervaloValorDocumentosInicial",
						intervaloValorDocumentosInicial);
				parametros.put("intervaloValorDocumentosFinal",
						intervaloValorDocumentosFinal);
			}

			if (intervaloQuantidadeItensDocumentosInicial != null
					&& !intervaloQuantidadeItensDocumentosInicial.equals("")
					&& intervaloQuantidadeItensDocumentosFinal != null
					&& !intervaloQuantidadeItensDocumentosFinal.equals("")) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.quantidadeItensCobrados >= :intervaloQuantidadeItensDocumentosInicial ";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.quantidadeItensCobrados <= :intervaloQuantidadeItensDocumentosFinal ";

				parametros.put("intervaloQuantidadeItensDocumentosInicial",
						intervaloQuantidadeItensDocumentosInicial);
				parametros.put("intervaloQuantidadeItensDocumentosFinal",
						intervaloQuantidadeItensDocumentosFinal);

			}

			if (situacaoComando != null && !situacaoComando.equals("")) {

				if (situacaoComando.equals("Realizados")) {
					sql = sql
							+ " AND cobrancaAcaoAtividadeComando.realizacao IS NOT NULL";

				} else if (situacaoComando.equals("NaoRealizados")) {
					sql = sql
							+ " AND cobrancaAcaoAtividadeComando.realizacao IS NULL";
				}
			}

			if (indicadorCriterio != null && indicadorCriterio != 0) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.indicadorCriterio = :indicadorCriterio ";

				parametros.put("indicadorCriterio", indicadorCriterio);
			}

			if (idGerenciaRegional != null && !idGerenciaRegional.equals("")) {
				sql = sql + " AND gerenciaRegional.id = :idGerenciaRegional ";

				parametros.put("idGerenciaRegional", idGerenciaRegional);
			}

			if (idLocalidadeInicial != null && !idLocalidadeInicial.equals("")
					&& idLocalidadeFinal != null
					&& !idLocalidadeFinal.equals("")) {

				sql = sql
						+ " AND localidadeInicial.id >= :idLocalidadeInicial ";
				sql = sql + " AND localidadeFinal.id <= :idLocalidadeFinal ";

				parametros.put("idLocalidadeInicial", idLocalidadeInicial);
				parametros.put("idLocalidadeFinal", idLocalidadeFinal);
			}

			if (codigoSetorComercialInicial != null
					&& !codigoSetorComercialInicial.equals("")
					&& codigoSetorComercialFinal != null
					&& !codigoSetorComercialFinal.equals("")) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.codigoSetorComercialInicial >= :codigoSetorComercialInicial ";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.codigoSetorComercialFinal <= :codigoSetorComercialFinal ";

				parametros.put("codigoSetorComercialInicial",
						codigoSetorComercialInicial);
				parametros.put("codigoSetorComercialFinal",
						codigoSetorComercialFinal);
			}

			if (idRotaInicial != null && !idRotaInicial.equals("")
					&& idRotaFinal != null && !idRotaFinal.equals("")) {

				sql = sql + " AND rotaInicial.codigo >= :idRotaInicial ";
				sql = sql + " AND rotaFinal.codigo <= :idRotaFinal ";

				parametros.put("idRotaInicial", idRotaInicial);
				parametros.put("idRotaFinal", idRotaFinal);
			}

			if (idCliente != null && !idCliente.equals("")) {
				sql = sql + " AND cliente.id = :idCliente ";

				parametros.put("idCliente", idCliente);
			}

			if (idClienteRelacaoTipo != null
					&& !idClienteRelacaoTipo.equals("")) {
				sql = sql
						+ " AND clienteRelacaoTipo.id = :idClienteRelacaoTipo ";

				parametros.put("idClienteRelacaoTipo", idClienteRelacaoTipo);
			}

			if (criterioCobranca != null && !criterioCobranca.equals("")) {
				sql = sql + " AND cobrancaCriterio.id = :criterioCobranca ";

				parametros.put("criterioCobranca", criterioCobranca);
			}

			if (unidadeNegocio != null && !unidadeNegocio.equals("")) {
				sql = sql + " AND unidadeNegocio.id = :unidadeNegocio ";

				parametros.put("unidadeNegocio", unidadeNegocio);
			}

			if (dataEmissaoInicial != null) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.comando between :dataEmissaoInicial AND :dataEmissaoFinal ";

				parametros.put("dataEmissaoInicial", dataEmissaoInicial);
				parametros.put("dataEmissaoFinal", dataEmissaoFinal);
			}

			if (consumoMedioInicial != null && !consumoMedioInicial.equals("")
					&& consumoMedioFinal != null
					&& !consumoMedioFinal.equals("")) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.consumoMedioInicial >= :consumoMedioInicial ";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.consumoMedioFinal <= :consumoMedioFinal ";

				parametros.put("consumoMedioInicial", consumoMedioInicial);
				parametros.put("consumoMedioFinal", consumoMedioFinal);

			}

			if (tipoConsumo != null && !tipoConsumo.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.tipoConsumo = :tipoConsumo ";

				parametros.put("tipoConsumo", tipoConsumo);
			}

			if (periodoInicialFiscalizacao != null) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.periodoInicialFiscalizacao >= :periodoInicialFiscalizacao ";

				parametros.put("periodoInicialFiscalizacao",
						periodoInicialFiscalizacao);
			}

			if (periodoFinalFiscalizacao != null) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.periodoFinalFiscalizacao <= :periodoFinalFiscalizacao ";

				parametros.put("periodoFinalFiscalizacao",
						periodoFinalFiscalizacao);
			}

			if (numeroQuadraInicial != null && !numeroQuadraInicial.equals("")
					&& numeroQuadraFinal != null
					&& !numeroQuadraFinal.equals("")) {

				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.numeroQuadraInicial >= :numeroQuadraInicial ";
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.numeroQuadraFinal <= :numeroQuadraFinal ";

				parametros.put("numeroQuadraInicial", numeroQuadraInicial);
				parametros.put("numeroQuadraFinal", numeroQuadraFinal);
			}

			if (quantidadeDiasVencimento != null
					&& !quantidadeDiasVencimento.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.quantidadeDiasVencimento = :quantidadeDiasVencimento ";

				parametros.put("quantidadeDiasVencimento",
						quantidadeDiasVencimento);
			}

			if (ligacaoAlteradaDebito != null
					&& !ligacaoAlteradaDebito.equals("")) {
				sql = sql
						+ " AND cobrancaAcaoAtividadeComando.ligacaoAlteradaDebito = :ligacaoAlteradaDebito ";

				parametros.put("ligacaoAlteradaDebito", ligacaoAlteradaDebito);
			}

			query = session.createQuery(sql);

			Set set = parametros.keySet();
			Iterator iterMap = set.iterator();
			while (iterMap.hasNext()) {
				String key = (String) iterMap.next();

				if (parametros.get(key) instanceof Set) {
					Set setList = (Set) parametros.get(key);
					query.setParameterList(key, setList);
				} else if (parametros.get(key) instanceof Collection) {
					Collection collection = (Collection) parametros.get(key);
					query.setParameterList(key, collection);
				} else if (parametros.get(key) instanceof Integer[]) {
					Integer[] collection = (Integer[]) parametros.get(key);
					query.setParameterList(key, collection);
				} else if (parametros.get(key) instanceof String[]) {
					String[] collection = (String[]) parametros.get(key);
					query.setParameterList(key, collection);
				} else {
					query.setParameter(key, parametros.get(key));
				}
			}
			if (helper.getNumeroPagina() != null) {
				retorno = query.setFirstResult(10 * helper.getNumeroPagina())
						.setMaxResults(10).list();
			} else {
				retorno = query.list();
			}

		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}
		return retorno;

	}

	/**
	 * 
	 * [UC0244] - Manter Comando Ação de Cobrança
	 * 
	 * @author Anderson Cabral
	 * @date 23/12/2013
	 * 
	 */
	public void removerCobrancaAcaoAtividadeComandoSetorComercial(
			Integer idComando) throws ErroRepositorioException {
		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = " DELETE "
					+ " FROM cobranca.cob_acao_atv_cmd_stcm cobstcm  "
					+ " WHERE cobstcm.cacm_id = ? ";

			st = jdbcCon.prepareStatement(delete);
			st.setLong(1, idComando);

			st.executeUpdate();

		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}

	}

	/**
	 * 
	 * [UC0244] - Manter Comando Ação de Cobrança
	 * 
	 * @author Anderson Cabral
	 * @date 23/12/2013
	 * 
	 */
	public void removerCobrancaAcaoAtividadeComandoLocalidade(Integer idComando)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		PreparedStatement st = null;

		try {

			Connection jdbcCon = session.connection();

			String delete = " DELETE "
					+ " FROM cobranca.cob_acao_atv_cmd_loca cobloca  "
					+ " WHERE cobloca.cacm_id = ? ";

			st = jdbcCon.prepareStatement(delete);
			st.setLong(1, idComando);

			st.executeUpdate();

		} catch (SQLException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1581] - Alterar Data Prevista Encerramento Comando Acao Cobranca
	 * 
	 * @author Davi Menezes
	 * @date 15/01/2014
	 */
	public void atualizarDataPrevistaEncerramentoComandoCronograma(Collection<Integer> idsComandos, Date dataPrevista)
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		
		String sql;
		
		PreparedStatement st = null;

		try {
			Connection jdbcCon = session.connection();
			
			sql = "UPDATE cobranca.cobranca_acao_ativ_crg "
				+ "SET caac_dtprevista = ?, caac_tmultimaalteracao = ? "
				+ "WHERE caac_id in ( "
				+ "SELECT ativCronEncerrar.caac_id "
				+ "FROM cobranca.cobranca_acao_ativ_crg ativCron "
				+ "INNER JOIN cobranca.cobranca_acao_ativ_crg ativCronEncerrar " 
				+ "on ativCronEncerrar.cbcr_id = ativCron.cbcr_id and ativCronEncerrar.cbat_id = " + CobrancaAtividade.ENCERRAR + " "
				+ "WHERE ativCron.caac_id in ( ";
			
			for (Integer idComando : idsComandos) {
				sql += idComando + ",";
			}
			
			sql = sql.substring(0, sql.length() - 1) + " ) ) ";
			
			st = jdbcCon.prepareStatement(sql);
			
			st.setDate(1, Util.getSQLDate(dataPrevista));
			st.setTimestamp(2, Util.getSQLTimesTemp(new Date()));
			
			// executa o update
			st.executeUpdate();
			session.flush();

		} catch (SQLException e) {
			// e.printStackTrace();
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			if (null != st)
				try {
					st.close();
				} catch (SQLException e) {
					throw new ErroRepositorioException(e, "Erro no Hibernate");
				}
			HibernateUtil.closeSession(session);
		}
	}

	/**
	 * [UC 1581] - Alterar Data Prevista Encerramento Comando Acao Cobranca
	 * 
	 * @author Davi Menezes
	 * @date 15/01/2014
	 */
	public void atualizarDataPrevistaEncerramentoComandoEventual(Collection<Integer> idsComandos, Date dataPrevista)
			throws ErroRepositorioException {
		
		Session session = HibernateUtil.getSession();
		String sql;

		try {
			sql = "update gcom.cobranca.CobrancaAcaoAtividadeComando "
				+ "set cacm_dtencerramentoprevista = :dataPrevista, cacm_tmultimaalteracao = :dataUltimaAlteracao "
				+ "where cacm_id in (:idsComando) ";

			session.createQuery(sql)
					.setDate("dataPrevista", dataPrevista)
					.setTimestamp("dataUltimaAlteracao", new Date())
					.setParameterList("idsComando", idsComandos)
					.executeUpdate();
		} catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC 1581] - Alterar Data Prevista Encerramento Comando Acao Cobranca
	 * 
	 * @auhtor Davi Menezes
	 * @date 27/01/2014
	 */
	public Date pesquisarDataRealizacaoComandoCronograma(Integer idComando)
			throws ErroRepositorioException {
		
		Date dataRealizacao = null;
		Session session = HibernateUtil.getSession();
		String sql;
		
		try{
			sql = "SELECT ativCronEncerrar.caac_tmrealizacao dataRealizacao "
				+ "FROM cobranca.cobranca_acao_ativ_crg ativCron "
				+ "INNER JOIN cobranca.cobranca_acao_ativ_crg ativCronEncerrar " 
				+ "on ativCronEncerrar.cbcr_id = ativCron.cbcr_id and ativCronEncerrar.cbat_id = " + CobrancaAtividade.ENCERRAR + " "
				+ "WHERE ativCron.caac_id in (:idComando) ";
			
			dataRealizacao = (Date) session.createSQLQuery(sql)
											.addScalar("dataRealizacao", Hibernate.DATE)
											.setInteger("idComando", idComando)
											.setMaxResults(1)
											.uniqueResult();
			
			return dataRealizacao;
		}catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC 1581] - Alterar Data Prevista Encerramento Comando Acao Cobranca
	 * 
	 * @auhtor Davi Menezes
	 * @date 27/01/2014
	 */
	public Date pesquisarDataPrevistaEncerramentoComandoCronograma(Integer idComando)
			throws ErroRepositorioException {
		
		Date dataPrevistaEncerramento = null;
		Session session = HibernateUtil.getSession();
		String sql;
		
		try{
			sql = "SELECT ativCronEncerrar.caac_dtprevista dataPrevistaEncerramento "
				+ "FROM cobranca.cobranca_acao_ativ_crg ativCron "
				+ "INNER JOIN cobranca.cobranca_acao_ativ_crg ativCronEncerrar " 
				+ "on ativCronEncerrar.cbcr_id = ativCron.cbcr_id and ativCronEncerrar.cbat_id = " + CobrancaAtividade.ENCERRAR + " "
				+ "WHERE ativCron.caac_id in (:idComando) ";
			
			dataPrevistaEncerramento = (Date) session.createSQLQuery(sql)
											.addScalar("dataPrevistaEncerramento", Hibernate.DATE)
											.setInteger("idComando", idComando)
											.setMaxResults(1)
											.uniqueResult();
			
			return dataPrevistaEncerramento;
		}catch (HibernateException e) {
			throw new ErroRepositorioException(e, "Erro no Hibernate");
		} finally {
			// fecha a sessao
			HibernateUtil.closeSession(session);
		}
	}
	
	/**
	 * [UC0000] Relatório Opção Totalização por Comando e Opção de Totalização por Mês de Apuração
	 * 
	 * @author Vivianne Sousa
	 * @date 24/04/2014
	 */
	public Collection<Object[]> gerarDadosRelatorioCobrancaPorResultadoPorComandoMes(
			Integer idEmpresa, 
			String periodoApuracao, 
			Integer idLocalidade,
			String[] idsGerenciaRegional, 
			String[] idsUnidadeNegocio,
			String[] idsRegiao, 
			String[] idsMicroRegiao, 
			String[] idsMunicipio,
			short indicadorLocalidade,
			ArrayList colecaoEmpresaCobrancaFaixa,
			Date cicloInicial, 
			Date cicloFinal,
			String[] idsCategoria,
			Integer idComando) throws ErroRepositorioException {

		String sql = "";
		String subsql = "";
		Session session = HibernateUtil.getSession();
		Collection<Object[]> retorno = new ArrayList<Object[]>();

		try {

			EmpresaCobrancaFaixa empresaCobrancaFaixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa.get(0);
			Integer numeroMinimoContas = null;
			Integer numeroMaximoContas = empresaCobrancaFaixa.getNumeroMinimoContasFaixa() - 1;
			
			subsql =  " FROM cobranca.empresa_cobranca_conta ecco "   
					+ " WHERE ecco.cecc_id = ecbm.cecc_id and ecco.loca_id = loca.loca_id and ecco.ecco_pcempresaconta = emcf.emcf_pcfaixa " 
					+ " and exists " 
					+ " 	(select eccc.imov_id  from cobranca.empresa_cobranca_conta eccc "    
					+ " 	where eccc.imov_id = ecco.imov_id and ecco.cecc_id = eccc.cecc_id group by eccc.imov_id " 
					+ "     having ";			
			for (int i = 0; i < colecaoEmpresaCobrancaFaixa.size(); i++) {
				EmpresaCobrancaFaixa faixa = (EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa.get(i);
				numeroMinimoContas = faixa.getNumeroMinimoContasFaixa();
				numeroMaximoContas = null;

				if (i < (colecaoEmpresaCobrancaFaixa.size() - 1)) {
					numeroMaximoContas = ((EmpresaCobrancaFaixa) colecaoEmpresaCobrancaFaixa.get(i + 1)).getNumeroMinimoContasFaixa() - 1;
				}

				if (numeroMaximoContas != null) {
					subsql = subsql
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) between "
							+ numeroMinimoContas + " and " + numeroMaximoContas
							+ " OR ";

				} else {
					subsql = subsql
							+ " count(distinct (CASE WHEN eccc.ecco_pcempresaconta = "
							+ faixa.getPercentualFaixa()
							+ "       THEN  eccc.cnta_id "
							+ "       ELSE NULL END)) >= " + numeroMinimoContas + " )   ";
				}
			}

			sql =   " SELECT " 
				+ "    greg.greg_id 	                     	AS idGerenciaRegional, " 	//0
				+ "    ecbm.loca_id                          	AS idLocalidade, "			//1
				+ "    emcf.emcf_id                          	AS idFaixaContas, "			//2
				+ "    re.regi_id                            	AS idRegiao, "				//3
				+ "    loca.muni_idprincipal                 	AS idMunicipio, "			//4
				+ "    empr.empr_nmempresa                   	AS nomeEmpresa, "			//5
				+ "    ces.cese_dsnumerocontrato             	AS numeroContrato, "		//6
				+ "    ecbm.ecbm_amreferencia                	AS anoMesRef, "				//7
				+ "    loca.loca_id 							AS idLocalidade,   "		//8
				+ "    loca.loca_nmlocalidade                	AS descLocalidade, "		//9
				+ "    mun.muni_nmmunicipio                  	AS descMunicipio, "			//10
				+ "    emcf.emcf_dsfaixa                     	AS descFaixaContas, "		//11
				+ "    (SELECT COUNT(DISTINCT ecco.cnta_id) as qtdeContas " 
				+ 		subsql + " )                       		AS qtdContas, "				//12
				+ "    (SELECT COUNT(DISTINCT ecco.imov_id) as qtdImoveis" 
				+		subsql + " )                     		AS qtdeClientes, "			//13
				+ "    SUM(ecbm.ecbm_vlcontaspagtoavista)    	AS vlPagtoAVista, "			//14
				+ "    SUM(ecbm.ecbm_vlcontaspagtoparcelado) 	AS vlPagtoParcelado, "		//15
				+ "    emcf.emcf_pcfaixa                     	AS percentualFaixa, "		//16
				+ "    greg.greg_nmregional                  	AS descGerenciaRegional, "	//17
				+ "    re.regi_nmregiao                     	AS descRegiao, "			//18
				+ "    SUM(COALESCE(ecbm.ecbm_vldescontos, 0)) 	AS vlDesconto, "			//19
				+ "    (SELECT SUM(ecco.ecco_vloriginalconta) as valorTotal "
				+ 		subsql + " )                       		AS vlTotalDivida, "			//20
				+ "    ecbm.cecc_id                          	AS idComando, "				//21
				+ "    cecc.cecc_dtexecucao                  	AS dataExecucao, "			//22
				+ "    cecc.cecc_dtiniciociclo               	AS dataInicio, "			//23
				+ "    cecc.cecc_dtfimciclo                  	AS dataFinal, "				//24
				+ "    uneg.uneg_ID                          	AS idUnidadeNegocio, "		//25
				+ "    uneg.uneg_nmunidadenegocio            	AS descUnidadeNegocio, "	//26
				+ "    mr.mreg_id                            	AS idMicroregiao, "			//27
				+ "    mr.mreg_nmmicrorregiao                	AS descMicroregiao, "		//28 		
				+ "	   SUM(ecbm.ECBM_QTCONTASPAGTOAVISTA)    	AS qtdePagtoAVista, "       //29
				+ "	   SUM(ecbm.ECBM_QTCONTASPAGTOPARCELADO) 	AS qtdePagtoParcelado "		//30
				
				+ "    FROM cobranca.empr_cobr_conta_bol_med ecbm  "
				+ "    INNER JOIN cobranca.cmd_empr_cobr_conta cecc    		ON (cecc.cecc_id = ecbm.cecc_id) "
				+ "    INNER JOIN cadastro.empr_cobr_faixa emcf        		ON (emcf.emcf_id = ecbm.emcf_id) "
				+ "    INNER JOIN cadastro.imovel imov                 		ON (ecbm.imov_id = imov.imov_id) "
				+ "    LEFT JOIN cadastro.empresa empr                      ON (empr.empr_id = cecc.empr_id) "
				+ "    INNER JOIN cadastro.localidade loca                  ON (loca.loca_id = imov.loca_id) "
				+ "    INNER JOIN cadastro.gerencia_regional greg           ON (greg.greg_id = loca.greg_id) "
				+ "    INNER JOIN cadastro.unidade_negocio uneg             ON (uneg.uneg_id = loca.uneg_id) "
				+ "    INNER JOIN cadastro.municipio mun                    ON (mun.muni_id = loca.muni_idprincipal) "
				+ "    INNER JOIN cadastro.microrregiao mr                  ON (mr.mreg_id = mun.mreg_id) "
				+ "    INNER JOIN cadastro.regiao re                        ON (re.regi_id = mr.regi_id) "
				+ "    INNER JOIN micromedicao.contrato_empresa_servico ces ON (ces.empr_id = cecc.empr_id) ";

			sql +=	  " WHERE " 
					+ "    	empr.empr_icuso           = 1 "
					+ " AND empr.empr_iccobranca      = 1 "
					+ " AND greg.greg_icuso           = 1 ";

			if (idLocalidade != null)
				sql += " AND loca.loca_id = :idLocalidade ";
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				sql += " AND loca.greg_id in (:idsGerenciaRegional) ";
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				sql += " AND loca.uneg_id in (:idsUnidadeNegocio) ";
			if (idsRegiao != null && idsRegiao.length > 0)
				sql += " AND mr.regi_id in (:idsRegiao) ";
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				sql += " AND mr.mreg_id in (:idsMicroRegiao) ";
			if (idsMunicipio != null && idsMunicipio.length > 0)
				sql += " AND mun.muni_id in (:idsMunicipio)";
			if(periodoApuracao != null && !periodoApuracao.equals(""))
				sql += " AND ecbm.ecbm_amreferencia = :anoMesReferencia ";
			if(idEmpresa != null && !idEmpresa.equals(""))
				sql += " AND empr.empr_id = :idEmpresa ";
			if (idsCategoria != null && idsCategoria.length > 0)
				sql += " AND imov.imov_idcategoriaprincipal in (:idsCategoria)";
			if(idComando != null && !idComando.equals(""))
				sql += " AND ecbm.cecc_id = :idComando ";
			
			if (cicloInicial != null && cicloFinal != null) {
				sql += " and cecc.cecc_dtexecucao between to_date('" + Util.formatarDataComTracoAAAAMMDD(cicloInicial)
						+ "','YYYY-MM-DD') and to_date('"+ Util.formatarDataComTracoAAAAMMDD(cicloFinal) + "','YYYY-MM-DD') ";
			}
			
			sql += " GROUP BY greg.greg_id, ecbm.loca_id, emcf.emcf_id, re.regi_id, loca.muni_idprincipal, empr.empr_nmempresa, " +
					"ces.cese_dsnumerocontrato, ecbm.ecbm_amreferencia, loca.loca_id, loca.loca_nmlocalidade, mun.muni_nmmunicipio, " +
					"emcf.emcf_dsfaixa, emcf.emcf_pcfaixa, greg.greg_nmregional, re.regi_nmregiao, ecbm.cecc_id, cecc.cecc_dtexecucao, " +
					"cecc.cecc_dtiniciociclo, cecc.cecc_dtfimciclo, uneg.uneg_ID, uneg.uneg_nmunidadenegocio, mr.mreg_id, mr.mreg_nmmicrorregiao " ;

			if (indicadorLocalidade == ConstantesSistema.INDICADOR_USO_ATIVO)
				sql += " order by  idComando,descGerenciaRegional, descUnidadeNegocio, descLocalidade, anoMesRef, idFaixaContas ";
			else
				sql += " order by  idComando,descRegiao, descMicroregiao,descMunicipio, anoMesRef,idFaixaContas ";

			Query q = session.createSQLQuery(sql)
					.addScalar("idGerenciaRegional", Hibernate.INTEGER)		// 0
					.addScalar("idLocalidade", Hibernate.INTEGER)			// 1
					.addScalar("idFaixaContas", Hibernate.INTEGER)			// 2
					.addScalar("idRegiao", Hibernate.INTEGER)				// 3
					.addScalar("idMunicipio", Hibernate.INTEGER)			// 4
					.addScalar("nomeEmpresa", Hibernate.STRING)				// 5
					.addScalar("numeroContrato", Hibernate.STRING)			// 6
					.addScalar("anoMesRef", Hibernate.STRING)				// 7
					.addScalar("idLocalidade", Hibernate.INTEGER)			// 8
					.addScalar("descLocalidade", Hibernate.STRING)			// 9
					.addScalar("descMunicipio", Hibernate.STRING)			// 10
					.addScalar("descFaixaContas", Hibernate.STRING)			// 11
					.addScalar("qtdContas", Hibernate.INTEGER)				// 12
					.addScalar("qtdeClientes", Hibernate.INTEGER)			// 13
					.addScalar("vlPagtoAVista", Hibernate.BIG_DECIMAL)		// 14
					.addScalar("vlPagtoParcelado", Hibernate.BIG_DECIMAL)	// 15
					.addScalar("percentualFaixa", Hibernate.BIG_DECIMAL)	// 16
					.addScalar("descGerenciaRegional", Hibernate.STRING)	// 17
					.addScalar("descRegiao", Hibernate.STRING)				// 18
					.addScalar("vlDesconto", Hibernate.BIG_DECIMAL)			// 19
					.addScalar("vlTotalDivida", Hibernate.BIG_DECIMAL)		// 20
					.addScalar("idComando", Hibernate.INTEGER)				// 21
					.addScalar("dataExecucao", Hibernate.DATE)				// 22
					.addScalar("dataInicio", Hibernate.DATE)				// 23
					.addScalar("dataFinal", Hibernate.DATE)					// 24
					.addScalar("idUnidadeNegocio", Hibernate.INTEGER)		// 25
					.addScalar("descUnidadeNegocio", Hibernate.STRING)		// 26
					.addScalar("idMicroregiao", Hibernate.INTEGER)			// 27
					.addScalar("descMicroregiao", Hibernate.STRING)			// 28
					.addScalar("qtdePagtoAVista", Hibernate.INTEGER)		// 29
					.addScalar("qtdePagtoParcelado", Hibernate.INTEGER);	// 30
			
			if (idLocalidade != null)
				q.setInteger("idLocalidade", idLocalidade);
			if (idsGerenciaRegional != null && idsGerenciaRegional.length > 0)
				q.setParameterList("idsGerenciaRegional", idsGerenciaRegional);
			if (idsUnidadeNegocio != null && idsUnidadeNegocio.length > 0)
				q.setParameterList("idsUnidadeNegocio", idsUnidadeNegocio);
			if (idsRegiao != null && idsRegiao.length > 0)
				q.setParameterList("idsRegiao", idsRegiao);
			if (idsMicroRegiao != null && idsMicroRegiao.length > 0)
				q.setParameterList("idsMicroRegiao", idsMicroRegiao);
			if (idsMunicipio != null && idsMunicipio.length > 0)
				q.setParameterList("idsMunicipio", idsMunicipio);
			if(periodoApuracao != null && !periodoApuracao.equals(""))
				q.setInteger("anoMesReferencia", new Integer(periodoApuracao));
			if(idEmpresa != null && !idEmpresa.equals(""))
				q.setInteger("idEmpresa", idEmpresa);	
			if (idsCategoria != null && idsCategoria.length > 0)
				q.setParameterList("idsCategoria", idsCategoria);
			if(idComando != null && !idComando.equals(""))
				q.setInteger("idComando", idComando);	

			System.out.println(q.getQueryString());

			retorno = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return retorno;
	}

	/**
	 * [UC1598] Gerar Relatório Cobrança Por Resultado Comando/Mês
	 * 
	 * @author Ana Maria
	 * @date 30/04/2014
	 */
	public Collection<ComandoEmpresaCobrancaConta> obterColecaoComandoEmpresaCobrancaConta(String idEmpresa, 
		Date dataInicialExecucao, Date dataFinalExecucao)
			throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();
		Collection<ComandoEmpresaCobrancaConta> colecaoComando = new ArrayList<ComandoEmpresaCobrancaConta>();
		String hql = "";

		try {
			hql = " SELECT cecc " 
				+ " FROM ComandoEmpresaCobrancaConta cecc "
				+ " WHERE cecc.empresa.id = :idEmpresa" 
				+ " AND (cecc.dataExecucao between :dataInicialExecucao and :dataFinalExecucao)";

			hql += " ORDER BY cecc.id";

			Query q = session.createQuery(hql)
					.setString("idEmpresa",idEmpresa)
					.setDate("dataInicialExecucao", dataInicialExecucao)
					.setDate("dataFinalExecucao", dataFinalExecucao);
			
			colecaoComando = q.list();

		} catch (HibernateException e) {
			e.printStackTrace();
			throw new ErroRepositorioException("Erro no Hibernate");
		} finally {
			HibernateUtil.closeSession(session);
		}

		return colecaoComando;
	}
	
	/**
	 * [UC0178] Processar Pagamentos com c?digo de Barras Auhtor: S?cio Luiz
	 * Data: 06/11/2006
	 * 
	 */
	public void cancelarComandoAcaoCobranca(Collection idsComando) throws ErroRepositorioException {

		Session session = HibernateUtil.getSession();

		String atualizarComandoAcaoCobranca;
		try {
			atualizarComandoAcaoCobranca = "update gcom.cobranca.CobrancaAcaoAtividadeComando "
					+ " set cacm_dtencerramentoprevista = :dataEncerramentoPrevista "
					+ " where cacm_id in (:idsComando)";

			session.createQuery(atualizarComandoAcaoCobranca)
					.setParameterList("idsComando", idsComando)
					.setDate("dataEncerramentoPrevista", new Date()).executeUpdate();

		} catch (Exception e) {
			System.out.println("Erro");

			throw new ErroRepositorioException(e, "Erro no Hibernate");
			
		} finally {
			// fecha a sess?o
			HibernateUtil.closeSession(session);
		}
	}
}